{"posts":[{"title":"🐧Windows Subsystem for Linux","text":"Penguins would not like open windows. Windows家庭中文版升级为专业版1. win11家庭版转专业版密钥 2. windows11家庭版升级专业版 按照文章1的步骤，密钥第四个可以，输入后自动重启升级。 升级后我的显示密钥无效未激活，在终端中输入文章2第二步的三个命令，查看发现升级成功。 启用或关闭Windows功能中没有Hyper-vWindows 没有 Hyper-V 解决方案 WSL2安装Linux发行版开启 WSL2 安装 Ubuntu 当我一切工作准备就绪，使用wsl --update命令升级到最新版的wsl后，仍然出现了错误。 1Error code: Wsl/Service/CreateVm/HCS/HCS_E_HYPERV_NOT_INSTALLED Google后发现有人遇到了和我同样的问题，onomatopellan的回答“勾选Windows Sandbox选项”帮助了我。 使用 wsl --list --online 命令查找可用发行版名称，并用 wsl --install -d &lt;distribution_name&gt; 安装你喜爱的版本。 移动发行版的安装位置。 导出到D盘中：wsl --export Ubuntu D:\\WSL\\Ubuntu\\ubuntu.tar 注销并移除C盘中的发行版：wsl --unregister Ubuntu 导入到D盘中：wsl --import Ubuntu D:\\WSL\\Ubuntu D:\\WSL\\Ubuntu\\ubuntu.tar 修改默认用户：Ubuntu config --default-user &lt;username&gt; 更换镜像源12sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak #备份sudo nano /etc/apt/sources.list #编辑 使用 lsb_release -a 可以查看 ubuntu 的版本，在https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 可以查询对应的镜像源。 Ctrl ^ 记录开始位置，移动光标选择范围，Ctrl K 进行剪切。一些基础的 Linux 操作命令不再赘述。","link":"/2024/07/21/%F0%9F%90%A7Windows-Subsystem-for-Linux/"},{"title":"🔢SageMath","text":"Sage is really a useful and powerful math tool. Python for Linux下面我们准备编写python脚本的IDE。以Ubuntu为例。 在windows中下载安装vscode，并安装名为wsl的连接插件。 在wsl中输入code便可以打开vscode。 新建文件test.py，路径任意，例如/root/test.py。 写入文件，保存后新建终端，使用python3 test.py命令，得到输出。 下面我们说一说pip包管理器。 1sudo apt install python3-pip python3-venv 在虚拟环境中安装python包，以便后续管理。 创建虚拟环境：python3 -m venv myenv。 激活虚拟环境：source myenv/bin/activate。 安装包：pip install &lt;package_name&gt;。 退出：deactivate。 发现下载速度较慢，可以清除下载缓存，更换下载源。 12pip cache purgepip install pwntools -i https://pypi.tuna.tsinghua.edu.cn/simple git Clone使用HTTP协议git clone https://github.com/repo/repo.git经常会遇到问题，可以使用SSH的方法clone一些github库： 创建ssh key：使用ssh-keygen -t rsa -b 4096 -C &quot;your-email&quot;命令，下面的选项全部直接敲回车即可。 随后使用 cat ~/.ssh/id_rsa.pub 命令查看生成的公钥，并完整的复制下来。 在github仓库界面点击自己的头像，选择settings。进入到设置页面后，点击左侧的SSH and GPG keys选项。点击New SSH key选项，并将复制下来的内容粘贴上去，添加该ssh key的描述。随后点击Add SSH key，并一路点击确认即可。 可以使用以下命令检查是否已有SSH密钥：ls -al ~/.ssh，如果你看到 id_rsa 和 id_rsa.pub 文件，说明已经存在SSH密钥。 使用以下命令测试与GitHub的SSH连接：ssh -T git@github.com。 如果一切正常，你会看到类似以下的输出： 1Hi username! You've successfully authenticated, but GitHub does not provide shell access. 使用git clone git@github.com:username/repository.git命令克隆存储库。 install SageMath阅读Sage的官方安装说明Installation Guide即可。 按理说可以按照 Installing SageMath 10.4 in Ubuntu 22.04 or 24.04 一步一步来，编译时会警告root，可以建立一个新用户，七月初10.3版本我也是这么做的，不知道为什么10.4我这里不行了。 也可以在Arch Linux上快速安装SageMath。第一次接触Arch的话，看一些基础的命令叭sudo pacman -Sy/-Syu/-Rns &lt;package_name&gt;/-Scc/...。 Arch的服务器比较慢，可以通过手动编辑镜像列表文件 /etc/pacman.d/mirrorlist，将速度较快的镜像服务器移到顶部。 12Server = https://mirror.tuna.tsinghua.edu.cn/archlinux/$repo/os/$archServer = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch o.0接着就是安装sagemath——sudo pacman -S sagemath sagemath-doc。 等一会儿就成功啦！怎么在sage里调用外来库呢，哭哭&gt;_&lt;sudo pacman -S python-&lt;package_name&gt;。","link":"/2024/07/14/%F0%9F%94%A2SageMath/"},{"title":"💻CNSS Recruit Dev 2024","text":"“Dev can be one of the ways to create everything for you, which will come with a great sense of achievement.” 🥳MAN！作为一名Dev手，学会查找并浏览官方文档是非常重要的能力。本题要求你初步学会使用linux系统自带的一个功能强大的文档：man 。(实际上是manual的英文缩写） 之前没有用过linux？没有关系，来看一下这门课程吧：https://missing-semester-cn.github.io/ CH1首先，你要在电脑上配置一个虚拟环境，这里列出几个方案: 在windows环境下可以使用wsl（比较推荐） 或者可以配置虚拟机 或者有条件可以找一台云服务器或者买另一台实体机。 双系统（步骤比较复杂） 当我们有了linux环境后，不妨在linux环境下使用gcc编译一个自己写的”Hello World!”并运行！ CH2linux有一个很有意思的指令：strace。同时，linux中的指令(command)，系统调用(system call)和库函数(library function) 基本都可以用man 1 [name], man 2 [name] man 3 [name]来了解他们的用法。 假设你在CH1中的程序名为hello。在同目录下运行strace ./hello。结合你看到的man上对strace的阐述，简单解释下运行结果。 In the simplest case strace runs the specified command until it exits. It intercepts and records the system calls which are called by a process and the signals which are received by a process. The name of each system call, its arguments and its return value are printed on standard error or to the file specified with the -o option. 输出展示了程序的执行过程。 execve调用hello_world，传递了PATH、参数和42个环境变量；返回0，成功执行。 brk查询程序数据段末尾位置，返回值是当前内存分配位置，用于管理内存。 mmap为程序分配一块内存，返回分配的内存地址，用于读写操作。 access在检查是否存在ld.so.preload文件，返回错误，没有找到。 openat打开共享库缓存文件，查找程序依赖的共享库；当前程序依赖的libc库被打开，程序返回3。 read、mmap和close表示从库中读取需要的数据。 arch_prctl设置线程本地存储，为多线程环境提供支持。（不懂） set_tid_address和set_robust_list用于线程的初始化、设置线程的标识地址，防止线程被意外中断。（也不懂） mprotect保护内存页面的权限，设置某些内存区域为只读。 （大的要来了）write(1, &quot;hello_world\\n&quot;, 12) = 12，通过write系统调用向文件描述符1即标准输出写入12个字节的字符串。 exit_group顾名思义，结束并正常退出。 +++ exited with 0 +++ CH3运行 man 3 exec。你能写一个运用到了库函数exec的C程序吗？ The exec() family of functions replaces the current process image with a new process image. 写程序调用execve来替换当前的进程。CH2的第一个调用。 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt; //execve所在的头文件extern char **environ; // 引用当前进程的环境变量int main() { // 要执行的程序的路径 char *program = &quot;/bin/ls&quot;; // 参数 char *args[] = {&quot;ls&quot;, NULL}; // 执行 execve 系统调用 if (execve(program, args, environ) == -1) { perror(&quot;execve met problems.&quot;); exit(EXIT_FAILURE); // 使用 EXIT_FAILURE 表示失败退出 } return 0;} 编译和运行这个程序。 12345$ gcc -o execve_exp execve_exp.c$ ./execve_expexecve_exp execve_exp.c hello_world test.c$ lsexecve_exp execve_exp.c hello_world test.c 😶‍🌫️Oop Loop学习c语言的数组部分时，想出了三种遍历二维数组的方法，并想办法测量了这三种方法所使用的时间。”这三种方法都访问了同样数量的数组元素，因此他们所耗费的时间一定是差不多的。“但事情远没有这么简单： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;fcntl.h&gt;#define UNIT_GAP 1000000.0void M_gettimeofday(struct timeval *tv) { int result = gettimeofday(tv, NULL); if(result != 0) { perror(&quot;gettimeofday st\\n&quot;); exit(1); } return ;}#define ArrSize 15000int arr1[ArrSize][ArrSize];int arr2[ArrSize][ArrSize];int arr3[ArrSize][ArrSize];int main() { /* Evaluate iterating pattern 1 */ struct timeval tv_st; M_gettimeofday(&amp;tv_st); for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr1[i][j] += 1; } } struct timeval tv_ed; M_gettimeofday(&amp;tv_ed); double time_gap1 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); /* Evaluate iterating pattern 2 */ M_gettimeofday(&amp;tv_st); for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr2[j][i] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap2 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); /* Evaluate iterating pattern 3 */ M_gettimeofday(&amp;tv_st); for(int i = 0; i &lt; ArrSize; i++) { int cap = (ArrSize / 3) * 3; for(int j = 0; j &lt; cap; j+=3) { arr3[i][j] += 1; arr3[i][j + 1] += 1; arr3[i][j + 2] += 1; } for(int j = cap; j &lt; ArrSize; j++) { arr3[i][j] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap3 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); printf(&quot;time spent for time_gap1: %lf seconds\\n&quot;, time_gap1); printf(&quot;time spent for time_gap2: %lf seconds\\n&quot;, time_gap2); printf(&quot;time spent for time_gap3: %lf seconds\\n&quot;, time_gap3);} 事实上，这三种遍历方式使用的时间有明显的差别。 CH1发现每次程序的运行结果差别都很大，因此需要反复运行程序很多次才能找出不同遍历模式下的时间规律。请你帮他修改程序，让程序的运行结果随机性更小，这样就能找出更加可信的结论了！ 实践出真知，跑一下看看。Oops，感觉1和3的随机性很强，2几乎是最慢的，不过也有少数例外。为了减少随机性，我们可以多次跑代码取平均值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;fcntl.h&gt;#define UNIT_GAP 1000000.0#define ArrSize 15000#define NUM_RUNS 5 //运行5次并取平均值void M_gettimeofday(struct timeval *tv) { int result = gettimeofday(tv, NULL); if(result != 0) { perror(&quot;gettimeofday failed\\n&quot;); exit(1); }}int arr1[ArrSize][ArrSize];int arr2[ArrSize][ArrSize];int arr3[ArrSize][ArrSize];int main() { double total_time1 = 0.0, total_time2 = 0.0, total_time3 = 0.0; for(int run = 0; run &lt; NUM_RUNS; run++) { struct timeval tv_st, tv_ed; M_gettimeofday(&amp;tv_st); /* PATTERN 1 */ for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr1[i][j] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap1 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); total_time1 += time_gap1; M_gettimeofday(&amp;tv_st); /* PATTERN 2 */ for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr2[j][i] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap2 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); total_time2 += time_gap2; M_gettimeofday(&amp;tv_st); /* PATTERN 3 */ for(int i = 0; i &lt; ArrSize; i++) { int cap = (ArrSize / 3) * 3; for(int j = 0; j &lt; cap; j += 3) { arr3[i][j] += 1; arr3[i][j + 1] += 1; arr3[i][j + 2] += 1; } for(int j = cap; j &lt; ArrSize; j++) { arr3[i][j] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap3 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); total_time3 += time_gap3; } printf(&quot;Average time spent for time_gap1: %lf seconds\\n&quot;, total_time1 / NUM_RUNS); printf(&quot;Average time spent for time_gap2: %lf seconds\\n&quot;, total_time2 / NUM_RUNS); printf(&quot;Average time spent for time_gap3: %lf seconds\\n&quot;, total_time3 / NUM_RUNS); return 0;} 嗯，看起来有规律多了：$2&gt;&gt;1&gt;3$。 CH2试回答不同遍历模式下运行时间的差别，并解释为什么会产生这些差别。 1是行优先遍历，这与C中行主序存储数组的方式一致。根据局部性，CPU可以有效地读取连续的内存块，减少缓存未命中次数，提高访问速度。 而2是列优先遍历，与1相反，这种访问模式导致大量缓存未命中、效率低。 关于原理解释那一部分，只靠cpu缓存其实不太能解释 第三个pattern 耗时比第一个pattern小的问题qwq——Shiver 3则使用了循环展开优化。每次处理三个元素，减少了每次更新迭代的控制开销，在大规模进行数组遍历时，会累积成明显的性能提升。 另外由于数组元素是每三个访问的，更容易预取更多数据到缓存中，进一步减少了缓存未命中的损失。 流水线优化：现代处理器使用流水线技术来提高指令执行的效率。3通过减少循环次数和增加每次循环内处理的数据量，减少了其它分支指令，使处理器流水线更顺畅。这可以减少流水线停顿，从而提高整体执行速度。 分支预测：循环的检查条件变少了，分支预测错误的概率也降低了。 可能存在的向量化优化？编译器可以自动将这种每次操作多个相邻元素转换为SIMD指令。这意味着处理器可以在一个指令周期内对多个数据进行相同的操作，提升运算速度。 连续访问多个元素更有可能保持内存对齐，从而减少额外的内存操作开销。 由于循环体内操作相互独立，处理器可以并行处理多个操作，进一步提升速度。 ♿造轮子 Git 是一个分布式版本控制系统，用于跟踪代码或文件的更改，并支持多人协作开发。 你可以在这里看到git的源代码: https://github.com/git/git Shiver想要在自己的电脑上安装git。 以前，他是通过系统的软件包管理器来安装git的。例如，在ubuntu系统中就可以使用这两行命令来安装git： 12$ sudo apt update$ sudo apt install git 但今天，它想换点新花样。他想要通过源代码来编译git！ git的源代码很多地方都有，这里比较推荐使用github上的代码仓库，并通过git clone下载。（不要吐槽为什么电脑上已经有git了为为什么还要下载git源码） 同时，Shiver还通过修改源代码实现了修改git调用版本信息后的输出。 总的来说，Shiver想要你实现如下的操作： 在自己的电脑上编译 git 程序，并在提交文档中简单阐述自己在编译过程中遇到的问题与自己是怎么解决这些问题的。 修改 git 的源代码，使其在输出版本信息时会有额外的 &lt;-- CNSS --&gt; 提示（你也可以添加自己喜欢的信息）并截图提交。（这可能需要你具有一定的代码阅读能力） Hints： 怎么编译？要不先从文档开始，比如源代码中的README.md，INSTALL文件？ 什么是cmake？ A）编译需要依赖，在GPT的帮助下怒装依赖项。 1sudo apt install -y make libssl-dev libcurl4-gnutls-dev libexpat1-dev gettext B）获取Git的源码并编译Git程序： 1234git clone git@github.com:git/git.gitmake configure./configure --prefix=/usr/local #指定安装路径，防止冲突make C）遇到报错信息： 12345678910/usr/bin/ld: libgit.a(utf8.o): in function `reencode_string_iconv':/home/aununo/CNSS/git/utf8.c:498:(.text+0x10dd): undefined reference to `libiconv'/usr/bin/ld: libgit.a(utf8.o): in function `reencode_string_len':/home/aununo/CNSS/git/utf8.c:593:(.text+0x121d): undefined reference to `libiconv_open'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:603:(.text+0x1252): undefined reference to `libiconv_close'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:593:(.text+0x129e): undefined reference to `libiconv_open'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:603:(.text+0x12c9): undefined reference to `libiconv_close'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:598:(.text+0x136b): undefined reference to `libiconv_open'collect2: error: ld returned 1 exit statusmake: *** [Makefile:2842: git-daemon] Error 1 大概是说缺少 libiconv 库的引用。libiconv 是一个用于字符编码转换的库，而 Git 在处理字符集转换时依赖于它。我们使用命令 123$ ldconfig -p | grep libiconv #检查libiconv是否成功安装 libiconv_hook.so.1 (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so.1 libiconv_hook.so (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so 系统上有 libiconv_hook.so，而不是标准的 libiconv.so。由于 libiconv_hook 并没有提供 libiconv.so 的标准接口，导致了编译和测试时出现错误。创建符号链接： 1sudo ln -s /lib/x86_64-linux-gnu/libiconv_hook.so.1 /lib/x86_64-linux-gnu/libiconv.so.2 让系统中的 libiconv_hook.so 模拟 libiconv.so.2，验证一下： 12345$ ldconfig -p | grep libiconv libiconv_hook.so.1 (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so.1 libiconv_hook.so (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so libiconv.so.2 (libc6,x86-64) =&gt; /usr/local/lib/libiconv.so.2 libiconv.so (libc6,x86-64) =&gt; /usr/local/lib/libiconv.so 然后进行make编译成功！再复现一遍。 使用的版本基于 2.46.2，并且在此版本发布后有 628 次提交。 当前版本对应的具体提交哈希是 6258f68c3c。（复现前后面还有个.dirty表示在工作目录中有未提交的更改） Git 的版本信息由 git --version 命令生成，输出git version，下面我们进行查找： 1grep -r &quot;git version&quot; . 把大量输出喂给GPT发现： 123./help.c: * with external projects that rely on the output of &quot;git version&quot;../help.c: strbuf_addf(buf, &quot;git version %s\\n&quot;, git_version_string);./help.c: N_(&quot;git version [--build-options]&quot;), Here it is! 在vscode中查找并编辑help.c文件，修改输出即可。 12strbuf_addf(buf, &quot;git version %s\\n&quot;, git_version_string);=&gt; strbuf_addf(buf, &quot;&lt;-- CNSS --&gt; git version %s I l0v3 Sh1v3r~\\n&quot;, git_version_string); 重新make一下，输出时发现后面多了一个dirty。是修改了help.c却没提交更改的缘故。 可以看到输出&lt;-- CNSS --&gt; git version 2.46.2.628.g6258f68c3c.dirty I l0v3 Sh1v3r~ ⚒️Dig and Dig ssg是一名资深的Minecraft玩家，平时最喜欢的就是在MC的辽阔土地上寻找珍贵的矿石。 CH1从原版到整合包，从我的世界到泰拉瑞亚，ssg挖矿的足迹分布在各个领域。 有一天，他突然好奇想挖挖看 C语言程序，于是他写下了这段代码： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int depth;void Dig (int digging) { if (digging &lt; 0) { return ; } int where_are_we; printf(&quot;In depth %d, we are at %p \\n&quot;, (depth - digging), (void *) &amp;where_are_we); Dig(digging - 1);}int main() { printf(&quot;Today we will dig: &quot;); scanf(&quot;%d&quot;, &amp;depth); printf(&quot;Let begin!\\n&quot;); Dig(depth);} 他决定先向下面挖掘 10 个函数的深度，于是他将depth 变量设置为了 10 并得到了这样的结果： Today we will dig: 10Let begin!In depth 0, we are at 0x7fffbc3fea14In depth 1, we are at 0x7fffbc3fe9e4In depth 2, we are at 0x7fffbc3fe9b4In depth 3, we are at 0x7fffbc3fe984In depth 4, we are at 0x7fffbc3fe954In depth 5, we are at 0x7fffbc3fe924In depth 6, we are at 0x7fffbc3fe8f4In depth 7, we are at 0x7fffbc3fe8c4In depth 8, we are at 0x7fffbc3fe894In depth 9, we are at 0x7fffbc3fe864In depth 10, we are at 0x7fffbc3fe834 看起来不错，于是他决定继续向下挖，但不知道为什么，当 depth 足够大时，程序就终止运作了！ 因此 ssg 找到你，想请你帮他解决这些问题： 尝试修改程序，使ssg的这个程序能统计他 总共 能够向下挖掘多少个 Byte。多次运行这个程序，每次能向下挖的Byte是固定的吗？ 运行初始程序看看depth的最大值，发现每次运行得到的最大深度相近但不同。比如： 123456789101112$ ./digToday we will dig: 1000000Let begin!...In depth 174513, we are at 0x7ffcccda07a4[1] 2146 segmentation fault ./dig# ----------------------------------- #In depth 174450, we are at 0x7ffda0d677a4[1] 2165 segmentation fault ./dig# ----------------------------------- #In depth 174576, we are at 0x7ffc72f5f7a4[1] 2688 segmentation fault ./dig 第一次运行，程序在174513处崩溃，而第二次运行在174450处崩溃，操作系统为进程分配的栈空间每次可能会略有不同，因此这些深度值并不完全一致。segmentation fault的段错误发生在程序试图访问未被允许访问的内存区域时。 [1] 是Linux系统为每个后台任务分配的作业号，1表示这是当前会话的第一个后台进程。 2146和2165是进程ID，是系统为每个运行程序分配的唯一标识符。 记录一下初始地址，用where_are_we减初始地址得到所在深度： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int depth;void *initial_address = NULL;void Dig (int digging) { if (digging &lt; 0) { return ; } int where_are_we; if (initial_address == NULL) { initial_address = &amp;where_are_we; } int current_depth_bytes = abs((char *) initial_address - (char *) &amp;where_are_we); printf(&quot;In depth %d, we are at %p, depth in bytes: %d \\n&quot;, (depth - digging), (void *) &amp;where_are_we, current_depth_bytes); Dig(digging - 1);}int main() { printf(&quot;Today we will dig: &quot;); scanf(&quot;%d&quot;, &amp;depth); printf(&quot;Let begin!\\n&quot;); Dig(depth); return 0;} 运行一下程序： 1234567$ ./digToday we will dig: 100Let begin!In depth 0, we are at 0x7ffdd7afae10, depth in bytes: 0In depth 1, we are at 0x7ffdd7afade0, depth in bytes: 48...In depth 100, we are at 0x7ffdd7af9b50, depth in bytes: 4800 发现每次能向下挖的字节数是固定的48字节。 尝试解释为什么depth足够大时程序会停止运行。 递归深度过深，发生了栈溢出。函数的递归调用会在栈上分配内存，而栈的大小是有限的。当递归深度超出系统分配给程序的栈内存时，程序就会发生栈溢出，从而导致程序崩溃。 尝试解释为什么每次层数的间隔都为 48Byte, 这48Byte里面都包含了些什么？ 函数调用过程中的栈帧结构，说明这个函数中一个栈帧大小为48byte。包含：函数的返回地址，局部变量，函数参数等。 比如将函数内部的局部变量where_are_we类型改为long时，层数间隔会变为64byte。 CH2ssg在挖矿的时候是左右手交替进行的，因此他想记录下自己在挖掘每一层时使用的是左手还是右手，于是他写下了这段代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;int depth;char* WhichHand(bool hand) { return hand ? &quot;left hand&quot; : &quot;right hand&quot;;}bool Dig1 (int digging) { if( digging &lt; 0) { return 0; } bool now_hand = !Dig1(digging - 1); printf(&quot;In depth %d, we use %s \\n&quot;, (depth - digging), WhichHand(now_hand)); return now_hand;}bool Dig2 (int digging, bool hand) { if( digging &lt; 0) { return hand; } printf(&quot;In depth %d, we use %s \\n&quot;, (depth - digging), WhichHand(hand)); return Dig2(digging - 1, !hand);}int main() { printf(&quot;Today we will dig: &quot;); scanf(&quot;%d&quot;, &amp;depth); printf(&quot;Let begin!\\n&quot;); Dig1(depth); //Dig2(depth, 0);} Dig1和Dig2是他编写的两个不同版本但是效果相似的函数，看起来运行的不错： Today we will dig: 10Let begin!In depth 10, we use left handIn depth 9, we use right handIn depth 8, we use left handIn depth 7, we use right handIn depth 6, we use left handIn depth 5, we use right handIn depth 4, we use left handIn depth 3, we use right handIn depth 2, we use left handIn depth 1, we use right handIn depth 0, we use left hand 但ssg发现了一个很严重的问题，当他使用 O2 优化(即在gcc编译时添加-O2指令)分别编译运行了两个不同版本的函数后，有一个版本的函数，无论他将深度设置为多大，都可以正常运行！ 他现在想考考你: 哪个版本的函数无论设置多大的深度都可以正常运行？ dig2函数。我们来跑一下： 12345678910111213141516$ gcc -O2 -o dig1 dig1.c #O2优化启用了包括-Wunused-result在内的警告，检查scanf返回值dig1.c: In function ‘main’:dig1.c:34:5: warning: ignoring return value of ‘scanf’ declared with attribute ‘warn_unused_result’ [-Wunused-result] 34 | scanf(&quot;%d&quot;, &amp;depth); |$ ./dig1Today we will dig: 1000000Let begin![1] 1727 segmentation fault ./dig# ----------------------------------- #$ ./dig2Today we will dig: 1000000Let begin!...In depth 999999, we use left handIn depth 1000000, we use right hand 为什么？ dig1函数仍然是使用了普通递归的方式，即使开O2优化编译，栈空间的限制依然存在。 而dig2函数使用尾递归，大多数编译器，比如这里的gcc中，开了O2尾递归可以被优化为普通循环实现，每次递归不需要额外占用栈帧，只需将函数参数改变再调用一次，就不会触发栈溢出。 谈一谈这道题对你在实际项目开发中的启发。 用递归，深度较大时，警惕栈溢出； 合理使用尾递归； 了解编译器和语言的优化能力，有助于提高程序的运行效率； developers应当编写健壮的代码，做好代码测试，关注边界条件。 🧮Primes香肠非常痴迷于筛法求素数表，大致原理如下 于是他先用 JavaScript 编写了下面这样的代码 1234567891011121314151617function* iota(i, n) { while (i &lt; n) yield i++}function* filter(g, p) { for (x of g) { if (x % p) yield x }}g = iota(2, 100)while (true) { var {value, done} = g.next() if (done) break g = filter(g, value) console.log(value)} 程序成功打印了 100 以内的所有素数。 为了让更多人理解这段代码，他又编写了 Python 版本 123456789101112131415161718def iota(i, n): while i &lt; n: yield i i += 1def filter(g, p): for x in g: if x % p: yield xg = iota(2, 100)try: while True: value = next(g) g = filter(g, value) print(value)except StopIteration: pass 程序虽然正确，但 IDE 给出了警告：用户定义的 filter 函数隐藏了 Python 内置的 filter 函数。 说来也是，为什么不直接使用更泛化的内置 filter 函数呢？于是他又把程序改成了这样。 12345678910111213def iota(i, n): while i &lt; n: yield i i += 1g = iota(2, 100)try: while True: value = next(g) g = filter(lambda incoming: incoming % value, g) print(value)except StopIteration: pass 很遗憾的是，程序输出的结果不再正确。到底是哪里出了问题？ 在调试的过程中，香肠觉得不能光调 Python 代码，JavaScript 的也不能放过。 考虑到 Python 采用了更泛化 filter 函数，于是他把原 JavaScript 代码也改成了这样。 1234567891011121314151617function* iota(i, n) { while (i &lt; n) yield i++}function* filter(g, p) { for (x of g) { if (p(x)) yield x }}g = iota(2, 100)while (true) { var {value, done} = g.next() if (done) break g = filter(g, incoming =&gt; incoming % value) console.log(value)} 竟然出现了和第二份 Python 代码一样的错误输出结果。这是巧合吗？ 本题筛素数的协程叫什么协程？你能简单描述一下这样筛素数的过程吗？ 在JavaScript或Python中，利用惰性求值的生成器，可以逐步生成一个序列，并能在筛选过程中动态修改序列，避免占用过多计算资源。 1234567g = iota(2, 100)while (true) { var {value, done} = g.next() if (done) break g = filter(g, value) console.log(value)} 核心思想是埃拉托斯特尼筛法（Sieve of Eratosthenes）。生成器iota生成一个从2到99的整数序列g，每次调用g中的值并通过生成器filter筛掉素数value的倍数，输出value，再移动到下一个数进行循环。 为什么第二份 Python 和第二份 JavaScript 的代码有问题？两者的问题是一样的吗？ 请你在第二份 Python 和第二份 JavaScript 基础上修改代码，在不失一般性的情况下解决存在的问题。 两者的问题不一样。 Python是和其延时绑定的机制有关。Python在真正执行函数（如lambda）的时候才会查找变量的值，而不是在定义函数时。 1g = filter(lambda incoming: incoming % value, g) 而在同一个作用域下，value的值始终针对同一个变量在变化，而不是每次循环都创建一个新变量。因此，所有的lambda中引用的value都会使用最新的值。 可以采用默认参数的方法解决这个问题。 12345678910111213def iota(i, n): while i &lt; n: yield i i += 1g = iota(2, 100)try: while True: value = next(g) g = filter(lambda incoming, value=value: incoming % value, g) print(value)except StopIteration: pass 这样，参数只会初始化一次，而在之后的循环中保持不变。 手动即时捕获。 12345678910111213def iota(i, n): while i &lt; n: yield i i += 1g = iota(2, 100)try: while True: value = next(g) g = filter((lambda value: lambda incoming: incoming % value)(value), g) print(value)except StopIteration: pass 而JavaScript是与var的作用域规则有关。var在JavaScript中的作用域是函数作用域，而不是块作用域。循环体中每次声明的value实际上会在整个函数的作用域中共享，lambda函数捕获的是对同一个变量的引用，所以value会在每次循环后更新。 可以使用 let 代替 var。 1234567891011121314151617function* iota(i, n) { while (i &lt; n) yield i++}function* filter(g, p) { for (x of g) { if (p(x)) yield x }}g = iota(2, 100)while (true) { let {value, done} = g.next() if (done) break g = filter(g, incoming =&gt; incoming % value) console.log(value)} 因为 let 是块作用域，在每次循环中会为 value 绑定一个新的变量，这样每个 lambda 函数都能捕获到当前循环中的 value，而不是共享的全局变量。 ⭐数数 计算机往往不够聪明（或者太过聪明），以至于他只会完全按照你的指令办事，尽管有时候你自己都不知道自己的指令是什么含义 CH1这道题目并不难，你要做的只是让计算机学会数数而已。 比如： 123456789101112131415161718192021222324252627#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load;void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { (* (int *)counter_ptr) += 1; } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); int counter; worker(&amp;counter); worker(&amp;counter); printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 十分简单对吧？但是柳苏明却认为，让同一个 worker函数运行两遍效率太低了。为什么不雇佣两个 worker， 让他们同时工作呢？换句话说，他决定使用 多线程！ 于是他十分好心的给了你两份代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// V1#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load;void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { (* (int *)counter_ptr) += 1; } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter1, counter2; pthread_create(&amp;thread1, NULL, worker, &amp;counter1); pthread_create(&amp;thread2, NULL, worker, &amp;counter2); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(&quot;Totally count: %d\\n&quot;, counter1 + counter2); return 0;}//V2#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load;void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { (* (int *)counter_ptr) += 1; } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter; pthread_create(&amp;thread1, NULL, worker, &amp;counter); pthread_create(&amp;thread2, NULL, worker, &amp;counter); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 但问题出现了，尽管第一份代码可以正常运行，但第二份代码在 输入值很大 时总是出现奇怪的偏差。 尝试运行测试这两段代码，回答： 为什么两份相似的代码会有不同的输出结果？ V1中每个线程独立地操作各自的counter1和counter2，互不干扰，最终把两个计数器的结果加和得到答案。 V2中通过多线程并发地对同一变量counter进行修改，这种操作存在竞争条件。意味着两个线程可能同时读写共享变量counter，导致计数不准确，尤其是在工作负荷较大的时候。 在编写多线程代码时，如何避免这种错误？ 引入同步机制，使用互斥锁来保证线程的独立访问，确保在同一时刻只有一个线程可以操作变量，避免竞争条件。 尝试只修改 worker 函数来使第二份代码输出正确。 123456789101112131415161718192021222324252627282930313233343536//V2#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load; pthread_mutex_t lock; //锁的声明void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { pthread_mutex_lock(&amp;lock); //上锁 (* (int *)counter_ptr) += 1; pthread_mutex_unlock(&amp;lock); //解锁 } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter; pthread_mutex_init(&amp;lock, NULL); //锁的初始化 pthread_create(&amp;thread1, NULL, worker, &amp;counter); pthread_create(&amp;thread2, NULL, worker, &amp;counter); pthread_join(thread1, NULL); pthread_join(thread2, NULL); pthread_mutex_destroy(&amp;lock); //销毁 printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 运行一下，对比更改前后： 1234567$ ./countgive the workload per thread: 1000000000Totally count: 1007291379#------------------------------------------#$ ./countgive the workload per thread: 1000000000Totally count: 2000000000 CH2了解”互斥锁”这个概念，思考： 两个线程都同时访问了同一个变量：互斥锁 对于互斥锁的访问难道不会产生数据竞争吗？ 回答: 为什么访问互斥锁不会产生数据竞争？ 请尝试自己编写一个互斥锁(额外加分) 【操作系统】锁的实现 当一个线程获取互斥锁时，其他线程尝试获取必须等待，直到当前线程释放锁。互斥锁的实现由底层硬件或操作系统支持，通常通过某种原子操作，当一个线程访问其他线程持有的锁时，会被 OS 调度为阻塞状态（休眠），直到锁被释放后，再唤醒一个休眠的线程。 （另外，自旋锁是一种忙等待锁。它在锁被其他线程持有时不会阻塞当前线程，而是不断地尝试获取锁，直到锁可用为止。这种忙等待的行为称为“自旋”。） 使用了原子操作来实现互斥锁的加锁和解锁逻辑。 1234567891011121314151617typedef struct { atomic_int lock_flag;} my_mutex_t;void my_mutex_init(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);}void my_mutex_lock(my_mutex_t *mutex) { while (atomic_exchange(&amp;mutex-&gt;lock_flag, 1) == 1) { sched_yield() //挂起，而非忙等待 } }void my_mutex_unlock(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);} 完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdatomic.h&gt;#include &lt;sched.h&gt;typedef struct { atomic_int lock_flag;} my_mutex_t;void my_mutex_init(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);}void my_mutex_lock(my_mutex_t *mutex) { while (atomic_exchange(&amp;mutex-&gt;lock_flag, 1) == 1) { sched_yield(); }}void my_mutex_unlock(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);}int work_load;my_mutex_t my_mutex;void *worker(void *counter_ptr) { for (int i = 0; i &lt; work_load; i++) { my_mutex_lock(&amp;my_mutex); (*(int *)counter_ptr) += 1; my_mutex_unlock(&amp;my_mutex); } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter = 0; my_mutex_init(&amp;my_mutex); pthread_create(&amp;thread1, NULL, worker, &amp;counter); pthread_create(&amp;thread2, NULL, worker, &amp;counter); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 📟BitterCH112345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define BOARD_SIZE 8int upper_lim = 1;int count = 0;/** int row: store the valid bit after applying the vertical rule* int ld: store the valid bit after applying the left diagram rule* int rd: store the valid bit after applying the right diagram rule* bit '0' represent where we can place a chess*/void solve_problem(int row ,int ld, int rd) { if( row == upper_lim) { count += 1; return ; } /* 'current' represent all the valid bit*/ int current = upper_lim &amp; (~ (row | ld | rd)); int buffer = current; while(buffer) { int valid = buffer &amp; (-buffer); buffer -= valid; solve_problem(row|valid, (ld|valid)&lt;&lt;1, (rd|valid)&gt;&gt;1); /////////////////////////////////////// }}/* board_size shouldn't be too large */void find_n_th_queen(int board_size ) { upper_lim = (1 &lt;&lt; board_size) - 1; solve_problem(0, 0, 0);}int main() { find_n_th_queen(BOARD_SIZE); printf(&quot;Answer: %d&quot;, count);}// Answer: 92 CH2用位来标记数组元素的状态。 1234567891011121314151617181920212223242526def solve(nums): n = len(nums) states = 1 &lt;&lt; n max_sum = 0 for state in range(states): valid = True curr_sum = 0 for i in range(n): if state &amp; (1 &lt;&lt; i): #choose ith element curr_sum += nums[i] if i &gt; 0 and (state &amp; (1 &lt;&lt; (i - 1))): #conflict valid = False break if valid: max_sum = max(max_sum, curr_sum) return max_sumnums = [1, 15, 3, 7, 12, 10, 19, 8, 5, 17, 2, 6, 11, 9, 4, 14, 13, 18, 16, 20]print(solve(nums))'''130[Done] exited with code=0 in 0.965 seconds''' 动态规划可以显著降低时间。 加密算法：AES中存在行移位，哈希算法会使用位移、异或操作，提供安全性 快速运算：位移操作快速计算，奇偶判断，节约时间，bitset筛素数可节省空间 文件权限：使用位运算可以方便地开启或关闭某些标志位 并行计算：位运算可以快速地启用或禁用某个线程或者检查某个线程的状态 🎩顺手牵羊要求：使用C语言实现一个自己的抓包软件 使用libpcap库实现抓包。 程序应该实现：判断并输出每个包的类型，包的长度，以及包的源地址和目的地址。 如果你能实现对于TCP包的捕获，可以获得70%的分数。如果你能实现至少三种包的分析捕获，可以获得剩下30%的分数。 简单阐述下你对抓包的实现原理的理解，最高可得额外的20%分数。 hint：要不下载一个wireshark体验下抓包？ 题解： 在C语言中使用libpcap库来进行抓包操作。 安装libpcap库； 1sudo apt install libpcap-dev 实现对TCP包的捕获； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;pcap.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt; //提供了IP地址的转换函数#include &lt;netinet/ip.h&gt;#include &lt;netinet/tcp.h&gt; //定义了IP和TCP头部的结构体// 回调函数在每次捕获到数据包时被调用void packet_handler(u_char *user_data, const struct pcap_pkthdr *pkthdr, const u_char *packet) { struct ip *ip_header = (struct ip *)(packet + 14); //跳过以太网帧头(14)、获取ip头 struct tcphdr *tcp_header = (struct tcphdr *)(packet + 14 + ip_header-&gt;ip_hl * 4); //获取TCP头 printf(&quot;&lt;--------- New Packet Arrived! ---------&gt;\\n&quot;); printf(&quot;Total packet available: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;Expected packet size: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;IP header length (IHL) in bytes: %d\\n&quot;, ip_header-&gt;ip_hl * 4); printf(&quot;Source Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_src)); printf(&quot;Destination Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_dst)); printf(&quot;TCP header length in bytes: %d\\n&quot;, tcp_header-&gt;th_off * 4); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header-&gt;ip_hl * 4 + tcp_header-&gt;th_off * 4); printf(&quot;Payload size: %d bytes\\n&quot;, pkthdr-&gt;len - (ip_header-&gt;ip_hl * 4 + tcp_header-&gt;th_off * 4)); printf(&quot;---------------------------------------\\n&quot;);} //三个参数分别表示：用户传递的数据、数据包头部信息、指向实际的数据包内容int main() { char errbuf[PCAP_ERRBUF_SIZE]; pcap_if_t *alldevs; pcap_if_t *device; pcap_t *handle; // 调用函数获取所有可用设备列表 if (pcap_findalldevs(&amp;alldevs, errbuf) == -1) { fprintf(stderr, &quot;Error finding devices: %s\\n&quot;, errbuf); return 1; } // 选择第一个设备 device = alldevs; printf(&quot;Using device: %s\\n&quot;, device-&gt;name); // 打开设备 handle = pcap_open_live(device-&gt;name, BUFSIZ, 1, 1000, errbuf); pcap_loop(handle, 0, packet_handler, NULL); //捕获数据包，回调 pcap_freealldevs(alldevs); pcap_close(handle); return 0;} 编译运行上述代码，打开firefox，捕获到数据包： 1234567891011121314$ gcc -o packet_sniffer packet_sniffer -lpcap$ sudo ./packet_snifferUsing device: loopback0&lt;--------- New Packet Arrived! ---------&gt;Total packet available: 1514 bytesExpected packet size: 1514 bytesIP header length (IHL) in bytes: 20Source Address: 127.0.0.1Destination Address: 127.0.0.1TCP header length in bytes: 32Size of all headers combined: 52 bytesPayload size: 1462 bytes---------------------------------------...... 这些数据包是在 WSL 2 内部通过 loopback 接口进行的本地通信，源头和目的地都是127.0.0.1。查找网络接口： 12345678910$ ip addr...4: loopback0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:15:5d:78:40:b2 brd ff:ff:ff:ff:ff:ff5: eth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether e0:2e:0b:08:09:53 brd ff:ff:ff:ff:ff:ff inet 192.168.0.144/24 brd 192.168.0.255 scope global noprefixroute eth2 valid_lft forever preferred_lft forever inet6 fe80::66a7:f661:86e5:c634/64 scope link nodad noprefixroute valid_lft forever preferred_lft forever 发现eth2是当前唯一状态为 UP 且配置了 IP 地址的接口，是WSL主要用于与外部网络通信的接口。修改代码： 1234567891011121314151617int main() { ... // 查找名为 &quot;eth2&quot; 的设备 for (device = alldevs; device != NULL; device = device-&gt;next) { if (strcmp(device-&gt;name, &quot;eth2&quot;) == 0) { found = 1; break; } } if (!found) { printf(&quot;Device eth2 not found. Make sure you have the necessary permissions.\\n&quot;); pcap_freealldevs(alldevs); return 1; } ...} 编译运行结果如下： 1234567891011&lt;--------- New Packet Arrived! ---------&gt;Total packet available: 66 bytesExpected packet size: 66 bytesIP header length (IHL) in bytes: 20Source Address: 192.168.0.144Destination Address: 34.107.243.93TCP header length in bytes: 32Size of all headers combined: 52 bytesPayload size: 14 bytes---------------------------------------... 实现对TCP、UDP和ICMP三种包的捕获： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;pcap.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/ip.h&gt;#include &lt;netinet/tcp.h&gt;#include &lt;netinet/udp.h&gt;#include &lt;netinet/ip_icmp.h&gt;// 回调函数，用于处理捕获的数据包void packet_handler(u_char *user_data, const struct pcap_pkthdr *pkthdr, const u_char *packet) { struct ip *ip_header = (struct ip *)(packet + 14); // 跳过以太网头部（Ethernet header） int ip_header_length = ip_header-&gt;ip_hl * 4; printf(&quot;&lt;--------- New Packet Arrived! ---------&gt;\\n&quot;); printf(&quot;Total packet available: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;Expected packet size: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;IP header length (IHL) in bytes: %d\\n&quot;, ip_header_length); printf(&quot;Source Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_src)); printf(&quot;Destination Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_dst)); // 检查IP包的协议字段以确定其类型 switch (ip_header-&gt;ip_p) { case IPPROTO_TCP: { struct tcphdr *tcp_header = (struct tcphdr *)(packet + 14 + ip_header_length); int tcp_header_length = tcp_header-&gt;th_off * 4; printf(&quot;Protocol: TCP\\n&quot;); printf(&quot;TCP header length in bytes: %d\\n&quot;, tcp_header_length); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header_length + tcp_header_length); printf(&quot;Payload size: %d bytes\\n&quot;, pkthdr-&gt;len - (ip_header_length + tcp_header_length)); break; } case IPPROTO_UDP: { struct udphdr *udp_header = (struct udphdr *)(packet + 14 + ip_header_length); int udp_header_length = 8; // UDP header 固定长度为 8 字节 printf(&quot;Protocol: UDP\\n&quot;); printf(&quot;UDP header length in bytes: %d\\n&quot;, udp_header_length); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header_length + udp_header_length); printf(&quot;Payload size: %d bytes\\n&quot;, ntohs(udp_header-&gt;len) - udp_header_length); break; } case IPPROTO_ICMP: { struct icmphdr *icmp_header = (struct icmphdr *)(packet + 14 + ip_header_length); int icmp_header_length = 8; // ICMP header 通常为 8 字节 printf(&quot;Protocol: ICMP\\n&quot;); printf(&quot;ICMP header length in bytes: %d\\n&quot;, icmp_header_length); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header_length + icmp_header_length); printf(&quot;Payload size: %d bytes\\n&quot;, pkthdr-&gt;len - (ip_header_length + icmp_header_length)); break; } default: printf(&quot;Protocol: Other\\n&quot;); break; } printf(&quot;---------------------------------------\\n&quot;);}int main() { char errbuf[PCAP_ERRBUF_SIZE]; pcap_if_t *alldevs; pcap_if_t *device; pcap_t *handle; int found = 0; // 使用 pcap_findalldevs 来获取所有可用设备 if (pcap_findalldevs(&amp;alldevs, errbuf) == -1) { fprintf(stderr, &quot;Error finding devices: %s\\n&quot;, errbuf); return 1; } // 查找名为 &quot;eth2&quot; 的设备 for (device = alldevs; device != NULL; device = device-&gt;next) { if (strcmp(device-&gt;name, &quot;eth2&quot;) == 0) { found = 1; break; } } if (!found) { printf(&quot;Device eth2 not found. Make sure you have the necessary permissions.\\n&quot;); pcap_freealldevs(alldevs); return 1; } printf(&quot;Using device: %s\\n&quot;, device-&gt;name); // 打开设备 handle = pcap_open_live(device-&gt;name, BUFSIZ, 1, 1000, errbuf); if (handle == NULL) { printf(&quot;Could not open device %s: %s\\n&quot;, device-&gt;name, errbuf); pcap_freealldevs(alldevs); return 1; } // 开始捕获数据包 pcap_loop(handle, 0, packet_handler, NULL); // 释放设备列表 pcap_freealldevs(alldevs); pcap_close(handle); return 0;} 运行代码抓包： 123456789101112&lt;--------- New Packet Arrived! ---------&gt;Total packet available: 90 bytesExpected packet size: 90 bytesIP header length (IHL) in bytes: 20Source Address: 185.125.190.57Destination Address: 192.168.0.144Protocol: UDPUDP header length in bytes: 8Size of all headers combined: 28 bytesPayload size: 48 bytes---------------------------------------... 首先找到可用的网络接口，确保抓包工具监听到指定网络接口上的所有数据包；打开网络接口，置于混杂模式（1），以便捕获所有经过该接口的数据包；循环捕获包，调用回调函数，解析IP包头的字段，判断包所使用的传输层协议等等。 libpcap通过操作系统的网络驱动从链路层捕获数据包，将其暂存在内核缓冲区中，然后将数据包传递到用户空间供应用程序分析。 参考内容： C语言如何做抓包 👿busin的野心要求：请你写个程序，自动检测排行榜的变化。具体有如下两个需求： 招新网站的排行榜包含10个招新相关方向以及一个总分方向。如果这11个类别中的任意一个排行的前十名发生了变化，程序就会打印：1.新的前十名排行 2.哪一个人掉出了前十名 3.哪一个人进入了前十名。 程序应该监测特定的题目（使用动态容器的题目可以不被监测）。当有人通过了这个题目后，程序会按照f&quot;passer: {user_name}, task: {task_name}, time: {passing_time}&quot;打印出这条信息。 将程序部署在服务器上实现24h运行，并能通过社交软件/邮箱/其他能从移动设备上接收到更新信息的方式，将信息发送到你的移动设备上，实现可视化的管理界面。 (ps:这可能需要一点SA的知识） 题解：首先编写程序rank.py实现打印排名变化情况。 在https://recruit.cnss.io/#/rank上，刷新页面在浏览器控制台网络中找到了fullrank，其通过XHR获取数据，说明排行榜的数据可能是通过该请求动态加载的。于是我们模拟浏览器的请求，**由于Token在随着时间变化，于是添加手动输入Token的部分：** 12345678910111213141516171819202122232425262728293031323334import requestsimport jsondef fetch(url, token): headers = { &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br, zstd&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Host&quot;: &quot;recruit.cnss.io:8443&quot;, &quot;Origin&quot;: &quot;https://recruit.cnss.io&quot;, &quot;Referer&quot;: &quot;https://recruit.cnss.io/&quot;, &quot;Sec-CH-UA&quot;: '&quot;Google Chrome&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;129&quot;', &quot;Sec-CH-UA-Mobile&quot;: &quot;?0&quot;, &quot;Sec-CH-UA-Platform&quot;: '&quot;Windows&quot;', &quot;Sec-Fetch-Dest&quot;: &quot;empty&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-site&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;, &quot;Token&quot;: token } try: response = requests.get(url, headers=headers) if response.status_code == 200: return response.json() else: print(f&quot;Failed to fetch rankings. HTTP Status Code: {response.status_code}&quot;) print(f&quot;Response content: {response.text}&quot;) return None except requests.exceptions.RequestException as e: print(f&quot;Error fetching rankings: {e}&quot;) return None 主函数流程，记录old_rankings.json文件，fetch得到new_rankings，对新旧排行进行比较，打印信息，更新old_rankings。 12345678910111213141516171819202122232425def main(): url = &quot;https://recruit.cnss.io:8443/v1/fullrank&quot; token = input(&quot;Please enter your access token: &quot;).strip() if not token: print(&quot;Your Token cannot be NULL.&quot;) return try: with open(&quot;old_rankings.json&quot;, &quot;r&quot;) as file: old_rankings = json.load(file) except FileNotFoundError: old_rankings = {} new_rankings = fetch(url, token) if new_rankings: changes = compare(old_rankings, new_rankings) print_changes(changes) with open(&quot;old_rankings.json&quot;, &quot;w&quot;, encoding='utf-8') as file: json.dump(new_rankings, file, ensure_ascii=False, indent=4)if __name__ == &quot;__main__&quot;: main() 下面是compare和print函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def compare(old_rankings, new_rankings): changes = {} for direction, new_top10 in new_rankings.items(): old_top10 = old_rankings.get(direction, []) old_top10_users = [item['Name'] for item in old_top10[:10] if 'Name' in item] new_top10_users = [item['Name'] for item in new_top10[:10] if 'Name' in item] entered = set(new_top10_users) - set(old_top10_users) dropped = set(old_top10_users) - set(new_top10_users) order_changed = old_top10_users != new_top10_users #judge if entered or dropped or order_changed: changes[direction] = { 'new_top10': [{'Name': item['Name'], 'Score': item['Score']} for item in new_top10[:10] if 'Name' in item], 'entered': list(entered), 'dropped': list(dropped), 'order_changed': order_changed } return changesdef print_changes(changes): if not changes: print(&quot;排名未发生变化。&quot;) return for direction, details in changes.items(): print(f&quot;\\n方向: {direction}&quot;) print(&quot;新的前十名排行:&quot;) for rank, user in enumerate(details['new_top10'], start=1): print(f&quot; 名次 {rank}: {user['Name']} (得分: {user['Score']})&quot;) if details['entered']: print(f&quot;进入前十名的人: {', '.join(details['entered'])}&quot;) else: print(&quot;没有新进入前十名的人。&quot;) if details['dropped']: print(f&quot;掉出前十名的人: {', '.join(details['dropped'])}&quot;) else: print(&quot;没有掉出前十名的人。&quot;) if details['order_changed']: print(&quot;前十名内部顺序发生了变化。&quot;) 运行一下，得到输出。 接下来我们编写task.py程序。以一道题为例，我的思路是先在题目tasks那个页面，捕获特定题目的pass_number，当通过人数发生变化时，遍历用户，在passrecord寻找该题的通过者，异步化代码实现如下 Python异步网络编程利器——详解aiohttp的使用教程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import aiohttpimport asyncioimport jsonfrom datetime import datetimeTASK_URL = &quot;https://recruit.cnss.io:8443/v1/tasks/534&quot;PASSRECORD_URL_TEMPLATE = &quot;https://recruit.cnss.io:8443/v1/passrecord/{}&quot;TARGET_TASK_TITLE = &quot;👿busin的野心&quot;USER_ID_RANGE = range(530, 535)SLEEP_INTERVAL = 6previous_pass_number = Noneuser_submissions = {}token = &quot;&quot;async def fetch_pass_number(session): headers = { &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br, zstd&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Host&quot;: &quot;recruit.cnss.io:8443&quot;, &quot;Origin&quot;: &quot;https://recruit.cnss.io&quot;, &quot;Referer&quot;: &quot;https://recruit.cnss.io/&quot;, &quot;Sec-CH-UA&quot;: '&quot;Google Chrome&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;129&quot;', &quot;Sec-CH-UA-Mobile&quot;: &quot;?0&quot;, &quot;Sec-CH-UA-Platform&quot;: '&quot;Windows&quot;', &quot;Sec-Fetch-Dest&quot;: &quot;empty&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-site&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;, &quot;Token&quot;: token } try: async with session.get(TASK_URL, headers=headers) as response: response.raise_for_status() data = await response.json() tasks = data.get('dev', []) for task in tasks: if task.get('title') == TARGET_TASK_TITLE: return task.get('pass_number') except aiohttp.ClientError as e: print(f&quot;获取任务数据时发生异常: {e}&quot;) except Exception as e: print(f&quot;处理任务数据时发生异常: {e}&quot;) return Noneasync def fetch_user_submission(session, user_id): headers = { &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br, zstd&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Host&quot;: &quot;recruit.cnss.io:8443&quot;, &quot;Origin&quot;: &quot;https://recruit.cnss.io&quot;, &quot;Referer&quot;: &quot;https://recruit.cnss.io/&quot;, &quot;Sec-CH-UA&quot;: '&quot;Google Chrome&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;129&quot;', &quot;Sec-CH-UA-Mobile&quot;: &quot;?0&quot;, &quot;Sec-CH-UA-Platform&quot;: '&quot;Windows&quot;', &quot;Sec-Fetch-Dest&quot;: &quot;empty&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-site&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;, &quot;Token&quot;: token } url = PASSRECORD_URL_TEMPLATE.format(user_id) try: async with session.get(url, headers=headers) as response: response.raise_for_status() return await response.json() except aiohttp.ClientError as e: print(f&quot;获取用户 {user_id} 的数据时出错: {e}&quot;) except Exception as e: print(f&quot;处理用户 {user_id} 的数据时出错: {e}&quot;) return None 整个函数的逻辑是这样的：通过fetch初始化每个用户（这里是530到535）的提交内容，记录下来，然后每6秒去监测特定题目的通过人数有没有发生变化，一旦发生变化，调用check函数遍历比对，打印出信息。 12345678910111213141516171819async def main(): global token token = input(&quot;请输入Token: &quot;).strip() if not token: print(&quot;Token不能为空。&quot;) return user_ids = USER_ID_RANGE async with aiohttp.ClientSession() as session: await initialize_user_records(session, user_ids) while True: await monitor_pass_number(session, user_ids) await asyncio.sleep(SLEEP_INTERVAL)if __name__ == &quot;__main__&quot;: try: asyncio.run(main()) except KeyboardInterrupt: print(&quot;\\n程序已手动终止。&quot;) 下面我们完善遍历用户，进行初始化用户的提交内容： 12345678910async def initialize_user_records(session, user_ids): global user_submissions tasks = [fetch_user_submission(session, user_id) for user_id in user_ids] submissions = await asyncio.gather(*tasks) for user_id, submission in zip(user_ids, submissions): if submission is not None: user_submissions[user_id] = submission print(f&quot;初始记录已保存用户 {user_id}。&quot;) else: print(f&quot;未能获取用户 {user_id} 的初始记录。&quot;) 接着监测特定题目人数并在变化时遍历： 123456789101112131415161718192021222324252627282930313233343536373839404142async def monitor_pass_number(session, user_ids): global previous_pass_number current_pass_number = await fetch_pass_number(session) if current_pass_number is not None: if previous_pass_number is None: previous_pass_number = current_pass_number print(f&quot;初始 pass_number: {current_pass_number}&quot;) elif current_pass_number &gt; previous_pass_number: print(f&quot;pass_number 增加了！新的 pass_number: {current_pass_number}&quot;) await check_user_submission_changes(session, user_ids) previous_pass_number = current_pass_number else: print(f&quot;当前 pass_number: {current_pass_number}&quot;) else: print(&quot;无法获取 pass_number&quot;)async def check_user_submission_changes(session, user_ids): global user_submissions tasks = [fetch_user_submission(session, user_id) for user_id in user_ids] submissions = await asyncio.gather(*tasks) for user_id, new_submission in zip(user_ids, submissions): if new_submission is None: continue previous_submission = user_submissions.get(user_id, []) new_tasks = {task['TaskID']: task for task in new_submission} old_tasks = {task['TaskID']: task for task in previous_submission} for task_id, new_task in new_tasks.items(): old_task = old_tasks.get(task_id) if not old_task or old_task.get('Score') != new_task.get('Score'): if new_task.get('TaskTitle') == TARGET_TASK_TITLE: user_name = f&quot;User {user_id}&quot; task_name = new_task.get('TaskTitle') passing_time = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) print(f&quot;passer: {user_name}, task: {task_name}, time: {passing_time}&quot;) user_submissions[user_id] = new_submission 运行上述代码，得到输出结果。速度有明显提升。 🤖GPT2目标：你可能已经发现了，你的程序可能并没有我演示的跑的那么快（神机请忽略）。 你的目标就是优化该程序的性能，在保证结果不变的情况下更快的完成文本的补全。 我会使用一些测试点来评测你的程序的正确性和执行时间。期待更高的效率和更多样的优化方案。 此外，请在 wp 中回答下面的问题： 什么是阿姆达尔定律？根据阿姆达尔定律，我们应该把优化的重点放在哪里？ 你的优化方案和思路是什么？优化的效果受到哪些因素影响？ 题解：按照指示完成GPT2，make运行一下，发现需要20多秒。 阿姆达尔定律是一个经验法则，代表处理器并行运算之后效率提升的能力。在并行计算中，使用多个处理器的程序的加速比受限制于程序串行部分的执行时间。$$s(n)=\\frac{1}{B+(1-B)/n}$$ $s(n):$ 固定负载下，理论上的加速比 $B:$ 串行工作部分所占比例，取值0~1 $n:$ 并行线程数，并行处理节点个数 可以看出，即使我们增加处理器数量，只能对并行部分产生影响，而对非并行部分没有任何影响。因此随着处理器数量增加，整体性能的提升会趋于平缓。 根据阿姆达尔定律，应该将优化重点放在最小化串行部分，同时最大化可并行部分。 浏览源gpt.c代码中注意到，存在矩阵乘法、注意力机制和涉及大量计算的循环，可以进行并行计算，将任务分配到多个处理器上，使用OpenMP并行化矩阵乘法、前馈神经网络层等。 具体操作是在matmul_forward和attention_forward函数循环前添加代码： 12#include &lt;omp.h&gt;#pragma omp parallel for collapse(2) 同时，在MakeFile中开启编译选项-fopenmp。 12345release: cc gpt.c -lm -O3 -fopenmp -Wno-unused-result -Wno-unused-value -Wno-unused-variable -o gptdebug: cc gpt.c -lm -O1 -g -fopenmp -Wno-unused-result -Wno-unused-value -Wno-unused-variable -o gpt 前后对比一下 在保证结果不变的情况下更快的（5~6秒)完成了文本的补全。 优化效果受影响的因素： 串行部分：总加速比会受到制约 硬件资源：可用处理器的数量和硬件的性能 编译器的优化程度 并行化的开销。","link":"/2024/12/04/%F0%9F%92%BBCNSS-Recruit-Dev-2024/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"CNSS","slug":"CNSS","link":"/tags/CNSS/"}],"categories":[{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"},{"name":"Crypto","slug":"Crypto","link":"/categories/Crypto/"}],"pages":[{"title":"","text":"一名普普通通热爱生活的计算机本科生。","link":"/about/index.html"}]}